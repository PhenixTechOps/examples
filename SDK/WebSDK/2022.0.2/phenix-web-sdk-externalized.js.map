{"version":3,"sources":["webpack://phenix-web-sdk/webpack/universalModuleDefinition","webpack://phenix-web-sdk/webpack/bootstrap","webpack://phenix-web-sdk/external \"phenix-web-lodash-light\"","webpack://phenix-web-sdk/external \"phenix-web-assert\"","webpack://phenix-web-sdk/external \"phenix-rtc\"","webpack://phenix-web-sdk/external \"phenix-web-disposable\"","webpack://phenix-web-sdk/external \"phenix-web-observable\"","webpack://phenix-web-sdk/external \"phenix-web-event\"","webpack://phenix-web-sdk/./src/sdk/streaming/stream.json.js","webpack://phenix-web-sdk/external \"phenix-web-http\"","webpack://phenix-web-sdk/external \"phenix-web-logging\"","webpack://phenix-web-sdk/./src/sdk/DimensionsChangedMonitor.js","webpack://phenix-web-sdk/./src/sdk/environment.js","webpack://phenix-web-sdk/external \"phenix-web-application-activity-detector\"","webpack://phenix-web-sdk/./src/sdk/streaming/FeatureDetector.js","webpack://phenix-web-sdk/./src/sdk/room/member.json.js","webpack://phenix-web-sdk/./src/sdk/room/room.json.js","webpack://phenix-web-sdk/./src/sdk/logging/pcastLoggerFactory.js","webpack://phenix-web-sdk/external \"phenix-web-proto\"","webpack://phenix-web-sdk/./src/sdk/PCastEndPoint.js","webpack://phenix-web-sdk/./src/sdk/streaming/PeerConnection.js","webpack://phenix-web-sdk/./src/sdk/room/Stream.js","webpack://phenix-web-sdk/./src/sdk/room/stream.json.js","webpack://phenix-web-sdk/./src/sdk/PCast.js","webpack://phenix-web-sdk/external \"phenix-web-detect-browser\"","webpack://phenix-web-sdk/./src/sdk/protocol/telemetryProto.json.js","webpack://phenix-web-sdk/./src/sdk/audio/AudioContext.js","webpack://phenix-web-sdk/./src/sdk/streaming/PeerConnectionMonitor.js","webpack://phenix-web-sdk/./src/sdk/sdpUtil.js","webpack://phenix-web-sdk/./src/sdk/streaming/PhenixLiveStream.js","webpack://phenix-web-sdk/./src/sdk/streaming/BitRateMonitor.js","webpack://phenix-web-sdk/external \"phenix-web-global\"","webpack://phenix-web-sdk/./src/sdk/room/RoomService.js","webpack://phenix-web-sdk/./src/sdk/authentication/AuthenticationService.js","webpack://phenix-web-sdk/./src/sdk/room/Room.js","webpack://phenix-web-sdk/./src/sdk/room/Member.js","webpack://phenix-web-sdk/./src/sdk/room/track.json.js","webpack://phenix-web-sdk/./src/sdk/userMedia/UserMediaResolver.js","webpack://phenix-web-sdk/./src/sdk/express/PCastExpress.js","webpack://phenix-web-sdk/./src/sdk/AdminApiProxyClient.js","webpack://phenix-web-sdk/./src/sdk/express/RoomExpress.js","webpack://phenix-web-sdk/./src/sdk/express/MemberSelector.js","webpack://phenix-web-sdk/./src/sdk/room/Channel.js","webpack://phenix-web-sdk/./src/web-sdk.js","webpack://phenix-web-sdk/./src/sdk/logging/telemetryAppenderFactory.js","webpack://phenix-web-sdk/./src/sdk/logging/TelemetryAppender.js","webpack://phenix-web-sdk/./src/sdk/PCastProtocol.js","webpack://phenix-web-sdk/./src/sdk/protocol/pcastProto.json.js","webpack://phenix-web-sdk/./src/sdk/protocol/chatProto.json.js","webpack://phenix-web-sdk/external \"phenix-web-closest-endpoint-resolver\"","webpack://phenix-web-sdk/./src/sdk/userMedia/ScreenShareExtensionManager.js","webpack://phenix-web-sdk/./src/sdk/userMedia/UserMediaProvider.js","webpack://phenix-web-sdk/./src/sdk/telemetry/metricsTransmitterFactory.js","webpack://phenix-web-sdk/./src/sdk/telemetry/MetricsTransmitter.js","webpack://phenix-web-sdk/./src/sdk/telemetry/StreamTelemetry.js","webpack://phenix-web-sdk/./src/sdk/telemetry/SessionTelemetry.js","webpack://phenix-web-sdk/./src/sdk/telemetry/NetworkMonitor.js","webpack://phenix-web-sdk/./src/sdk/streaming/StreamWrapper.js","webpack://phenix-web-sdk/./src/sdk/streaming/ShakaRenderer.js","webpack://phenix-web-sdk/./src/sdk/streaming/PhenixPlayerRenderer.js","webpack://phenix-web-sdk/./src/sdk/streaming/FlashRenderer.js","webpack://phenix-web-sdk/./src/sdk/streaming/PhenixRealTimeStream.js","webpack://phenix-web-sdk/./src/sdk/streaming/PhenixRealTimeRenderer.js","webpack://phenix-web-sdk/./src/sdk/room/ImmutableRoom.js","webpack://phenix-web-sdk/./src/sdk/chat/RoomChatService.js","webpack://phenix-web-sdk/./src/sdk/chat/ChatService.js","webpack://phenix-web-sdk/./src/sdk/audio/AudioSpeakerDetector.js","webpack://phenix-web-sdk/./src/sdk/audio/AudioVolumeMeterFactory.js","webpack://phenix-web-sdk/./src/sdk/audio/AudioVolumeMeter.js","webpack://phenix-web-sdk/./src/sdk/audio/AudioSpeakerDetectionAlgorithm.js","webpack://phenix-web-sdk/./src/sdk/bandwidth/BandwidthMonitor.js","webpack://phenix-web-sdk/./src/sdk/bandwidth/PublisherBandwidthAdjuster.js","webpack://phenix-web-sdk/./src/sdk/userMedia/ResolutionProvider.js","webpack://phenix-web-sdk/./src/sdk/streaming/shaka.json.js","webpack://phenix-web-sdk/./src/sdk/express/ChannelExpress.js","webpack://phenix-web-sdk/./src/sdk/room/ChannelService.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC5FF,gD;;;;;;ACAA,gD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACtHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,uBAA2B;AAC/B,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,gFAAgF,IAAI,2BAA2B;;AAE/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChIF,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAY;AAChB,IAAI,uBAAmB;AACvB,IAAI,uBAAoB;AACxB,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACnMF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACpEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAoB;AACxB,IAAI,uBAAgB;AACpB,IAAI,uBAA4B;AAChC,CAAC,mCAAE;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC1DF,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAmB;AACvB,IAAI,sBAAyB;AAC7B,IAAI,sBAAuB;AAC3B,IAAI,uBAAsC;AAC1C,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uEAAuE,mBAAmB;AAC1F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;;AAEA,0EAA0E,sBAAsB;AAChG;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;;AAEA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,IAAI;AACb;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACzLF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,+DAA+D;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC5VF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAe;AACnB,IAAI,uBAAc;AAClB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC5KF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACtCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAA8B;AAClC,IAAI,sBAAiB;AACrB,IAAI,uBAA0C;AAC9C,IAAI,uBAAe;AACnB,IAAI,uBAAsB;AAC1B,IAAI,uBAAiB;AACrB,IAAI,uBAAiB;AACrB,IAAI,uBAAyC;AAC7C,IAAI,uBAA+B;AACnC,IAAI,uBAAmC;AACvC,IAAI,sBAA4B;AAChC,IAAI,uBAAuC;AAC3C,IAAI,uBAA6B;AACjC,IAAI,uBAA8B;AAClC,IAAI,uBAA4B;AAChC,IAAI,uBAA2B;AAC/B,IAAI,uBAA8B;AAClC,IAAI,uBAAkC;AACtC,IAAI,uBAA6B;AACjC,IAAI,sBAAyB;AAC7B,IAAI,uBAA4B;AAChC,IAAI,sBAAY;AAChB,IAAI,uBAAW;AACf,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,YAAY,gBAAgB;;AAExE;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,+DAA+D,uCAAuC;AACtG;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE,gCAAgC;;AAExG;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA,oEAAoE,gCAAgC;;AAEpG;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAAgD,YAAY,uCAAuC;AACnG;AACA,iDAAiD;;AAEjD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+DAA+D,uCAAuC;AACtG;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE,gCAAgC;;AAEpG;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,KAAkF;AACzH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0CAA0C,uCAAuC;AACjF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uEAAuE;AACvE;AACA;;AAEA,uFAAuF;AACvF;AACA;;AAEA,qFAAqF;AACrF;AACA;;AAEA,+EAA+E;AAC/E;AACA;;AAEA,iFAAiF;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iCAAiC,GAAG;AACrD;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,gHAAgH;AAChH;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,qBAAqB;;AAErB;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;;AAEhC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iCAAiC,GAAG;AACrD;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;;AAEhC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,4FAA4F;AAC5F;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gFAAgF;AAChF,sFAAsF;;AAEtF;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA,2IAA2I,SAAS;AACpJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,6IAA6I,iDAAiD;AAC9L;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACnoEF,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACpcF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC1CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAY;AAChB,IAAI,uBAAY;AAChB,IAAI,uBAAkB;AACtB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACjdF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACvNF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAY;AAChB,IAAI,uBAAiB;AACrB,IAAI,uBAAwB;AAC5B,IAAI,uBAAiB;AACrB,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA,8EAA8E;AAC9E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACvLF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA,+CAA+C;;AAE/C;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC/HF,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAAyC;AAC7C,IAAI,uBAAQ;AACZ,IAAI,uBAAiB;AACrB,IAAI,uBAAU;AACd,IAAI,uBAAyB;AAC7B,IAAI,uBAAa;AACjB,IAAI,uBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA,sCAAsC,sBAAsB;AAC5D,0CAA0C,0BAA0B;AACpE,0CAA0C,0BAA0B;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,GAAG,cAAc;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gDAAgD,iBAAiB;AACjE;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACt4BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAU;AACd,IAAI,uBAAa;AACjB,CAAC,mCAAE;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACnOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAU;AACd,IAAI,uBAAe;AACnB,CAAC,mCAAE;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yFAAyF,eAAe;AACxG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACvMF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACtCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAY;AAChB,IAAI,uBAAsB;AAC1B,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2FAA2F;AAC3F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC/kBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAwB;AAC5B,IAAI,uBAAgC;AACpC,IAAI,uBAAU;AACd,IAAI,sBAAY;AAChB,IAAI,uBAAyB;AAC7B,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,aAAa;AACrF,4EAA4E,aAAa;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,6CAA6C,mBAAmB,cAAc;;AAE9E,uEAAuE;AACvE;AACA;AACA;AACA,SAAS,wDAAwD;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA,kDAAkD;;AAElD,2EAA2E;AAC3E;AACA;AACA;AACA,SAAS,4DAA4D;;AAErE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,GAAG,kBAAkB;AAClC;;AAEA,sFAAsF,kBAAkB;AACxG;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,qBAAqB;;AAE9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,qCAAqC;AACtE;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,qEAAqE,oBAAoB;AACzF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,oEAAoE,oBAAoB;AACxF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,eAAe;AACtD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,+DAA+D;;AAE/D;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA,kHAAkH,uCAAuC;AACzJ,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,qBAAqB;;AAElE;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,eAAe;AACtD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gEAAgE;;AAEhE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;;AAEA;AACA;;AAEA,kDAAkD,qBAAqB;;AAEvE;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC12CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAiB;AACrB,IAAI,sBAAuB;AAC3B,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;AACzC;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA,4BAA4B,uBAAuB;;AAEnD;AACA;;AAEA,sKAAsK;;AAEtK;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;;AAEnD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;;AAEnD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA,uCAAuC,2BAA2B;AAClE;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;;AAEA,0BAA0B,GAAG,kCAAkC;AAC/D;;AAEA;AACA;AACA,qCAAqC;AACrC;;AAEA;;AAEA;AACA,mCAAmC,4CAA4C;AAC/E;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,iBAAiB;AACrD;;AAEA,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChVF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAAgB;AACpB,IAAI,uBAAqB;AACzB,IAAI,uBAAkB;AACtB,IAAI,uBAAgB;AACpB,IAAI,uBAAmB;AACvB,IAAI,uBAAqB;AACzB,IAAI,uBAAqB;AACzB,IAAI,uBAAoB;AACxB,IAAI,uBAA8B;AAClC,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,kBAAkB;AAC3E;;AAEA;AACA;;AAEA;AACA,qDAAqD,0CAA0C;AAC/F;;AAEA;AACA;;AAEA;AACA;;AAEA,6CAA6C,+BAA+B;;AAE5E;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA,6CAA6C,mBAAmB,cAAc;;AAE9E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iEAAiE,oBAAoB;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,gCAAgC;AAC3E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,kCAAkC;AACzE;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uCAAuC,+BAA+B;AACtE;;AAEA;AACA;;AAEA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,GAAG,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,GAAG,kBAAkB;AACtC;;AAEA;AACA,wCAAwC,0BAA0B;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD,yBAAyB;;AAEhF;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qGAAqG,kBAAkB;;AAEvH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4GAA4G,kBAAkB;AAC9H,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,yBAAyB;;AAEnF;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mDAAmD,yBAAyB;AAC5E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D;;AAE5D;;AAEA;AACA;AACA,0DAA0D,yBAAyB;;AAEnF;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;AACb,uCAAuC,wBAAwB;AAC/D;;AAEA,+CAA+C,aAAa,aAAa;;AAEzE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iEAAiE,oBAAoB;AACrF;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C,YAAY,gFAAgF;;AAE3I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE,oBAAoB;AACzF;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,YAAY,gFAAgF;;AAE3I;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,gCAAgC,aAAa;AAC7C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACpgDF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC3PF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACrGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAyB;AACzB,IAAI,sBAAY;AAChB,IAAI,sBAAoB;AACxB,IAAI,uBAAa;AACjB,IAAI,uBAAwB;AAC5B,IAAI,uBAAkC;AACtC,IAAI,uBAAkC;AACtC,IAAI,uBAAmC;AACvC,IAAI,uBAA4B;AAChC,IAAI,uBAA2B;AAC/B,IAAI,uBAA8B;AAClC,IAAI,uBAA2B;AAC/B,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC/DF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAAgB;AACpB,IAAI,uBAAqB;AACzB,CAAC,mCAAE;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChDF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAY;AAChB,IAAI,sBAAoB;AACxB,IAAI,uBAAkB;AACtB,IAAI,uBAAiC;AACrC,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAkB;AACtB,IAAI,sBAAY;AAChB,IAAI,uBAA4B;AAChC,IAAI,uBAA2B;AAC/B,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,aAAa;AACzF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC3YF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AClgEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC54BF,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gFAAgF,gBAAgB;AAChG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,kDAAkD,wBAAwB;;AAE1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACzRF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS,+CAA+C;AACxD;AACA,SAAS,gFAAgF;AACzF;AACA,SAAS,gDAAgD;AACzD;AACA,SAAS,qFAAqF;AAC9F;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC/PF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAAgB;AACpB,IAAI,uBAAsB;AAC1B,CAAC,mCAAE;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACjDF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAAkB;AACtB,IAAI,sBAAY;AAChB,IAAI,uBAAiC;AACrC,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACpGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;AACA,uCAAuC,KAAG;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,SAAS,4BAA4B;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,wCAAwC;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qCAAqC,oBAAoB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mDAAmD,+BAA+B;AAClF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oDAAoD,mDAAmD,GAAG,2DAA2D;;AAErK;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,4CAA4C,sBAAsB;;AAElE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA8C,eAAe;AAC7D,aAAa;AACb,8CAA8C,cAAc;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC7TF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAA0C;AAC9C,IAAI,uBAAkB;AACtB,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;;AAEA;AACA,uCAAuC,KAAG;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,SAAS,4BAA4B;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC,4BAA4B;;AAE/D;AACA;;AAEA;AACA;;AAEA,mCAAmC,4BAA4B;;AAE/D;AACA;;AAEA;AACA;;AAEA,0CAA0C,aAAa,SAAS,4BAA4B;;AAE5F;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,uBAAuB,GAAG,4BAA4B,GAAG,4BAA4B;;AAE/H;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,eAAe,GAAG,eAAe,GAAG,4BAA4B;;AAE5G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD,mBAAmB,GAAG,mBAAmB,GAAG,4BAA4B;;AAEjI;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACzPF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,CAAC,mCAAE;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACtGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AClJF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAiB;AACrB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,IAAI,sBAA6B;AACjC,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,8DAA8D;AAChF,uBAAuB,kBAAkB,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,2BAA2B;AAC1D;AACA;;AAEA;AACA,sCAAsC,+CAA+C;AACrF;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wEAAwE;;AAExE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT,6DAA6D,sBAAsB,yBAAyB;AAC5G;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C,uBAAuB,SAAS;AAChC;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACrZF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAoB;AACxB,IAAI,sBAAkB;AACtB,IAAI,sBAAiB;AACrB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,IAAI,sBAA6B;AACjC,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,mCAAmC;;AAEzE;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,qBAAqB;AACrB,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC9WF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAoB;AACxB,IAAI,sBAAkB;AACtB,IAAI,sBAAiB;AACrB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,IAAI,sBAA6B;AACjC,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC7RF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAY;AAChB,IAAI,sBAAuB;AAC3B,IAAI,uBAA0C;AAC9C,IAAI,uBAAkB;AACtB,IAAI,uBAAyB;AAC7B,IAAI,uBAAkB;AACtB,IAAI,uBAA0B;AAC9B,IAAI,uBAAmB;AACvB,IAAI,sBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC3WF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAkB;AACtB,IAAI,sBAAiB;AACrB,IAAI,sBAAuB;AAC3B,IAAI,sBAAY;AAChB,IAAI,uBAA0C;AAC9C,IAAI,uBAA2B;AAC/B,IAAI,uBAAmB;AACvB,IAAI,sBAA6B;AACjC,IAAI,sBAAe;AACnB,IAAI,uBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC9SF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,uBAAQ;AACZ,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC1HF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAAe;AACnB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACrNF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAAyC;AAC7C,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACrUF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAA+B;AACnC,IAAI,uBAAkB;AACtB,IAAI,uBAAgB;AACpB,IAAI,uBAA2B;AAC/B,IAAI,uBAAkC;AACtC,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AChHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAAoB;AACxB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACxDF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACxIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AClHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAA+B;AACnC,IAAI,uBAAkB;AACtB,IAAI,uBAA8B;AAClC,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC/DF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,2GAA2G,kBAAkB;AAC7H;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yHAAyH,kBAAkB;AAC3I;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AC5FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,WAAW;AAC5B,iBAAiB,UAAU;AAC3B,iBAAiB,UAAU;AAC3B,iBAAiB,UAAU;AAC3B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA,SAAS;AACT;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,WAAW;AAC5B,iBAAiB,UAAU;AAC3B,iBAAiB,UAAU;AAC3B,iBAAiB,UAAU;AAC3B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACtZF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;AClCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,sBAAuB;AAC3B,IAAI,sBAAuB;AAC3B,IAAI,uBAAe;AACnB,IAAI,uBAAwB;AAC5B,IAAI,uBAAiB;AACrB,IAAI,uBAAkB;AACtB,IAAI,uBAAgB;AACpB,IAAI,uBAAmB;AACvB,IAAI,uBAAqB;AACzB,IAAI,uBAAqB;AACzB,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,sBAAsB;;AAEhE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gCAAgC;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,4BAA4B;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD,iDAAiD;AAC1G;;AAEA,qDAAqD,4BAA4B;AACjF;;AAEA;AACA;;AAEA,qDAAqD,4BAA4B;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,mDAAmD;;AAE1G;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA,kCAAkC;AAClC;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,mDAAmD;;AAE1G;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mGAAmG,8BAA8B;;AAEjI;AACA;;AAEA;AACA;;AAEA,kGAAkG,8BAA8B;;AAEhI;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C;;;;;;ACxbF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAO;AACP,IAAI,sBAAyB;AAC7B,IAAI,sBAAmB;AACvB,IAAI,uBAAW;AACf,CAAC,mCAAE;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC,C","file":"phenix-web-sdk-externalized.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"phenix-web-lodash-light\"), require(\"phenix-web-assert\"), require(\"phenix-rtc\"), require(\"phenix-web-disposable\"), require(\"phenix-web-observable\"), require(\"phenix-web-event\"), require(\"phenix-web-http\"), require(\"phenix-web-logging\"), require(\"phenix-web-application-activity-detector\"), require(\"phenix-web-proto\"), require(\"phenix-web-detect-browser\"), require(\"phenix-web-global\"), require(\"phenix-web-closest-endpoint-resolver\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"phenix-web-sdk\", [\"phenix-web-lodash-light\", \"phenix-web-assert\", \"phenix-rtc\", \"phenix-web-disposable\", \"phenix-web-observable\", \"phenix-web-event\", \"phenix-web-http\", \"phenix-web-logging\", \"phenix-web-application-activity-detector\", \"phenix-web-proto\", \"phenix-web-detect-browser\", \"phenix-web-global\", \"phenix-web-closest-endpoint-resolver\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phenix-web-sdk\"] = factory(require(\"phenix-web-lodash-light\"), require(\"phenix-web-assert\"), require(\"phenix-rtc\"), require(\"phenix-web-disposable\"), require(\"phenix-web-observable\"), require(\"phenix-web-event\"), require(\"phenix-web-http\"), require(\"phenix-web-logging\"), require(\"phenix-web-application-activity-detector\"), require(\"phenix-web-proto\"), require(\"phenix-web-detect-browser\"), require(\"phenix-web-global\"), require(\"phenix-web-closest-endpoint-resolver\"));\n\telse\n\t\troot[\"phenix-web-sdk\"] = factory(root[\"phenix-web-lodash-light\"], root[\"phenix-web-assert\"], root[\"phenix-rtc\"], root[\"phenix-web-disposable\"], root[\"phenix-web-observable\"], root[\"phenix-web-event\"], root[\"phenix-web-http\"], root[\"phenix-web-logging\"], root[\"phenix-web-application-activity-detector\"], root[\"phenix-web-proto\"], root[\"phenix-web-detect-browser\"], root[\"phenix-web-global\"], root[\"phenix-web-closest-endpoint-resolver\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__16__, __WEBPACK_EXTERNAL_MODULE__22__, __WEBPACK_EXTERNAL_MODULE__29__, __WEBPACK_EXTERNAL_MODULE__47__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 41);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var streamEnums = {\n        networkStates: {\n            networkEmpty: {\n                id: 0,\n                name: 'NETWORK_EMPTY'\n            },\n            networkIdle: {\n                id: 1,\n                name: 'NETWORK_IDLE'\n            },\n            networkLoading: {\n                id: 2,\n                name: 'NETWORK_LOADING'\n            },\n            networkNoSource: {\n                id: 3,\n                name: 'NETWORK_NO_SOURCE'\n            }\n        },\n        types: {\n            realTime: {\n                id: 0,\n                name: 'real-time'\n            },\n            dash: {\n                id: 1,\n                name: 'dash'\n            },\n            hls: {\n                id: 2,\n                name: 'hls'\n            },\n            rtmp: {\n                id: 0,\n                name: 'rtmp'\n            }\n        },\n        streamEvents: {\n            playerEnded: {\n                id: 0,\n                name: 'playerended'\n            },\n            playerError: {\n                id: 1,\n                name: 'playererror'\n            },\n            stopped: {\n                id: 2,\n                name: 'stopped'\n            }\n        },\n        rendererEvents: {\n            ended: {\n                id: 0,\n                name: 'ended'\n            },\n            error: {\n                id: 1,\n                name: 'error'\n            },\n            autoMuted: {\n                id: 2,\n                name: 'autoMuted'\n            },\n            failedToPlay: {\n                id: 3,\n                name: 'failedToPlay'\n            }\n        }\n    };\n\n    return streamEnums;\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event'\n], function(_, assert, event) {\n    'use strict';\n\n    var defaultPollFrequency = 500;\n    var minimumPollFrequency = 15;\n\n    function DimensionsChangedMonitor(logger, options) {\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n        this._dimensionsChangedEvent = new event.Event();\n        this._dimensionsChangedIntervalId = null;\n        this._toBeStarted = false;\n        this._videoElement = null;\n        this._dimensionsChangedData = {\n            pollFrequency: defaultPollFrequency,\n            previousWidth: 0,\n            previousHeight: 0\n        };\n\n        if (options && options.pollFrequency) {\n            this._dimensionsChangedData.pollFrequency = options.pollFrequency >= minimumPollFrequency ? options.pollFrequency : minimumPollFrequency;\n        }\n\n        this._renderer = null;\n    }\n\n    DimensionsChangedMonitor.prototype.start = function start(renderer, element) {\n        startMonitor.call(this, renderer, element);\n    };\n\n    DimensionsChangedMonitor.prototype.stop = function stop() {\n        stopMonitor.call(this);\n    };\n\n    DimensionsChangedMonitor.prototype.addVideoDisplayDimensionsChangedCallback = function addVideoDisplayDimensionsChangedCallback(callback) {\n        assert.isFunction(callback, 'addVideoDisplayDimensionsChangedCallback');\n        startInterval.call(this);\n\n        return this._dimensionsChangedEvent.listen(callback);\n    };\n\n    DimensionsChangedMonitor.prototype.toString = function() {\n        return 'DimensionsChangedMonitor[pollFrequency=' + this._dimensionsChangedData.pollFrequency +\n            ', previousHeight=' + this._dimensionsChangedData.previousHeight +\n            ', previousWidth=' + this._dimensionsChangedData.previousHeight +\n            ', state=' + (this._dimensionsChangedIntervalId ? 'running' : 'stopped') + ']';\n    };\n\n    function startMonitor(renderer, element) {\n        if (!element || _.isUndefined(element.videoWidth)) {\n            this._logger.warn(\"Attempting to start dimensions changed monitor without providing proper 'video' element.\");\n        }\n\n        this._renderer = renderer;\n        this._videoElement = element;\n        this._toBeStarted = true;\n        startInterval.call(this);\n    }\n\n    function stopMonitor() {\n        this._toBeStarted = false;\n\n        if (this._dimensionsChangedIntervalId) {\n            clearInterval(this._dimensionsChangedIntervalId);\n            this._dimensionsChangedIntervalId = null;\n        }\n\n        this._dimensionsChangedEvent.dispose();\n    }\n\n    function startInterval() {\n        // Return if either:\n        // - start hasn't been called yet\n        // - the interval is already running\n        // - there is no callback yet\n        if (!this._toBeStarted || this._dimensionsChangedIntervalId || this._dimensionsChangedEvent.size() === 0) {\n            return;\n        }\n\n        var that = this;\n        this._dimensionsChangedData.previousWidth = this._videoElement.videoWidth;\n        this._dimensionsChangedData.previousHeight = this._videoElement.videoHeight;\n\n        this._dimensionsChangedIntervalId = setInterval(function checkVideoDimensions() {\n            if (that._videoElement.videoWidth !== that._dimensionsChangedData.previousWidth || that._videoElement.videoHeight !== that._dimensionsChangedData.previousHeight) {\n                that._dimensionsChangedData.previousWidth = that._videoElement.videoWidth;\n                that._dimensionsChangedData.previousHeight = that._videoElement.videoHeight;\n\n                that._dimensionsChangedEvent.fireAsync([that._renderer, {\n                    width: that._videoElement.videoWidth,\n                    height: that._videoElement.videoHeight\n                }]);\n            }\n        }, that._dimensionsChangedData.pollFrequency);\n    }\n\n    return DimensionsChangedMonitor;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-detect-browser'\n], function(_, DetectBrowser) {\n    'use strict';\n\n    var environment = {};\n    var browser = new DetectBrowser(navigator.userAgent).detect();\n\n    environment.getEnvironmentFromUrl = function(uri) {\n        try {\n            var baseURL;\n\n            if (URL && browser.browser !== 'IE') {\n                baseURL = new URL(uri);\n            } else {\n                baseURL = getLocation(uri);\n            }\n\n            if (baseURL.port) {\n                return baseURL.protocol + '//' + baseURL.hostname + ':' + baseURL.port;\n            }\n\n            return baseURL.protocol + '//' + baseURL.hostname;\n        } catch (e) {\n            return '';\n        }\n    };\n\n    environment.parseEnvFromPcastBaseUri = function(uri) {\n        uri = uri.toLowerCase();\n\n        if (_.includes(uri, 'local')) {\n            return 'local';\n        } else if (_.includes(uri, 'stg')) {\n            return 'staging';\n        }\n\n        return 'production';\n    };\n\n    environment.getTelemetryServerUri = function(baseUri) {\n        if (!baseUri) {\n            return '';\n        }\n\n        try {\n            var baseURL;\n\n            if (URL && browser.browser !== 'IE') {\n                baseURL = new URL(baseUri);\n            } else {\n                baseURL = getLocation(baseUri);\n            }\n\n            var segments = baseURL.hostname.split('.');\n\n            if (segments.length === 2 ||\n                (segments.length === 3 && segments[segments.length - 2].length <= 2 && segments[segments.length - 1].length <= 3)\n            ) {\n                segments.unshift('telemetry');\n            } else if (_.startsWith(segments[0], 'stg-') || _.endsWith(segments[0], '-stg') || _.includes(segments[0], '-stg-') || segments[0] === 'stg') {\n                segments[0] = 'telemetry-stg';\n            } else if (_.startsWith(segments[0], 'local') || _.endsWith(segments[0], 'local')) {\n                // Leave URL unchanged\n            } else {\n                segments[0] = 'telemetry';\n            }\n\n            baseURL.hostname = segments.join('.');\n\n            switch (baseURL.protocol) {\n            case 'ws:':\n                baseURL.protocol = 'http:';\n\n                break;\n            case 'wss:':\n                baseURL.protocol = 'https:';\n\n                break;\n\n            default:\n                break;\n            }\n\n            if (baseURL.port) {\n                return baseURL.protocol + '//' + baseURL.hostname + ':' + baseURL.port + '/telemetry';\n            }\n\n            return baseURL.protocol + '//' + baseURL.hostname + '/telemetry';\n        } catch (e) {\n            return baseUri;\n        }\n    };\n\n    function getLocation(url) {\n        var match = url.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)([\\/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/); // eslint-disable-line\n\n        return match && {\n            href: url,\n            protocol: match[1],\n            host: match[2],\n            hostname: match[3],\n            port: match[4],\n            pathname: match[5],\n            search: match[6],\n            hash: match[7],\n            origin: match[1] + '//' + match[2]\n        };\n    }\n\n    return environment;\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-rtc',\n    'phenix-web-global',\n    './PhenixLiveStream',\n    './stream.json'\n], function(_, assert, rtc, global, PhenixLiveStream, streamEnums) {\n    'use strict';\n\n    var defaultFeatures = [\n        streamEnums.types.realTime.name,\n        streamEnums.types.dash.name,\n        streamEnums.types.hls.name\n    ];\n\n    function FeatureDetector(features) {\n        features = features || defaultFeatures;\n\n        assert.isArray(features, 'features');\n\n        _.forEach(features, function(feature, index) {\n            assert.isValidType(feature, streamEnums.types, 'FeatureType[' + index + ']');\n        });\n\n        this._features = _.map(features, _.bind(_.getEnumName, _, streamEnums.types));\n    }\n\n    FeatureDetector.isFeatureSupported = function(feature) {\n        if (feature) {\n            assert.isStringNotEmpty(feature, 'feature');\n        }\n\n        var featureName = _.getEnumName(streamEnums.types, feature);\n\n        switch (featureName) {\n        case streamEnums.types.realTime.name:\n            return rtc.webrtcSupported;\n        case streamEnums.types.dash.name:\n        case streamEnums.types.hls.name:\n        case streamEnums.types.rtmp.name:\n            return PhenixLiveStream.canPlaybackType(feature);\n        default:\n            return false;\n        }\n    };\n\n    FeatureDetector.mapFeatureToPCastCapability = function(feature) {\n        if (feature) {\n            assert.isStringNotEmpty(feature, 'feature');\n        }\n\n        var featureName = _.getEnumName(streamEnums.types, feature);\n\n        switch (featureName) {\n        case streamEnums.types.realTime.name:\n            return 'real-time';\n        case streamEnums.types.dash.name:\n        case streamEnums.types.hls.name:\n            return 'streaming';\n        case streamEnums.types.rtmp.name:\n            return 'rtmp';\n        default:\n            return '';\n        }\n    };\n\n    FeatureDetector.mapPCastCapabilitiesToFeatures = function(capabilities) {\n        assert.isArray(capabilities, 'capabilities');\n\n        return _.reduce(capabilities, function(features, capability) {\n            return features.concat(FeatureDetector.mapPCastCapabilityToFeatures(capability));\n        }, []);\n    };\n\n    FeatureDetector.mapPCastCapabilityToFeatures = function(capability) {\n        if (capability) {\n            assert.isStringNotEmpty(capability, 'capability');\n        }\n\n        if (capability === 'real-time') {\n            return [streamEnums.types.realTime.name];\n        }\n\n        if (capability === 'streaming') {\n            return [streamEnums.types.dash.name, streamEnums.types.dash.name];\n        }\n\n        if (capability === 'rtmp') {\n            return [streamEnums.types.rtmp.name];\n        }\n\n        return [];\n    };\n\n    FeatureDetector.prototype.getFeatures = function() {\n        return this._features;\n    };\n\n    FeatureDetector.prototype.getFeaturePCastCapabilities = function() {\n        var capabilities = _.map(this._features, FeatureDetector.mapFeatureToPCastCapability);\n\n        return _.reduce(capabilities, removeDuplicates, []);\n    };\n\n    FeatureDetector.prototype.getPreferredFeatureFromPublisherCapabilities = function(capabilities, excludeRealTime) {\n        assert.isArray(capabilities, 'capabilities');\n\n        var preferredFeature = _.reduce(this._features, function(candidateFeature, feature) {\n            var featureCapability = FeatureDetector.mapFeatureToPCastCapability(feature);\n            var isFeatureAvailableAndCanPlayBack = FeatureDetector.isFeatureSupported(feature) && (_.includes(capabilities, featureCapability) || (feature === 'real-time' && !excludeRealTime));\n            var nextFeature = isFeatureAvailableAndCanPlayBack ? feature : null;\n\n            return candidateFeature || nextFeature;\n        }, null);\n\n        if (preferredFeature === streamEnums.types.dash.name && FeatureDetector.shouldUseNativeHls && _.includes(capabilities, FeatureDetector.mapFeatureToPCastCapability(streamEnums.types.hls.name)) && _.includes(this._features, streamEnums.types.hls.name)) {\n            preferredFeature = streamEnums.types.hls.name;\n        } else if (preferredFeature === streamEnums.types.hls.name && !FeatureDetector.shouldUseNativeHls && _.includes(capabilities, FeatureDetector.mapFeatureToPCastCapability(streamEnums.types.dash.name)) && _.includes(this._features, streamEnums.types.dash.name)) {\n            preferredFeature = streamEnums.types.dash.name;\n        }\n\n        return preferredFeature;\n    };\n\n    FeatureDetector.shouldUseNativeHls = isIOS() || rtc.browser === 'Safari' || isSamsungBrowser();\n    FeatureDetector.isIOS = isIOS;\n    FeatureDetector.isSamsungBrowser = isSamsungBrowser;\n    FeatureDetector.isAndroid = isAndroid;\n    FeatureDetector.isMobile = isMobile;\n    FeatureDetector.getIOSVersion = getIOSVersion;\n\n    function isIOS() {\n        var userAgent = _.get(global, ['navigator', 'userAgent'], '');\n\n        return /iPad|iPhone|iPod/.test(userAgent) && !global.MSStream;\n    }\n\n    function isSamsungBrowser() {\n        var userAgent = _.get(global, ['navigator', 'userAgent'], '');\n\n        return /SamsungBrowser/.test(userAgent);\n    }\n\n    function isAndroid() {\n        var userAgent = _.get(global, ['navigator', 'userAgent'], '');\n\n        return /(android)/i.test(userAgent);\n    }\n\n    function isMobile() {\n        var userAgent = _.get(global, ['navigator', 'userAgent'], '');\n\n        return isIOS() || /Android|webOS|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(userAgent);\n    }\n\n    function getIOSVersion() {\n        var userAgent = _.get(global, ['navigator', 'userAgent'], '');\n\n        if (/iP(hone|od|ad)/.test(userAgent)) {\n            var version = userAgent.match(/.*OS (\\d+)_(\\d+)_?(\\d+)? like Mac OS X/);\n\n            return {\n                major: parseInt(_.get(version, [1], 0), 10),\n                minor: parseInt(_.get(version, [2], 0), 10),\n                patch: parseInt(_.get(version, [3], 0), 10)\n            };\n        }\n    }\n\n    function removeDuplicates(list, item) {\n        if (!_.includes(list, item)) {\n            list.push(item);\n        }\n\n        return list;\n    }\n\n    return FeatureDetector;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var memberEnums = {\n        roles: {\n            participant: {\n                id: 0,\n                name: 'Participant'\n            },\n            moderator: {\n                id: 1,\n                name: 'Moderator'\n            },\n            presenter: {\n                id: 2,\n                name: 'Presenter'\n            },\n            audience: {\n                id: 3,\n                name: 'Audience'\n            }\n        },\n        states: {\n            active: {\n                id: 0,\n                name: 'Active'\n            },\n            passive: {\n                id: 1,\n                name: 'Passive'\n            },\n            handRaised: {\n                id: 2,\n                name: 'HandRaised'\n            },\n            inactive: {\n                id: 3,\n                name: 'Inactive'\n            },\n            offline: {\n                id: 4,\n                name: 'Offline'\n            }\n        }\n    };\n\n    return memberEnums;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var roomEnums = {\n        types: {\n            directChat: {\n                id: 0,\n                name: 'DirectChat'\n            },\n            multiPartyChat: {\n                id: 1,\n                name: 'MultiPartyChat'\n            },\n            moderatedChat: {\n                id: 2,\n                name: 'ModeratedChat'\n            },\n            townHall: {\n                id: 3,\n                name: 'TownHall'\n            },\n            channel: {\n                id: 4,\n                name: 'Channel'\n            }\n        },\n        events: {\n            memberJoined: {\n                id: 0,\n                name: 'MemberJoined'\n            },\n            memberLeft: {\n                id: 1,\n                name: 'MemberLeft'\n            },\n            memberUpdated: {\n                id: 2,\n                name: 'MemberUpdated'\n            },\n            roomUpdated: {\n                id: 3,\n                name: 'RoomUpdated'\n            },\n            roomEnded: {\n                id: 4,\n                name: 'RoomEnded'\n            }\n        }\n    };\n\n    return roomEnums;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-logging',\n    '../environment',\n    './telemetryAppenderFactory'\n], function(_, assert, logging, environment, telemetryAppenderFactory) {\n    'use strict';\n\n    function PCastLoggerFactory() {\n\n    }\n\n    PCastLoggerFactory.prototype.createPCastLogger = function createPCastLogger(baseUri, disableConsole, loggingLevel) {\n        if (baseUri) {\n            assert.isStringNotEmpty(baseUri, 'baseUri');\n        }\n\n        var logger = new logging.Logger();\n        var env = environment.getEnvironmentFromUrl(baseUri);\n        var telemetryAppender = telemetryAppenderFactory.getAppender(baseUri);\n\n        logger.setEnvironment(env);\n\n        if (loggingLevel) {\n            telemetryAppender.setThreshold(loggingLevel);\n        } else {\n            telemetryAppender.setThreshold(logging.level.INFO);\n        }\n\n        if (!disableConsole) {\n            logger.addAppender(new logging.ConsoleAppender());\n        }\n\n        logger.addAppender(telemetryAppender);\n\n        logger.isPCastLogger = true;\n\n        return logger;\n    };\n\n    return new PCastLoggerFactory();\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__16__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-assert',\n    'phenix-web-lodash-light',\n    'phenix-web-disposable',\n    'phenix-web-closest-endpoint-resolver'\n], function(assert, _, disposable, ClosestEndPointResolver) {\n    'use strict';\n\n    function PCastEndPoint(version, baseUri, logger, sessionTelemetry) {\n        assert.isStringNotEmpty(version, 'version');\n        assert.isStringNotEmpty(baseUri, 'baseUri');\n        assert.isObject(logger, 'logger');\n\n        this._version = version;\n        this._baseUri = baseUri;\n        this._logger = logger;\n        this._disposables = new disposable.DisposableList();\n        this._sessionTelemetry = sessionTelemetry;\n    }\n\n    PCastEndPoint.DefaultPCastUri = 'https://pcast.phenixrts.com';\n\n    PCastEndPoint.prototype.getBaseUri = function() {\n        return this._baseUri;\n    };\n\n    PCastEndPoint.prototype.resolveUri = function(callback /* (error, {uri, roundTripTime}) */) {\n        return resolveUri.call(this, this._baseUri, callback);\n    };\n\n    PCastEndPoint.prototype.dispose = function() {\n        this._disposables.dispose();\n    };\n\n    PCastEndPoint.prototype.toString = function() {\n        return 'PCastEndPoint[' + this._baseUri + ']';\n    };\n\n    function resolveUri(baseUri, callback /* (error, {uri, roundTripTime}) */) {\n        var isWss = baseUri.lastIndexOf('wss:', 0) === 0;\n        var isWs = baseUri.lastIndexOf('ws:', 0) === 0;\n        var isHttps = baseUri.lastIndexOf('https:', 0) === 0;\n        var isHttp = baseUri.lastIndexOf('http:', 0) === 0;\n\n        if (isWss || isWs) {\n            // WS - Specific web socket end point\n            callback(undefined, {\n                uri: baseUri + '/ws',\n                roundTripTime: 0\n            });\n        } else if (isHttps || isHttp) {\n            // HTTP - Resolve closest end point\n            var that = this;\n\n            getEndpoints.call(that, baseUri, function(err, endPoints) {\n                if (err) {\n                    return callback(err);\n                }\n\n                var closestEndPointResolver = new ClosestEndPointResolver({\n                    logger: that._logger,\n                    version: that._version\n                }, callback, function(err, response) {\n                    if (err) {\n                        if (err.code === 503) {\n                            that._logger.debug('The end point [%s] is temporarily disabled', _.get(response, ['endPoint']));\n                        } else {\n                            that._logger.warn('An error occurred in resolving an endpoint [%s]', _.get(response, ['endPoint']), err);\n                        }\n\n                        return;\n                    }\n\n                    var isHttpsEndPoint = response.endPoint.lastIndexOf('https:', 0) === 0;\n\n                    that._sessionTelemetry.recordMetric('RoundTripTime', {uint64: response.time}, null, {\n                        resource: response.endPoint,\n                        kind: isHttpsEndPoint ? 'https' : 'http'\n                    });\n                });\n\n                closestEndPointResolver.resolveAll(endPoints);\n\n                that._disposables.add(closestEndPointResolver);\n            });\n        } else {\n            // Not supported\n            callback(new Error('Uri not supported [' + baseUri + ']'));\n        }\n    }\n\n    function getEndpoints(baseUri, callback) {\n        var version = '2022-04-13T15:08:08Z';\n        var requestUrl = baseUri + '/pcast/endPoints?version=' + version + '&_=' + _.now();\n        var xhr = getAndOpenVendorSpecificXmlHttpMethod('GET', requestUrl);\n\n        xhr.addEventListener('readystatechange', _.bind(handleReadyStateChange, this, xhr, function(err, response) {\n            if (err) {\n                return callback(new Error('Failed to resolve an end point', err));\n            }\n\n            var endPoints = response.data.split(',');\n\n            if (endPoints.length < 1) {\n                callback(new Error('Failed to discover end points'));\n            }\n\n            callback(undefined, endPoints);\n        }));\n        xhr.timeout = 15000;\n        xhr.send(null);\n    }\n\n    function getAndOpenVendorSpecificXmlHttpMethod(requestMethod, requestUrl) {\n        var xhr = new XMLHttpRequest();\n\n        if ('withCredentials' in xhr) {\n            // Most browsers.\n            xhr.open(requestMethod, requestUrl, true);\n        } else if (typeof XDomainRequest !== 'undefined') {\n            // IE8 & IE9\n            // eslint-disable-next-line no-undef\n            xhr = new XDomainRequest();\n            xhr.open(requestMethod, requestUrl);\n        } else {\n            return;\n        }\n\n        return xhr;\n    }\n\n    function handleReadyStateChange(xhr, callback) {\n        if (xhr.readyState === 4 /* DONE */) {\n            if (xhr.status === 200) {\n                var responseHeaders = getXhrResponseHeaders(xhr);\n                var response = {\n                    data: xhr.response || xhr.responseText,\n                    headers: responseHeaders,\n                    rawXhr: xhr\n                };\n\n                callback(null, response);\n            } else {\n                var err = new Error(xhr.status === 0 ? 'timeout' : 'Status=[' + xhr.status + ']');\n\n                err.code = xhr.status;\n\n                callback(err);\n            }\n        }\n    }\n\n    function getXhrResponseHeaders(xhr) {\n        var responseHeadersString = xhr.getAllResponseHeaders();\n\n        return _.reduce(responseHeadersString.trim().split(/[\\r\\n]+/), function(headers, header) {\n            var parts = header.split(': ');\n            var headerName = parts.shift();\n            var headerValue = parts.join(': ');\n\n            if (headerName) {\n                headers[headerName] = headerValue;\n            }\n\n            return headers;\n        }, {});\n    }\n\n    return PCastEndPoint;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-rtc'\n], function(_, rtc) {\n    'use strict';\n\n    // TODO(dy) wrap PC in this class\n    function PeerConnection() {\n\n    }\n\n    PeerConnection.convertPeerConnectionStats = function(stats, lastStats) {\n        return convertPeerConnectionStats(stats, lastStats);\n    };\n\n    function convertPeerConnectionStats(stats, lastStats) {\n        if (!stats) {\n            return null;\n        }\n\n        var newStats = [];\n        var normalizedStats = normalizeStatsReport(stats);\n\n        var iteratorDidRun = false;\n\n        function convertStats(statsReport) {\n            if (!iteratorDidRun) {\n                iteratorDidRun = true;\n            }\n\n            if (!_.hasIndexOrKey(statsReport, 'ssrc') || !statsReport.ssrc || _.includes(statsReport.id, 'rtcp')) {\n                return;\n            }\n\n            var id = statsReport.id || statsReport.ssrc;\n\n            if (!_.hasIndexOrKey(lastStats, id)) {\n                lastStats[id] = {timestamp: _.now()};\n            }\n\n            var direction = '?';\n            var timeDelta = parseFloat(statsReport.timestamp) - lastStats[id].timestamp;\n            var up = calculateUploadRate(parseFloat(statsReport.bytesSent), lastStats[id].bytesSent, timeDelta);\n            var down = calculateDownloadRate(parseFloat(statsReport.bytesReceived), lastStats[id].bytesReceived, timeDelta);\n            var framerateMean = calculateFrameRate(useFirstNumberValue(parseIntOrUndefined(statsReport.framesEncoded), parseIntOrUndefined(statsReport.framesDecoded)), lastStats[id].framesEncoded || lastStats[id].framesDecoded, timeDelta);\n\n            if (isOutbound(statsReport)) {\n                direction = 'upload';\n            }\n\n            if (isInbound(statsReport)) {\n                direction = 'download';\n            }\n\n            var stat = {\n                uploadRate: up,\n                downloadRate: down,\n                mediaType: statsReport.mediaType,\n                ssrc: statsReport.ssrc,\n                direction: direction,\n                nativeReport: statsReport,\n                rtt: useFirstNumberValue(parseIntOrUndefined(statsReport.rtt), parseIntOrUndefined(statsReport.googRtt), parseIntOrUndefined(statsReport.roundTripTime), parseIntOrUndefined(statsReport.currentRoundTripTime)),\n                bitrateMean: parseIntOrUndefined(statsReport.bitrateMean, 10) || (isOutbound(statsReport) ? up : down) * 1000,\n                targetDelay: parseIntOrUndefined(useFirstStringValue(statsReport.targetDelay, statsReport.googTargetDelayMs), 10),\n                currentDelay: parseIntOrUndefined(useFirstStringValue(statsReport.currentDelay, statsReport.currentDelayMs, statsReport.googCurrentDelayMs), 10)\n            };\n\n            _.assign(lastStats[id], statsReport);\n\n            if (statsReport.mediaType === 'video') {\n                stat = _.assign(stat, {\n                    droppedFrames: parseIntOrUndefined(statsReport.droppedFrames, 10) || 0,\n                    framerateMean: useFirstNumberValue(statsReport.framerateMean, statsReport.framesPerSecond, framerateMean) || 0,\n                    cpuLimitedResolution: useFirstStringValue(statsReport.cpuLimitedResolution, statsReport.googCpuLimitedResolution),\n                    avgEncode: parseIntOrUndefined(useFirstStringValue(statsReport.avgEncode, statsReport.avgEncodeMs, statsReport.googAvgEncodeMs), 10)\n                });\n            }\n\n            if (statsReport.mediaType === 'audio') {\n                stat = _.assign(stat, {\n                    audioInputLevel: useFirstStringValue(statsReport.audioInputLevel, statsReport.googAudioInputLevel),\n                    audioOutputLevel: useFirstStringValue(statsReport.audioOutputLevel, statsReport.googAudioOutputLevel),\n                    jitter: parseIntOrUndefined(useFirstStringValue(statsReport.jitter, statsReport.jitterReceived, statsReport.googJitterReceived), 10),\n                    jitterBuffer: parseIntOrUndefined(useFirstStringValue(statsReport.jitterBuffer, statsReport.jitterBufferMs, statsReport.googJitterBufferMs), 10),\n                    totalSamplesDuration: parseFloatOrUndefined(statsReport.totalSamplesDuration),\n                    totalAudioEnergy: parseFloatOrUndefined(statsReport.totalAudioEnergy)\n                });\n            }\n\n            newStats.push(stat);\n        }\n\n        _.forOwn(normalizedStats, convertStats);\n\n        if (!iteratorDidRun && newStats.length <= 0 && normalizedStats.forEach) {\n            normalizedStats.forEach(convertStats);\n        }\n\n        return newStats;\n    }\n\n    function useFirstNumberValue(value1, value2, value3, value4, value5) {\n        if (_.isNumber(value1)) {\n            return value1;\n        }\n\n        if (_.isNumber(value2)) {\n            return value2;\n        }\n\n        if (_.isNumber(value3)) {\n            return value3;\n        }\n\n        if (_.isNumber(value4)) {\n            return value4;\n        }\n\n        return value5;\n    }\n\n    function useFirstStringValue(value1, value2, value3, value4, value5) {\n        if (_.isString(value1)) {\n            return value1;\n        }\n\n        if (_.isString(value2)) {\n            return value2;\n        }\n\n        if (_.isString(value3)) {\n            return value3;\n        }\n\n        if (_.isNumber(value4)) {\n            return value4;\n        }\n\n        return value5;\n    }\n\n    function parseIntOrUndefined(value, radix) {\n        var parsed = parseInt(value, radix);\n\n        if (isNaN(parsed)) {\n            return undefined;\n        }\n\n        return parsed;\n    }\n\n    function parseFloatOrUndefined(value) {\n        var parsed = parseFloat(value);\n\n        if (isNaN(parsed)) {\n            return undefined;\n        }\n\n        return parsed;\n    }\n\n    function calculateUploadRate(bytesSent, prevBytesSent, timeDelta) {\n        if (_.isUndefined(prevBytesSent)) {\n            return;\n        }\n\n        if (bytesSent) {\n            var bytesSentBefore = prevBytesSent || 0;\n\n            return 8 * (bytesSent - bytesSentBefore) / timeDelta;\n        }\n\n        return 0;\n    }\n\n    function calculateDownloadRate(bytesReceived, prevBytesReceived, timeDelta) {\n        if (_.isUndefined(prevBytesReceived)) {\n            return;\n        }\n\n        if (bytesReceived) {\n            var bytesReceivedBefore = prevBytesReceived || 0;\n\n            return 8 * (bytesReceived - bytesReceivedBefore) / timeDelta;\n        }\n\n        return 0;\n    }\n\n    function calculateFrameRate(currentFramesEncoded, lastFramesEncoded, timeDelta) {\n        if (_.isUndefined(lastFramesEncoded)) {\n            return;\n        }\n\n        return (currentFramesEncoded - lastFramesEncoded)\n            / (timeDelta / 1000.0);\n    }\n\n    function normalizeStatsReport(stats) {\n        var normalizedReport = {};\n\n        switch (rtc.browser) {\n        case 'Firefox':\n            _.forOwn(stats, function(report, key) {\n                if (_.includes(key, 'rtcp')) {\n                    _.forOwn(stats, function(reportToUpdate, key) {\n                        if (_.includes(key, 'rtp') && report.mediaType === reportToUpdate.mediaType) {\n                            reportToUpdate.jitter = (report.jitter || reportToUpdate.jitter) * 1000;\n                            reportToUpdate.roundTripTime = report.roundTripTime;\n                        }\n                    });\n                }\n            });\n\n            return stats;\n        case 'IE':\n            _.forOwn(stats, function(value, key) {\n                if (!_.startsWith(key, 'ssrc')) {\n                    return;\n                }\n\n                normalizedReport[value.id] = value;\n            });\n\n            return normalizedReport;\n        case 'Edge':\n            stats.forEach(function(report) {\n                normalizedReport[report.id] = report;\n\n                if (_.hasIndexOrKey(report, 'jitter')) {\n                    report.jitter *= 1000;\n                }\n            });\n\n            _.forOwn(normalizedReport, function(report) {\n                if (report.type === 'track' && _.hasIndexOrKey(report, 'framesPerSecond')) {\n                    _.forOwn(normalizedReport, function(reportToUpdate) {\n                        if (reportToUpdate.mediaType === 'video') {\n                            reportToUpdate.framesPerSecond = parseInt(report.framesPerSecond, 10);\n                        }\n                    });\n                }\n            });\n\n            return normalizedReport;\n        case 'Safari':\n            stats.forEach(function(report) {\n                normalizedReport[report.id] = report;\n            });\n\n            _.forOwn(normalizedReport, function(report) {\n                if (_.hasIndexOrKey(report, 'id') && isInbound(report)) {\n                    var candidateSsrc = parseInt(_.get(report.id.split('_'), [1]), 10);\n\n                    report.ssrc = candidateSsrc || report.ssrc; // Ssrc is inaccurate for inbound reports\n                }\n\n                if (_.hasIndexOrKey(report, 'jitter')) {\n                    report.jitter *= 1000;\n                }\n\n                if (report.type === 'candidate-pair') {\n                    _.forOwn(normalizedReport, function(reportToUpdate) {\n                        if (reportToUpdate.mediaType === 'audio' || reportToUpdate.mediaType === 'video') {\n                            reportToUpdate.currentRoundTripTime = report.currentRoundTripTime * 1000;\n                        }\n                    });\n                }\n\n                if (report.type === 'track') {\n                    _.forOwn(normalizedReport, function(reportToUpdate) {\n                        if (reportToUpdate.mediaType === 'audio' && isInbound(reportToUpdate)) {\n                            reportToUpdate.audioOutputLevel = report.audioLevel * 100000;\n                        } else if (reportToUpdate.mediaType === 'audio' && isOutbound(reportToUpdate)) {\n                            reportToUpdate.audioInputLevel = report.audioLevel * 100000;\n                        }\n                    });\n                }\n            });\n\n            return normalizedReport;\n        case 'ReactNative':\n            var parsedStats = _.isString(stats) ? JSON.parse(stats) : stats;\n\n            parsedStats.forEach(function(report) {\n                var normalizedStatistics = {\n                    id: report.id,\n                    type: report.type\n                };\n\n                report.values.forEach(function(value) {\n                    _.keys(value).forEach(function(key) {\n                        normalizedStatistics[key] = value[key];\n                    });\n                });\n\n                normalizedStatistics.timestamp = report.timestamp;\n\n                normalizedReport[normalizedStatistics.id] = normalizedStatistics;\n            });\n\n            return normalizedReport;\n        case 'Chrome':\n        default:\n            stats.result().forEach(function(report) {\n                var normalizedStatistics = {\n                    id: report.id,\n                    type: report.type\n                };\n\n                report.names().forEach(function(name) {\n                    normalizedStatistics[name] = report.stat(name);\n                });\n\n                normalizedStatistics.timestamp = report.timestamp.getTime();\n\n                normalizedReport[normalizedStatistics.id] = normalizedStatistics;\n            });\n\n            return normalizedReport;\n        }\n    }\n\n    function isOutbound(statsReport) {\n        return _.includes(statsReport.id, 'send') || _.includes(statsReport.id, 'outbound') || statsReport.type === 'outboundrtp' || statsReport.type === 'outbound-rtp' || statsReport.type === 'kOutboundRtp';\n    }\n\n    function isInbound(statsReport) {\n        return _.includes(statsReport.id, 'recv') || statsReport.type === 'inboundrtp' || statsReport.type === 'inbound-rtp' || statsReport.type === 'kInboundRtp';\n    }\n\n    return PeerConnection;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    './stream.json',\n    './track.json'\n], function(_, assert, observable, stream, track) {\n    'use strict';\n\n    var streamTypes = stream.types;\n    var trackStates = track.states;\n    var oldPcastStreamPrefix = 'pcast://phenixp2p.com/';\n    var pcastStreamPrefix = 'pcast://phenixrts.com/';\n\n    function Stream(uri, type, audioState, videoState) {\n        this.init(uri, type, audioState, videoState);\n    }\n\n    Stream.prototype.init = function(uri, type, audioState, videoState) {\n        assert.isString(uri, 'uri');\n\n        this._uri = new observable.Observable(uri);\n        this._type = new observable.Observable(type, assertIsValidStreamType);\n        this._audioState = new observable.Observable(audioState || trackStates.trackEnabled.name, assertIsValidTrackState);\n        this._videoState = new observable.Observable(videoState || trackStates.trackEnabled.name, assertIsValidTrackState);\n        this._streamId = Stream.parsePCastStreamIdFromStreamUri(uri);\n    };\n\n    Stream.prototype.getUri = function getUri() {\n        return this._uri.getValue();\n    };\n\n    Stream.prototype.getType = function getType() {\n        return this._type.getValue();\n    };\n\n    Stream.prototype.getObservableAudioState = function getObservableAudioState() {\n        return this._audioState;\n    };\n\n    Stream.prototype.getObservableVideoState = function getObservableVideoState() {\n        return this._videoState;\n    };\n\n    Stream.prototype.toJson = function toJson() {\n        return {\n            uri: this._uri.getValue(),\n            type: this._type.getValue(),\n            audioState: this._audioState.getValue(),\n            videoState: this._videoState.getValue()\n        };\n    };\n\n    Stream.prototype._update = function update(stream) {\n        if (!_.isObject(stream)) {\n            return;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(stream, 'uri')) {\n            if (stream.uri !== this._uri.getValue() && matchPCastStreams(stream.uri, this._uri.getValue())) {\n                this._uri.setValue(stream.uri);\n\n                this._streamId = Stream.parsePCastStreamIdFromStreamUri(stream.uri);\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(stream, 'audioState')) {\n            this._audioState.setValue(stream.audioState);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(stream, 'videoState')) {\n            this._videoState.setValue(stream.videoState);\n        }\n    };\n\n    Stream.prototype.isPCastStream = function() {\n        return !!this._streamId;\n    };\n\n    Stream.prototype.getPCastStreamId = function() {\n        return this._streamId;\n    };\n\n    Stream.prototype.getInfo = function() {\n        return parseStreamInfoFromStreamUri(this._uri.getValue());\n    };\n\n    Stream.getPCastPrefix = function() {\n        return oldPcastStreamPrefix;\n    };\n\n    Stream.parsePCastStreamIdFromStreamUri = function(uri) {\n        var hasPrefix = _.includes(uri, getPrefixToUse(uri));\n\n        if (!hasPrefix) {\n            return null;\n        }\n\n        return uri.replace(getPrefixToUse(uri), '').split('?')[0];\n    };\n\n    Stream.getInfoFromStreamUri = function(uri) {\n        return parseStreamInfoFromStreamUri(uri);\n    };\n\n    function getPrefixToUse(uri) {\n        if (_.includes(uri, oldPcastStreamPrefix)) {\n            return oldPcastStreamPrefix;\n        }\n\n        return pcastStreamPrefix;\n    }\n\n    function matchPCastStreams(uriA, uriB) {\n        return Stream.parsePCastStreamIdFromStreamUri(uriA) === Stream.parsePCastStreamIdFromStreamUri(uriB);\n    }\n\n    function parseStreamInfoFromStreamUri(uri) {\n        var parsedUriInfo = {};\n        var queryParamString = uri.split('?');\n\n        if (queryParamString.length !== 2) {\n            return parsedUriInfo;\n        }\n\n        var queryParamsString = queryParamString[1];\n        var queryParams = queryParamsString.split('&');\n\n        _.forEach(queryParams, function(param) {\n            var parsedParams = param.split('=');\n            var key = parsedParams[0];\n            var value = decodeURIComponent(parsedParams[1]);\n\n            parsedUriInfo[key] = value;\n\n            if (key === 'capabilities') {\n                parsedUriInfo[key] = value ? (value.split(',') || []) : [];\n            }\n        });\n\n        return parsedUriInfo;\n    }\n\n    function assertIsValidStreamType(type) {\n        assert.isValidType(type, streamTypes, 'streamType');\n\n        return _.getEnumName(streamTypes, type);\n    }\n\n    function assertIsValidTrackState(state) {\n        assert.isValidType(state, trackStates, 'trackState');\n\n        return _.getEnumName(trackStates, state);\n    }\n\n    return Stream;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var streamEnums = {\n        types: {\n            user: {\n                id: 0,\n                name: 'User'\n            },\n            presentation: {\n                id: 1,\n                name: 'Presentation'\n            },\n            audio: {\n                id: 2,\n                name: 'Audio'\n            }\n        }\n    };\n\n    return streamEnums;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    './logging/pcastLoggerFactory',\n    'phenix-web-http',\n    'phenix-web-application-activity-detector',\n    './environment',\n    './audio/AudioContext',\n    './PCastProtocol',\n    './PCastEndPoint',\n    './userMedia/ScreenShareExtensionManager',\n    './userMedia/UserMediaProvider',\n    './streaming/PeerConnectionMonitor',\n    './DimensionsChangedMonitor',\n    './telemetry/metricsTransmitterFactory',\n    './telemetry/StreamTelemetry',\n    './telemetry/SessionTelemetry',\n    './streaming/PeerConnection',\n    './streaming/StreamWrapper',\n    './streaming/PhenixLiveStream',\n    './streaming/PhenixRealTimeStream',\n    './streaming/FeatureDetector',\n    './streaming/stream.json',\n    './streaming/BitRateMonitor',\n    'phenix-rtc',\n    './sdpUtil'\n], function(_, assert, observable, disposable, pcastLoggerFactory, http, applicationActivityDetector, environment, AudioContext, PCastProtocol, PCastEndPoint, ScreenShareExtensionManager, UserMediaProvider, PeerConnectionMonitor, DimensionsChangedMonitor, metricsTransmitterFactory, StreamTelemetry, SessionTelemetry, PeerConnection, StreamWrapper, PhenixLiveStream, PhenixRealTimeStream, FeatureDetector, streamEnums, BitRateMonitor, phenixRTC, sdpUtil) {\n    'use strict';\n\n    var sdkVersion = '2022-04-13T15:08:08Z';\n    var accumulateIceCandidatesDuration = 50;\n    var roomOrChannelIdRegex = /^(?:room|channel)Id[:](.*)$/;\n    var roomOrChannelAliasRegex = /^(?:room|channel)Alias[:](.*)$/;\n\n    function PCast(options) {\n        options = options || {};\n\n        assert.isObject(options, 'options');\n\n        if (options.streamingSourceMapping) {\n            assert.isObject(options.streamingSourceMapping, 'options.streamingSourceMapping');\n            assert.isStringNotEmpty(options.streamingSourceMapping.replacement, 'options.streamingSourceMapping.replacement');\n\n            if (!(options.streamingSourceMapping.patternToReplace instanceof RegExp)) {\n                assert.isStringNotEmpty(options.streamingSourceMapping.patternToReplace, 'options.streamingSourceMapping.patternToReplace');\n            }\n        }\n\n        if (!_.isNullOrUndefined(options.disableMultiplePCastInstanceWarning)) {\n            assert.isBoolean(options.disableMultiplePCastInstanceWarning, 'options.disableMultiplePCastInstanceWarning');\n        }\n\n        if (!_.isNullOrUndefined(options.disableGlobalErrorListener)) {\n            assert.isBoolean(options.disableGlobalErrorListener, 'options.disableGlobalErrorListener');\n        }\n\n        if (!_.isNullOrUndefined(options.disableBeforeUnload)) {\n            assert.isBoolean(options.disableBeforeUnload, 'options.disableBeforeUnload');\n        }\n\n        if (!_.isNullOrUndefined(options.disableConsoleLogging)) {\n            assert.isBoolean(options.disableConsoleLogging, 'options.disableConsoleLogging');\n        }\n\n        if (!_.isNullOrUndefined(options.loggingLevel)) {\n            assert.isNumber(options.loggingLevel, 'options.loggingLevel');\n        }\n\n        if (!_.isNullOrUndefined(options.treatBackgroundAsOffline)) {\n            assert.isBoolean(options.treatBackgroundAsOffline, 'options.treatBackgroundAsOffline');\n        }\n\n        if (!_.isNullOrUndefined(options.reAuthenticateOnForeground)) {\n            assert.isBoolean(options.reAuthenticateOnForeground, 'options.reAuthenticateOnForeground');\n        }\n\n        if (options.treatBackgroundAsOffline === true && options.reAuthenticateOnForeground === false) {\n            this._logger.warn('Conflicting options \"reAuthenticateOnForeground\" can not be false when \"treatBackgroundAsOffline\" is true. Will reauthenticate upon entering foreground.');\n        }\n\n        if (options.shakaLoader) {\n            assert.isFunction(options.shakaLoader, 'options.shakaLoader');\n        }\n\n        if (options.webPlayerLoader) {\n            assert.isFunction(options.webPlayerLoader, 'options.webPlayerLoader');\n        }\n\n        this._observableStatus = new observable.Observable('offline');\n        this._networkRTT = new observable.Observable(0);\n        this._observableSessionId = new observable.Observable(null);\n        this._deviceId = options.deviceId || '';\n        this._version = sdkVersion;\n\n        if (!options.authToken) {\n            this._baseUri = options.uri || PCastEndPoint.DefaultPCastUri;\n            setupPcastLoggerAndMetrics.call(this, options);\n        } else {\n            var baseUri = this.parseUriFromToken.call(this, options.authToken);\n\n            if (baseUri) {\n                this._baseUri = baseUri;\n                setupPcastLoggerAndMetrics.call(this, options);\n\n                if (options.uri) {\n                    this._logger.warn('Trying to join room with both authToken and uri. Please only use authToken.');\n                }\n\n                this._logger.info('Base uri is set to [%s] from authToken [%s]', baseUri, options.authToken);\n            } else {\n                this._baseUri = options.uri || PCastEndPoint.DefaultPCastUri;\n                setupPcastLoggerAndMetrics.call(this, options);\n\n                if (options.uri) {\n                    this._logger.warn('Trying to join room with options uri. Please use authToken.');\n\n                    this._logger.info('Base uri is set to [%s] from options uri', options.uri);\n                }\n            }\n        }\n\n        this._screenShareExtensionManager = new ScreenShareExtensionManager(options, this._logger);\n        this._shakaLoader = options.shakaLoader;\n        this._webPlayerLoader = options.webPlayerLoader;\n        this._rtmpOptions = options.rtmp || {};\n        this._streamingSourceMapping = options.streamingSourceMapping;\n        this._disposables = new disposable.DisposableList();\n        this._disableMultiplePCastInstanceWarning = options.disableMultiplePCastInstanceWarning;\n        this._treatBackgroundAsOffline = options.treatBackgroundAsOffline === true;\n        this._reAuthenticateOnForeground = options.reAuthenticateOnForeground === true;\n        this._authenticateCallId = 0;\n        this._reAuthenticateCallId = 0;\n        this._canPlaybackAudio = true;\n        this._h264ProfileIds = [];\n        this._supportedWebrtcCodecs = [];\n        this._featureDetector = new FeatureDetector(options.features);\n        this._pendingIceCandidates = {};\n        this._addIceCandidatesTimeoutScheduled = {};\n\n        var that = this;\n        var supportedFeatures = _.filter(this._featureDetector.getFeatures(), FeatureDetector.isFeatureSupported);\n        var logGlobalError = function logGlobalError(event) {\n            var errorToLog = event ? event.error : 'Unknown Error';\n            that._logger.error('Window Error Event Triggered with pcast in [%s] state [%s]', that._observableStatus.getValue(), /* Once for browsers that don't show stack traces */ errorToLog, errorToLog);\n        };\n\n        this._logger.info('Device supports features [%s], user selected [%s]', supportedFeatures, this._featureDetector.getFeatures());\n\n        _.addEventListener(phenixRTC.global, 'unload', function() {\n            that._logger.info('Window Unload Event Triggered');\n\n            return that.stop('window-unload');\n        });\n\n        if (!options.disableGlobalErrorListener) {\n            _.addEventListener(phenixRTC.global, 'error', logGlobalError);\n\n            if (phenixRTC.global.__phenixGlobalErrorListenerDisposable) {\n                phenixRTC.global.__phenixGlobalErrorListenerDisposable.dispose();\n            }\n\n            phenixRTC.global.__phenixGlobalErrorListenerDisposable = new disposable.Disposable(function() {\n                _.removeEventListener(phenixRTC.global, 'unload', logGlobalError);\n            });\n        }\n\n        if (!options.disableBeforeUnload) {\n            _.addEventListener(phenixRTC.global, 'beforeunload', function() {\n                that._logger.info('Window Before Unload Event Triggered');\n\n                return that.stop('window-beforeunload');\n            });\n        }\n\n        if (!phenixRTC.webrtcSupported && phenixRTC.browser === 'ReactNative') {\n            phenixRTC.shim();\n        }\n\n        // We need to check connection status because FF can create PC only with network status online\n        if (phenixRTC.webrtcSupported && this._observableStatus.getValue() === 'online') {\n            setEnvironmentCodecDefaults.call(this);\n            setAudioState.call(this);\n        }\n    }\n\n    PCast.prototype.getBaseUri = function() {\n        return this._baseUri;\n    };\n\n    PCast.prototype.getStatus = function() {\n        return this._observableStatus.getValue();\n    };\n\n    PCast.prototype.getObservableStatus = function() {\n        return this._observableStatus;\n    };\n\n    PCast.prototype.getRemoteDescriptionSdp = function(streamId) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n\n        if (!this._peerConnections) {\n            return;\n        }\n\n        return _.get(this._peerConnections, [streamId, 'remoteDescription', 'sdp']);\n    };\n\n    PCast.prototype.isStarted = function() {\n        return this._started;\n    };\n\n    PCast.prototype.reAuthenticate = function(authToken) {\n        assert.isStringNotEmpty(authToken, 'authToken');\n\n        if (this._observableStatus.getValue() === 'online') {\n            return this._logger.warn('Already authenticated. Denying request to re-authenticate');\n        }\n\n        this._logger.info('Attempting to re-authenticate with new auth token [%s]', authToken);\n\n        this._authToken = authToken;\n\n        reconnected.call(this);\n    };\n\n    PCast.prototype.start = function(authToken, authenticationCallback, onlineCallback, offlineCallback) {\n        assert.isStringNotEmpty(authToken, 'authToken');\n        assert.isFunction(authenticationCallback, 'authenticationCallback');\n        assert.isFunction(onlineCallback, 'onlineCallback');\n        assert.isFunction(offlineCallback, 'offlineCallback');\n\n        if (this._started) {\n            throw new Error('\"Already started\"');\n        }\n\n        if (!_.isNumber(phenixRTC.global.__phenixInstantiatedPCastCount)) {\n            phenixRTC.global.__phenixInstantiatedPCastCount = 1;\n        } else {\n            phenixRTC.global.__phenixInstantiatedPCastCount++;\n        }\n\n        if (phenixRTC.global.__phenixInstantiatedPCastCount > 1 && !this._disableMultiplePCastInstanceWarning) {\n            this._logger.warn('Avoid using multiple instances of PCast as this uses unnecessary resources and will reduce performance. This is your [%s] simultaneous instance. Remember to dispose all resources when done with them by calling .stop() or .dispose()',\n                phenixRTC.global.__phenixInstantiatedPCastCount);\n        }\n\n        this._stopped = false;\n        this._started = true;\n        this._authToken = authToken;\n        this._authenticationCallback = authenticationCallback;\n        this._onlineCallback = onlineCallback;\n        this._offlineCallback = offlineCallback;\n        this._sessionTelemetry = new SessionTelemetry(this._logger, this._metricsTransmitter);\n        this._endPoint = new PCastEndPoint(this._version, this._baseUri, this._logger, this._sessionTelemetry);\n\n        transitionToStatus.call(this, 'connecting');\n\n        this._peerConnections = {};\n        this._mediaStreams = {};\n        this._iceCandidateCallbacks = {};\n        this._publishers = {};\n        this._gumStreams = [];\n\n        this._disposables.add(this._endPoint);\n        this._disposables.add(this._sessionTelemetry);\n        this._disposables.add(applicationActivityDetector.onBackground(_.bind(handleBackground, this)));\n        this._disposables.add(applicationActivityDetector.onForeground(_.bind(handleForeground, this)));\n\n        var that = this;\n\n        that._endPoint.resolveUri(function(err, endPoint) {\n            if (err) {\n                that._logger.error('Failed to connect to [%s]', that._baseUri, err);\n\n                if (that._authenticationCallback) {\n                    switch (err.code) {\n                    case 0:\n                        that._authenticationCallback.call(that, that, 'network-unavailable', '');\n\n                        break;\n                    case 503:\n                        that._authenticationCallback.call(that, that, 'capacity', '');\n\n                        break;\n                    default:\n                        that._authenticationCallback.call(that, that, 'critical-network-issue', '');\n\n                        return;\n                    }\n                }\n\n                transitionToStatus.call(that, 'offline');\n\n                that._stopped = true;\n                that._started = false;\n\n                return;\n            }\n\n            that._logger.info('Discovered end point [%s] with RTT [%s]', endPoint.uri, endPoint.roundTripTime);\n\n            that._networkOneWayLatency = endPoint.roundTripTime / 2;\n            that._resolvedEndPoint = endPoint.uri;\n\n            if (!that._started) {\n                return;\n            }\n\n            instantiateProtocol.call(that, endPoint.uri);\n        });\n    };\n\n    PCast.prototype.stop = function(reason) {\n        reason = reason || '';\n\n        assert.isString(reason, 'reason');\n\n        if (!this._started) {\n            return;\n        }\n\n        this._logger.info('Stopping pcast instance with reason [%s]', reason);\n\n        this._stopped = true;\n        this._started = false;\n\n        delete this._authenticationCallback;\n\n        try {\n            var that = this;\n\n            _.forOwn(this._mediaStreams, function(mediaStream, streamId) {\n                endStream.call(that, streamId, reason);\n            });\n            _.forOwn(this._publishers, function(publisher, publisherStreamId) {\n                endStream.call(that, publisherStreamId, reason);\n\n                if (!_.includes(publisher.getOptions(), 'detached')) {\n                    publisher.stop(reason, true);\n                }\n            });\n            _.forOwn(this._peerConnections, function(mediaStream, peerConnectionStreamId) {\n                endStream.call(that, peerConnectionStreamId, reason);\n            });\n            _.forEach(this._gumStreams, function(gumStream) {\n                var tracks = gumStream.getTracks();\n\n                _.forEach(tracks, function(track) {\n                    track.stop();\n                });\n            });\n        } catch (e) {\n            that._logger.warn('Pcast stop caught an error', e);\n        } finally {\n            if (this._protocol) {\n                try {\n                    this._protocol.disconnect();\n                } catch (e) {\n                    that._logger.warn('Failed to disconnect pcast', e);\n                }\n\n                this._protocol = null;\n            }\n\n            if (this._logger.setObservableSessionId) {\n                this._logger.setObservableSessionId(null);\n            }\n\n            if (this._sessionTelemetrySubscription) {\n                this._sessionTelemetrySubscription.dispose();\n                this._sessionTelemetry.setSessionId(null);\n            }\n\n            if (this._sessionIdSubscription) {\n                this._sessionIdSubscription.dispose();\n                this._observableSessionId.setValue(null);\n            }\n\n            phenixRTC.global.__phenixInstantiatedPCastCount--;\n\n            this._disposables.dispose();\n        }\n    };\n\n    PCast.prototype.getUserMedia = function(options, callback, onScreenShare) {\n        if (phenixRTC.browser === 'IE') {\n            throw new Error('Publishing not supported on IE');\n        }\n\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        if (onScreenShare) {\n            assert.isFunction(onScreenShare, 'onScreenShare');\n        }\n\n        var userMediaProvider = new UserMediaProvider(this._logger, this._screenShareExtensionManager, onScreenShare);\n\n        return userMediaProvider.getUserMedia(options, callback);\n    };\n\n    PCast.prototype.publish = function(streamToken, streamToPublish, callback, tags, options) {\n        if (phenixRTC.browser === 'IE') {\n            throw new Error('Publishing not supported on IE');\n        }\n\n        if (!this._started) {\n            throw new Error('PCast not started. Unable to publish. Please start pcast first.');\n        }\n\n        tags = tags || [];\n        options = options || {};\n\n        assert.isStringNotEmpty(streamToken, 'streamToken');\n        assert.isFunction(callback, 'callback');\n        assert.isArray(tags, 'tags');\n        assert.isObject(options, 'options');\n\n        if (!_.isObject(streamToPublish) && !_.isString(streamToPublish)) {\n            throw new Error('\"streamToPublish\" must be an object or URI');\n        }\n\n        var that = this;\n        var streamType = 'upload';\n        var setupStreamOptions = _.assign({}, options, {negotiate: true});\n\n        if (_.isString(streamToPublish)) {\n            setupStreamOptions.negotiate = false;\n            setupStreamOptions.connectUri = streamToPublish;\n        } else {\n            setupStreamOptions.connectUri = options.connectUri;\n        }\n\n        if (tags.length > 0) {\n            setupStreamOptions.tags = tags;\n        }\n\n        var streamTelemetry = new StreamTelemetry(this.getProtocol().getSessionId(), this._logger, this._metricsTransmitter);\n\n        streamTelemetry.setProperty('resource', streamType);\n        this._protocol.setupStream(streamType, streamToken, setupStreamOptions, that._networkOneWayLatency * 2, function(error, response) {\n            if (error) {\n                that._logger.error('Failed to create uploader [%s]', error);\n\n                return callback.call(that, that, 'failed');\n            } else if (response.status !== 'ok') {\n                that._logger.warn('Failed to create uploader, status [%s]', response.status);\n\n                switch (response.status) {\n                case 'timeout':\n                case 'capacity':\n                case 'unauthorized':\n                    return callback.call(that, that, response.status);\n                default:\n                    return callback.call(that, that, 'failed');\n                }\n            } else {\n                var streamId = response.createStreamResponse.streamId;\n\n                streamTelemetry.setStreamId(streamId);\n                streamTelemetry.setStartOffset(response.createStreamResponse.offset);\n                streamTelemetry.recordMetric('Provisioned');\n                streamTelemetry.recordMetric('RoundTripTime', {uint64: that._networkOneWayLatency * 2}, null, {\n                    resource: that._resolvedEndPoint,\n                    kind: 'https'\n                });\n\n                if (setupStreamOptions.negotiate === true) {\n                    var offerSdp = response.createStreamResponse.createOfferDescriptionResponse.sessionDescription.sdp;\n                    var peerConnectionConfig = applyVendorSpecificLogic(parseProtobufMessage(response.createStreamResponse.rtcConfiguration));\n\n                    if (phenixRTC.browser === 'Opera' && that._h264ProfileIds.length > 0) {\n                        // For publishing we need any profile and level that is equal to or greater than the offer's profile and level\n                        var profileLevelIdToReplace = _.get(sdpUtil.getH264ProfileIds(offerSdp), [0]);\n                        var preferredLevelId = sdpUtil.getH264ProfileIdWithSameProfileAndEqualToOrHigherLevel(that._h264ProfileIds, profileLevelIdToReplace);\n\n                        if (!preferredLevelId) {\n                            that._logger.warn('[%s] Unable to find h264 profile level id to replace [%s]. Rejected environment defaults of [%s]',\n                                streamId, profileLevelIdToReplace, that._h264ProfileIds);\n                        } else if (profileLevelIdToReplace !== preferredLevelId) {\n                            that._logger.info('[%s] Replacing publisher h264 profile level id [%s] with new value [%s] in offer sdp',\n                                streamId, profileLevelIdToReplace, preferredLevelId);\n\n                            offerSdp = sdpUtil.replaceH264ProfileId(offerSdp, profileLevelIdToReplace, preferredLevelId);\n                        }\n                    }\n\n                    return createPublisherPeerConnection.call(that, peerConnectionConfig, streamToPublish, streamId, offerSdp, streamTelemetry, function(phenixPublisher, error) {\n                        streamTelemetry.recordMetric('SetupCompleted', {string: error ? 'failed' : 'ok'});\n\n                        if (error) {\n                            callback.call(that, that, 'failed', null);\n                        } else {\n                            callback.call(that, that, 'ok', phenixPublisher);\n                        }\n                    }, options, response.createStreamResponse.options);\n                }\n\n                return createPublisher.call(that, streamId, function(phenixPublisher, error) {\n                    streamTelemetry.recordMetric('SetupCompleted', {string: error ? 'failed' : 'ok'});\n\n                    if (error) {\n                        callback.call(that, that, 'failed', null);\n                    } else {\n                        callback.call(that, that, 'ok', phenixPublisher);\n                    }\n                }, response.createStreamResponse.options);\n            }\n        });\n    };\n\n    PCast.prototype.subscribe = function(streamToken, callback, options) {\n        if (!this._started) {\n            throw new Error('PCast not started. Unable to subscribe. Please start pcast first.');\n        }\n\n        options = options || {};\n\n        assert.isStringNotEmpty(streamToken, 'streamToken');\n        assert.isFunction(callback, 'callback');\n        assert.isObject(options, 'options');\n\n        var that = this;\n\n        setAudioState.call(that, function() {\n            var streamType = 'download';\n            var setupStreamOptions = _.assign({}, options, {negotiate: options.negotiate !== false});\n            var streamTelemetry = new StreamTelemetry(that.getProtocol().getSessionId(), that._logger, that._metricsTransmitter);\n            var createViewerOptions = _.assign({}, options);\n\n            createViewerOptions.canPlaybackAudio = that._canPlaybackAudio;\n\n            createViewerOptions.capabilities = that.parseCapabilitiesFromToken(streamToken);\n\n            if (!that._canPlaybackAudio && options.disableAudioIfNoOutputFound && options.receiveAudio !== false) {\n                setupStreamOptions.receiveAudio = false;\n                createViewerOptions.receiveAudio = false;\n                createViewerOptions.forcedAudioDisabled = true;\n            }\n\n            if (options.originStreamId) {\n                setupStreamOptions.originStreamId = options.originStreamId;\n            }\n\n            streamTelemetry.setProperty('resource', streamType);\n\n            that._protocol.setupStream(streamType, streamToken, setupStreamOptions, that._networkOneWayLatency * 2, function(error, response) {\n                if (error) {\n                    that._logger.error('Failed to create downloader [%s]', error);\n\n                    return callback.call(that, that, 'failed');\n                } else if (response.status !== 'ok') {\n                    that._logger.warn('Failed to create downloader, status [%s]', response.status);\n\n                    return callback.call(that, that, response.status);\n                }\n\n                var streamId = response.createStreamResponse.streamId;\n                var offerSdp = response.createStreamResponse.createOfferDescriptionResponse.sessionDescription.sdp;\n                var peerConnectionConfig = applyVendorSpecificLogic(parseProtobufMessage(response.createStreamResponse.rtcConfiguration));\n                var create = _.bind(createViewerPeerConnection, that, peerConnectionConfig);\n                var isNotRealTime = !(offerSdp.match(/m=audio /) || offerSdp.match(/m=video /)) && (offerSdp.match(/a=x-playlist:/) || offerSdp.match(/a=x-rtmp:/));\n\n                if (isNotRealTime) {\n                    create = createChunkedOrRtmpViewer;\n                }\n\n                streamTelemetry.setStreamId(streamId);\n                streamTelemetry.setStartOffset(response.createStreamResponse.offset);\n                streamTelemetry.recordMetric('Provisioned');\n                streamTelemetry.recordMetric('RoundTripTime', {uint64: that._networkOneWayLatency * 2}, null, {\n                    resource: that.getBaseUri(),\n                    kind: 'https'\n                });\n\n                createViewerOptions.originStartTime = _.now() - response.createStreamResponse.offset + that._networkOneWayLatency;\n\n                if (!isNotRealTime && ((phenixRTC.browser === 'Chrome' && phenixRTC.browserVersion >= 62 && FeatureDetector.isMobile()) || phenixRTC.browser === 'Opera') && that._h264ProfileIds.length > 0) {\n                    // For subscribing we need any profile and level that is equal to or greater than the offer's profile and level\n                    var profileLevelIdToReplace = _.get(sdpUtil.getH264ProfileIds(offerSdp), [0]);\n                    var preferredLevelId = sdpUtil.getH264ProfileIdWithSameOrHigherProfileAndEqualToOrHigherLevel(that._h264ProfileIds, profileLevelIdToReplace);\n\n                    if (!preferredLevelId) {\n                        that._logger.warn('[%s] Unable to find new subscriber h264 profile level id to replace [%s]. Rejected environment defaults of [%s]',\n                            streamId, profileLevelIdToReplace, that._h264ProfileIds);\n                    } else if (profileLevelIdToReplace !== preferredLevelId) {\n                        that._logger.info('[%s] Replacing subscriber h264 profile level id [%s] with new value [%s] in offer sdp',\n                            streamId, profileLevelIdToReplace, preferredLevelId);\n\n                        offerSdp = sdpUtil.replaceH264ProfileId(offerSdp, profileLevelIdToReplace, preferredLevelId);\n                    }\n                }\n\n                return create.call(that, streamId, offerSdp, streamTelemetry, function(phenixMediaStream, error) {\n                    streamTelemetry.recordMetric('SetupCompleted', {string: error ? 'failed' : 'ok'});\n\n                    if (error) {\n                        callback.call(that, that, 'failed', null);\n                    } else {\n                        callback.call(that, that, 'ok', phenixMediaStream);\n                    }\n                }, createViewerOptions);\n            });\n        });\n    };\n\n    PCast.prototype.getProtocol = function() {\n        return this._protocol;\n    };\n\n    PCast.prototype.getLogger = function() {\n        return this._logger;\n    };\n\n    PCast.prototype.getObservableSessionId = function() {\n        return this._observableSessionId;\n    };\n\n    PCast.prototype.toString = function() {\n        var protocol = this.getProtocol();\n        var sessionId = protocol ? protocol.getSessionId() : '';\n\n        return 'PCast[' + sessionId || 'unauthenticated' + ',' + (protocol ? protocol.toString() : 'uninitialized') + ']';\n    };\n\n    PCast.prototype.parseCapabilitiesFromToken = function(streamToken) {\n        return _.get(parseToken.call(this, streamToken), ['capabilities'], []);\n    };\n\n    PCast.prototype.parseUriFromToken = function(streamToken) {\n        return _.get(parseToken.call(this, streamToken), ['uri'], '');\n    };\n\n    PCast.prototype.parseRoomOrChannelIdFromToken = function(streamToken) {\n        var requiredTag = _.get(parseToken.call(this, streamToken), ['requiredTag'], '');\n        var idMatch = requiredTag.match(roomOrChannelIdRegex);\n\n        return idMatch ? idMatch[1] : null;\n    };\n\n    PCast.prototype.parseRoomOrChannelAliasFromToken = function(streamToken) {\n        var requiredTag = _.get(parseToken.call(this, streamToken), ['requiredTag'], '');\n        var aliasMatch = requiredTag.match(roomOrChannelAliasRegex);\n\n        return aliasMatch ? aliasMatch[1] : null;\n    };\n\n    function setupPcastLoggerAndMetrics(options) {\n        this._logger = options.logger || pcastLoggerFactory.createPCastLogger(this._baseUri, options.disableConsoleLogging, options.loggingLevel);\n        this._metricsTransmitter = options.metricsTransmitter || metricsTransmitterFactory.createMetricsTransmitter(this._baseUri);\n    }\n\n    function parseToken(streamToken) {\n        if (!_.startsWith(streamToken, 'DIGEST:')) {\n            this._logger.warn('Failed to parse the `streamToken` [%s]', streamToken);\n\n            throw new Error('Bad `streamToken`');\n        }\n\n        try {\n            var base64Token = streamToken.split(':')[1];\n            var decodedToken = phenixRTC.global.atob(base64Token);\n            var token = JSON.parse(decodedToken).token;\n            var tokenOptions = JSON.parse(token);\n\n            return tokenOptions;\n        } catch (e) {\n            var sessionId = this.getProtocol().getSessionId();\n            this._logger.warn('[%s] Failed to parse the `streamToken` [%s]', sessionId, streamToken);\n\n            throw new Error(e);\n        }\n    }\n\n    function instantiateProtocol(uri) {\n        this._protocol = new PCastProtocol(uri, this._deviceId, this._version, this._logger);\n\n        this._protocol.onEvent('connected', _.bind(connected, this));\n        this._protocol.onEvent('reconnecting', _.bind(reconnecting, this));\n        this._protocol.onEvent('reconnected', _.bind(reconnected, this));\n        this._protocol.onEvent('disconnected', _.bind(disconnected, this));\n        this._protocol.onEvent('pcast.StreamEnded', _.bind(streamEnded, this));\n        this._protocol.onEvent('pcast.StreamDataQuality', _.bind(dataQuality, this));\n\n        if (this._logger.setObservableSessionId) {\n            this._logger.setObservableSessionId(this._protocol.getObservableSessionId());\n        }\n\n        if (this._sessionTelemetrySubscription) {\n            this._sessionTelemetrySubscription.dispose();\n            this._sessionTelemetry.setSessionId(null);\n        }\n\n        if (this._sessionIdSubscription) {\n            this._sessionIdSubscription.dispose();\n        }\n\n        var handleSessionIdChange = function(sessionId) {\n            this._observableSessionId.setValue(sessionId);\n        };\n\n        this._sessionIdSubscription = this._protocol.getObservableSessionId().subscribe(_.bind(handleSessionIdChange, this));\n\n        this._sessionTelemetrySubscription = this._protocol.getObservableSessionId().subscribe(_.bind(this._sessionTelemetry.setSessionId, this._sessionTelemetry));\n    }\n\n    function connected() {\n        var that = this;\n\n        if (that._stopped) {\n            that._logger.warn('[%s] Skip connect due to stopped state', that);\n\n            return;\n        }\n\n        if (areAllPeerConnectionsOffline.call(that) && that._observableStatus.getValue() === 'offline') {\n            this._logger.warn('[PCast] connected after being offline. Reconnecting.');\n\n            reconnecting.call(that);\n        }\n\n        this._connected = true;\n\n        var protocol = that._protocol;\n        var authenticateCallId = ++that._authenticateCallId;\n\n        protocol.authenticate(that._authToken, function(error, response) {\n            if (protocol !== that._protocol) {\n                that._logger.info('Ignoring authentication response as reset took place');\n\n                return;\n            }\n\n            if (authenticateCallId !== that._authenticateCallId) {\n                that._logger.info('Ignoring authentication response as a latter request is already underway');\n\n                return;\n            }\n\n            if (that._authenticationCallback) {\n                if (error) {\n                    that._logger.error('Failed to authenticate [%s]', error);\n                    transitionToStatus.call(that, 'unauthorized');\n                    that._authenticationCallback.call(that, that, 'unauthorized', '');\n                } else if (response.status !== 'ok') {\n                    that._logger.warn('Failed to authenticate, status [%s]', response.status);\n                    transitionToStatus.call(that, 'unauthorized');\n                    that._authenticationCallback.call(that, that, 'unauthorized', '');\n                } else {\n                    transitionToStatus.call(that, 'online');\n\n                    that._authenticationCallback.call(that, that, response.status, response.sessionId);\n                }\n            }\n        });\n    }\n\n    function reconnecting() {\n        transitionToStatus.call(this, 'reconnecting');\n    }\n\n    function reconnected(optionalReason) {\n        if (optionalReason) {\n            assert.isString('reason', optionalReason);\n        }\n\n        transitionToStatus.call(this, 'reconnected', optionalReason);\n\n        this._logger.info('Attempting to re-authenticate after reconnected event [%s]', optionalReason);\n\n        reAuthenticate.call(this);\n    }\n\n    function reAuthenticate() {\n        var that = this;\n\n        if (that._stopped) {\n            that._logger.info('Skip re-authentication due to stopped state');\n\n            return;\n        }\n\n        var protocol = that._protocol;\n        var reAuthenticateCallId = ++that._reAuthenticateCallId;\n\n        protocol.authenticate(that._authToken, function(error, response) {\n            var suppressCallbackIfNeverDisconnected = that._connected === true;\n\n            if (protocol !== that._protocol) {\n                that._logger.info('Ignoring re-authentication response as reset took place');\n\n                return;\n            }\n\n            if (reAuthenticateCallId !== that._reAuthenticateCallId) {\n                that._logger.info('Ignoring re-authentication response as a latter request is already underway');\n\n                return;\n            }\n\n            if (error) {\n                that._logger.error('Unable to authenticate after reconnect to WebSocket [%s]', error);\n\n                return transitionToStatus.call(that, 'reconnect-failed');\n            }\n\n            if (response.status !== 'ok') {\n                that._logger.warn('Unable to authenticate after reconnect to WebSocket, status [%s]', response.status);\n\n                var reason = response.status === 'capacity' ? response.status : 'reconnect-failed';\n\n                return transitionToStatus.call(that, reason);\n            }\n\n            that._connected = true;\n\n            that._logger.info('Successfully authenticated after reconnect to WebSocket');\n\n            return transitionToStatus.call(that, 'online', null, suppressCallbackIfNeverDisconnected);\n        });\n    }\n\n    function disconnected() {\n        if (areAllPeerConnectionsOffline.call(this) && this._observableStatus.getValue() === 'reconnecting') {\n            this._logger.warn('[PCast] disconnected after attempting to reconnect. Going offline.');\n\n            transitionToStatus.call(this, 'critical-network-issue');\n\n            return this.stop('critical-network-issue');\n        }\n\n        this._connected = false;\n        transitionToStatus.call(this, 'offline');\n    }\n\n    function areAllPeerConnectionsOffline() {\n        return _.reduce(this._peerConnections, function(isOffline, peerConnection) {\n            if (!isOffline) {\n                return isOffline;\n            }\n\n            return peerConnection.iceConnectionState === 'closed';\n        }, true);\n    }\n\n    function streamEnded(event) {\n        var streamId = event.streamId;\n        var reason = event.reason;\n\n        return endStream.call(this, streamId, reason);\n    }\n\n    function dataQuality(event) {\n        var streamId = event.streamId;\n        var status = event.status;\n        var reason = event.reason;\n\n        var internalMediaStream = this._mediaStreams[streamId];\n\n        if (internalMediaStream) {\n            internalMediaStream.dataQualityChangedCallback(status, reason);\n        }\n\n        var publisher = this._publishers[streamId];\n\n        if (publisher && _.isFunction(publisher.dataQualityChangedCallback)) {\n            publisher.dataQualityChangedCallback(publisher, status, reason);\n        }\n    }\n\n    function endStream(streamId, reason) {\n        this._logger.info('[%s] Stream ended with reason [%s]', streamId, reason);\n\n        var internalMediaStream = this._mediaStreams[streamId];\n\n        if (internalMediaStream) {\n            internalMediaStream.streamEndedCallback(StreamWrapper.getStreamEndedStatus(reason), reason, true);\n        }\n\n        delete this._mediaStreams[streamId];\n\n        var publisher = this._publishers[streamId];\n\n        if (publisher && _.isFunction(publisher.publisherEndedCallback)) {\n            publisher.publisherEndedCallback(publisher, StreamWrapper.getStreamEndedStatus(reason), reason);\n        }\n\n        delete this._publishers[streamId];\n\n        var peerConnection = this._peerConnections[streamId];\n\n        if (peerConnection) {\n            closePeerConnection.call(this, streamId, peerConnection, 'ended');\n        }\n\n        delete this._peerConnections[streamId];\n    }\n\n    function setupStreamAddedListener(streamId, state, peerConnection, streamTelemetry, callback, options) {\n        var that = this;\n        var added = false;\n        var setupTimeoutId;\n        var streamSetupInterval = 3000;\n        var onAddStream = function onAddStream(event) {\n            if (state.failed || added) {\n                return;\n            }\n\n            var numberOfActiveTracks = sdpUtil.getNumberOfActiveSections(peerConnection);\n            var masterStream = event.stream || _.get(event, ['streams', 0]);\n            var kind = 'real-time';\n\n            if (!masterStream) {\n                state.failed = true;\n                that._logger.warn('[%s] No remote stream', streamId);\n\n                return callback.call(that, undefined, 'failed');\n            }\n\n            if (setupTimeoutId) {\n                clearTimeout(setupTimeoutId);\n            }\n\n            if (numberOfActiveTracks !== masterStream.getTracks().length && phenixRTC.browser !== 'ReactNative') {\n                setupTimeoutId = setTimeout(function() {\n                    state.failed = true;\n                    that._logger.warn('[%s] Did not receive all tracks within [%s] ms', streamId, streamSetupInterval);\n\n                    return callback.call(that, undefined, 'failed');\n                }, streamSetupInterval);\n\n                return;\n            }\n\n            added = true;\n\n            that._logger.info('[%s] Got remote stream', streamId);\n\n            streamTelemetry.setProperty('kind', kind);\n\n            var streamOptions = _.assign({networkLag: that._networkOneWayLatency}, options);\n            var realTimeStream = new PhenixRealTimeStream(streamId, masterStream, peerConnection, streamTelemetry, streamOptions, that._logger);\n            var realTimeStreamDecorator = new StreamWrapper(kind, realTimeStream, that._logger);\n\n            var onError = function onError(source, event) {\n                that._logger.info('Phenix Real-Time stream error [%s] [%s]', source, event);\n\n                realTimeStreamDecorator.streamErrorCallback(kind, event);\n            };\n\n            var onStop = function destroyMasterMediaStream(reason) {\n                if (state.stopped || !that._protocol) {\n                    return;\n                }\n\n                that._logger.info('[%s] media stream has stopped with reason [%s]', streamId, reason);\n\n                closePeerConnection.call(that, streamId, peerConnection, 'stop');\n\n                that._protocol.destroyStream(streamId, reason || '', function(error, response) {\n                    if (error) {\n                        that._logger.error('[%s] failed to destroy stream [%s]', streamId, error);\n\n                        return;\n                    } else if (response.status !== 'ok') {\n                        that._logger.warn('[%s] failed to destroy stream, status [%s]', streamId, response.status);\n\n                        return;\n                    }\n\n                    that._logger.info('[%s] destroyed stream', streamId);\n                });\n\n                state.stopped = true;\n            };\n\n            realTimeStreamDecorator.on(streamEnums.streamEvents.playerError.name, onError);\n            realTimeStreamDecorator.on(streamEnums.streamEvents.stopped.name, onStop);\n\n            that._mediaStreams[streamId] = realTimeStreamDecorator;\n\n            callback.call(that, realTimeStream);\n        };\n\n        _.addEventListener(peerConnection, 'addstream', onAddStream);\n        _.addEventListener(peerConnection, 'track', onAddStream);\n    }\n\n    function setupIceCandidateListener(streamId, peerConnection, callback) {\n        var that = this;\n        var onIceCandidate = function onIceCandidate(event) {\n            var candidate = event.candidate;\n\n            if (candidate) {\n                that._logger.info('[%s] ICE candidate: [%s] [%s] [%s]', streamId, candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate);\n            } else {\n                that._logger.info('[%s] ICE candidate discovery complete', streamId);\n            }\n\n            if (callback) {\n                callback(candidate);\n            }\n        };\n\n        _.addEventListener(peerConnection, 'icecandidate', onIceCandidate);\n    }\n\n    function setupStateListener(streamId, peerConnection) {\n        var that = this;\n        var onNegotiationNeeded = function onNegotiationNeeded(event) { // eslint-disable-line no-unused-vars\n            that._logger.info('[%s] Negotiation needed', streamId);\n        };\n\n        var onIceConnectionStateChanged = function onIceConnectionStateChanged(event) { // eslint-disable-line no-unused-vars\n            that._logger.info('[%s] ICE connection state changed [%s]', streamId, peerConnection.iceConnectionState);\n        };\n\n        var onIceGatheringStateChanged = function onIceGatheringStateChanged(event) { // eslint-disable-line no-unused-vars\n            that._logger.info('[%s] ICE gathering state changed [%s]', streamId, peerConnection.iceGatheringState);\n        };\n\n        var onSignalingStateChanged = function onSignalingStateChanged(event) { // eslint-disable-line no-unused-vars\n            that._logger.info('[%s] Signaling state changed [%s]', streamId, peerConnection.signalingState);\n        };\n\n        var onConnectionStateChanged = function onConnectionStateChanged(event) { // eslint-disable-line no-unused-vars\n            that._logger.info('[%s] Connection state changed [%s]', streamId, peerConnection.connectionState);\n        };\n\n        _.addEventListener(peerConnection, 'negotiationneeded', onNegotiationNeeded);\n        _.addEventListener(peerConnection, 'iceconnectionstatechange', onIceConnectionStateChanged);\n        _.addEventListener(peerConnection, 'icegatheringstatechange ', onIceGatheringStateChanged);\n        _.addEventListener(peerConnection, 'signalingstatechange', onSignalingStateChanged);\n        _.addEventListener(peerConnection, 'connectionstatechange', onConnectionStateChanged);\n    }\n\n    function createPublisher(streamId, callback, streamOptions) {\n        var that = this;\n        var state = {stopped: false};\n\n        var publisher = {\n            getStreamId: function getStreamId() {\n                return streamId;\n            },\n\n            getStream: function getStream() {\n                that._logger.debug('[%s] Unable to get stream for remote origin.', streamId);\n\n                return null;\n            },\n\n            getStats: function getStats() {\n                that._logger.debug('[%s] Unable to get stream stats for remote origin.', streamId);\n\n                return null;\n            },\n\n            isActive: function isActive() {\n                return !state.stopped;\n            },\n\n            hasEnded: function hasEnded() {\n                return state.stopped;\n            },\n\n            stop: function stop(reason) {\n                if (state.stopped) {\n                    return;\n                }\n\n                that._logger.info('[%s] stopping publisher with reason [%s]', streamId, reason);\n\n                that._protocol.destroyStream(streamId, reason || '', function(error, response) {\n                    if (error) {\n                        that._logger.error('[%s] failed to destroy stream [%s]', streamId, error);\n\n                        return;\n                    } else if (response.status !== 'ok') {\n                        that._logger.warn('[%s] failed to destroy stream, status [%s]', streamId, response.status);\n\n                        return;\n                    }\n\n                    that._logger.info('[%s] destroyed stream', streamId);\n                });\n\n                state.stopped = true;\n            },\n\n            setPublisherEndedCallback: function setPublisherEndedCallback(callback) {\n                assert.isFunction(callback, 'callback');\n\n                this.publisherEndedCallback = callback;\n            },\n\n            setDataQualityChangedCallback: function setDataQualityChangedCallback(callback) {\n                assert.isFunction(callback, 'callback');\n\n                this.dataQualityChangedCallback = callback;\n            },\n\n            getOptions: function getOptions() {\n                return streamOptions;\n            },\n\n            monitor: function monitor(options, callback) {\n                assert.isObject(options, 'options');\n                assert.isFunction(callback, 'callback');\n            },\n\n            getMonitor: function getMonitor() {\n                return null;\n            }\n        };\n\n        that._publishers[streamId] = publisher;\n\n        callback(publisher);\n    }\n\n    function setEnvironmentCodecDefaults() {\n        var that = this;\n        var peerConnection = new phenixRTC.RTCPeerConnection();\n\n        // TODO(DY) remove when updating to webrtc-adapter version 5.0.5 or greater\n        if (phenixRTC.browser === 'Safari' && phenixRTC.browserVersion > 10) {\n            peerConnection.addTransceiver('audio');\n            peerConnection.addTransceiver('video');\n        }\n\n        try {\n            var handleOffer = function handleOffer(offer) {\n                var h264ProfileIds = sdpUtil.getH264ProfileIds(offer.sdp);\n\n                that._supportedWebrtcCodecs = sdpUtil.getSupportedCodecs(offer.sdp);\n\n                that._logger.info('Supported WebRTC video codecs [%s]', that._supportedWebrtcCodecs);\n\n                if (h264ProfileIds.length === 0) {\n                    return that._logger.info('Unable to find local h264 profile level id', offer.sdp);\n                }\n\n                that._logger.info('Found local h264 profile level ids [%s]', h264ProfileIds, offer.sdp);\n\n                that._h264ProfileIds = h264ProfileIds;\n\n                if (peerConnection.close) {\n                    peerConnection.close();\n                }\n            };\n\n            var handleFailure = function(e) {\n                that._logger.error('Unable to create offer to get local h264 profile level id', e);\n\n                if (peerConnection.close) {\n                    peerConnection.close();\n                }\n            };\n\n            var constraints = {\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            };\n\n            if (typeof phenixRTC.global.Promise === 'function') {\n                return peerConnection.createOffer(constraints)\n                    .then(handleOffer)\n                    .catch(handleFailure);\n            }\n\n            peerConnection.createOffer(handleOffer, handleFailure, constraints);\n        } catch (e) {\n            that._logger.error('Failed to set environment defaults. Creating the Offer failed', e);\n\n            if (peerConnection.close) {\n                peerConnection.close();\n            }\n        }\n    }\n\n    function setAudioState(done) {\n        var that = this;\n\n        switch (phenixRTC.browser) {\n        case 'Edge':\n            return phenixRTC.getDestinations(function(destinations) {\n                var audioDestinations = _.filter(destinations, function(destination) {\n                    return destination.kind === 'audio';\n                });\n\n                if (audioDestinations.length === 0) {\n                    if (that._canPlaybackAudio) {\n                        that._logger.info('Detected no audio devices attached to machine');\n                    }\n\n                    that._canPlaybackAudio = false;\n                } else {\n                    that._canPlaybackAudio = true;\n                }\n\n                if (done) {\n                    done();\n                }\n            });\n        default:\n            if (done) {\n                done();\n            }\n\n            break;\n        }\n    }\n\n    function createPublisherPeerConnection(peerConnectionConfig, mediaStream, streamId, offerSdp, streamTelemetry, callback, createOptions, streamOptions) {\n        var that = this;\n        var state = {\n            failed: false,\n            stopped: false\n        };\n        var hasCrypto = offerSdp.match(/a=crypto:/i);\n        var hasDataChannel = offerSdp.match(/m=application /i);\n        var peerConnection = new phenixRTC.RTCPeerConnection(peerConnectionConfig, {\n            'optional': [\n                {DtlsSrtpKeyAgreement: !hasCrypto}, {RtpDataChannels: hasDataChannel}\n            ]\n        });\n        var remoteMediaStream = null;\n        var publisherMonitor = null;\n\n        shimPeerConnectionGetStreams(peerConnection);\n\n        that._peerConnections[streamId] = peerConnection;\n\n        peerConnection.addStream(mediaStream);\n\n        if (phenixRTC.browser === 'Firefox' || phenixRTC.browser === 'Edge') {\n            if (offerSdp.match(/(\\nm=video)/g) && offerSdp.match(/(\\nm=audio)/g)) {\n                var firstSection = /(a=candidate)((.|\\n)*)(?=m=)/g;\n\n                offerSdp = offerSdp.replace(firstSection, offerSdp.match(firstSection) + 'a=end-of-candidates\\n');\n            }\n\n            offerSdp += 'a=end-of-candidates';\n\n            offerSdp = offerSdp.replace(/(\\na=ice-options:trickle)/g, '');\n        }\n\n        var onFailure = function onFailure(status) {\n            if (state.failed) {\n                return;\n            }\n\n            if (status instanceof Error) {\n                that._logger.info('[%s] Failed to setup peer connection', streamId, status);\n\n                status = 'failed';\n            }\n\n            state.failed = true;\n            state.stopped = true;\n\n            delete that._peerConnections[streamId];\n            delete that._publishers[streamId];\n            delete that._iceCandidateCallbacks[streamId];\n\n            closePeerConnection.call(that, streamId, peerConnection, 'failure');\n\n            callback.call(that, undefined, status || 'failed');\n        };\n\n        var createPublisher = function createPublisher() {\n            var bandwidthAttribute = /(b=AS:([0-9]*)[\\n\\r]*)/gi;\n            var video = /(mid:video)([\\n\\r]*)/gi;\n            var limit = 0;\n            var bandwithAttribute = bandwidthAttribute.exec(offerSdp);\n\n            if (bandwithAttribute && bandwithAttribute.length >= 3) {\n                limit = bandwithAttribute[2] * 1000;\n            }\n\n            var publisher = {\n                getStreamId: function getStreamId() {\n                    return streamId;\n                },\n\n                getStream: function getStream() {\n                    return mediaStream;\n                },\n\n                isActive: function isActive() {\n                    return !state.stopped;\n                },\n\n                hasEnded: function hasEnded() {\n                    switch (peerConnection.iceConnectionState) {\n                    case 'new':\n                    case 'checking':\n                    case 'connected':\n                    case 'completed':\n                        return false;\n                    case 'disconnected':\n                    case 'failed':\n                    case 'closed':\n                        return true;\n                    default:\n                        return true;\n                    }\n                },\n\n                stop: function stop(reason) {\n                    if (state.stopped || !that._protocol) {\n                        return;\n                    }\n\n                    that._logger.info('[%s] stopping publisher with reason [%s]', streamId, reason || 'client-action');\n\n                    closePeerConnection.call(that, streamId, peerConnection, 'closed');\n\n                    that._protocol.destroyStream(streamId, reason || '', function(error, response) {\n                        if (error) {\n                            that._logger.error('[%s] failed to destroy stream [%s]', streamId, error);\n\n                            return;\n                        } else if (response.status !== 'ok') {\n                            that._logger.warn('[%s] failed to destroy stream, status [%s]', streamId, response.status);\n\n                            return;\n                        }\n\n                        that._logger.info('[%s] destroyed stream', streamId);\n                    });\n\n                    state.stopped = true;\n                },\n\n                setPublisherEndedCallback: function setPublisherEndedCallback(callback) {\n                    assert.isFunction(callback, 'callback');\n\n                    this.publisherEndedCallback = callback;\n                },\n\n                setDataQualityChangedCallback: function setDataQualityChangedCallback(callback) {\n                    assert.isFunction(callback, 'callback');\n\n                    this.dataQualityChangedCallback = callback;\n                },\n\n                limitBandwidth: function limitBandwidth(bandwidthLimit) {\n                    if (phenixRTC.browser === 'Edge') {\n                        return that._logger.warn('Limit bandwidth not support on [%s]', phenixRTC.browser);\n                    }\n\n                    assert.isNumber(bandwidthLimit, 'bandwidthLimit');\n\n                    var newLimit = limit ? Math.min(bandwidthLimit, limit) : bandwidthLimit;\n                    var remoteDescription = peerConnection.remoteDescription;\n\n                    that._logger.info('Changing bandwidth limit to [%s]', newLimit);\n\n                    var updatedSdp = remoteDescription.sdp.replace(bandwidthAttribute, '');\n\n                    // Add new limit in kbps\n                    updatedSdp = updatedSdp.replace(video, function(match, videoLine, lineEnding, offset, sdp) { // eslint-disable-line no-unused-vars\n                        return [videoLine, lineEnding, 'b=AS:', Math.ceil(newLimit / 1000), lineEnding].join('');\n                    });\n\n                    var updatedRemoteDescription = new phenixRTC.RTCSessionDescription({\n                        type: remoteDescription.type,\n                        sdp: updatedSdp\n                    });\n\n                    peerConnection.setRemoteDescription(updatedRemoteDescription);\n\n                    return {\n                        dispose: function() {\n                            peerConnection.setRemoteDescription(remoteDescription);\n                        }\n                    };\n                },\n\n                getMonitor: function getMonitor() {\n                    return publisherMonitor;\n                },\n\n                monitor: function monitor(options, callback) {\n                    assert.isObject(options, 'options');\n                    assert.isFunction(callback, 'callback');\n\n                    var monitor = new PeerConnectionMonitor(streamId, peerConnection, that._logger);\n\n                    options.direction = 'outbound';\n                    options.setNetworkRTT = function(rtt) {\n                        that._networkRTT.setValue(rtt);\n                    };\n                    monitor.start(options, function activeCallback() {\n                        return that._publishers[streamId] === publisher && !state.stopped;\n                    }, function monitorCallback(error, monitorEvent) {\n                        if (error) {\n                            that._logger.warn('[%s] Publisher monitor triggered unrecoverable error [%s]', error);\n                        }\n\n                        that._logger.warn('[%s] Publisher triggered monitor condition for [%s]', streamId, monitorEvent.reasons);\n\n                        return callback(publisher, 'client-side-failure', monitorEvent);\n                    });\n\n                    _.forEach(mediaStream.getTracks(), function(track) {\n                        _.addEventListener(track, 'readystatechange', function() {\n                            if (track.readyState === 'ended') {\n                                that._logger.warn('[%s] Publisher track has failed [%s]', streamId, track);\n\n                                return callback(publisher, 'camera-track-failure', {\n                                    type: track.kind + '-track-ended',\n                                    message: 'Publisher ' + track.kind + ' track has ended in an unrecoverable way. This may require reconfiguring your camera or microphone.'\n                                });\n                            }\n                        });\n                    });\n\n                    publisherMonitor = monitor;\n\n                    return monitor;\n                },\n\n                addBitRateThreshold: function addBitRateThreshold(threshold, callback) {\n                    var bitRateMonitor = new BitRateMonitor('Publisher', publisherMonitor, function getLimit() {\n                        return limit;\n                    });\n\n                    return bitRateMonitor.addThreshold(threshold, callback);\n                },\n\n                setRemoteMediaStreamCallback: function setRemoteMediaStreamCallback(callback) {\n                    assert.isFunction(callback, 'callback');\n\n                    this.remoteMediaStreamCallback = callback;\n\n                    if (remoteMediaStream) {\n                        callback(publisher, remoteMediaStream);\n                    }\n                },\n\n                getOptions: function getOptions() {\n                    return streamOptions;\n                },\n\n                getStats: function getStats(callback) {\n                    assert.isFunction(callback, 'callback');\n\n                    if (!this._lastStats) {\n                        this._lastStats = {};\n                    }\n\n                    var that = this;\n\n                    return phenixRTC.getStats(peerConnection, null, function(stats) {\n                        callback(PeerConnection.convertPeerConnectionStats(stats, that._lastStats));\n                    });\n                },\n\n                networkRTT: that._networkRTT\n            };\n\n            that._publishers[streamId] = publisher;\n\n            callback.call(that, publisher);\n        };\n\n        setupStreamAddedListener.call(that, streamId, state, peerConnection, streamTelemetry, function(mediaStream) {\n            var publisher = that._publishers[streamId];\n\n            remoteMediaStream = mediaStream;\n\n            if (publisher && publisher.remoteMediaStreamCallback) {\n                publisher.remoteMediaStreamCallback(publisher, mediaStream);\n            }\n        }, createOptions);\n        setupIceCandidateListener.call(that, streamId, peerConnection, function onIceCandidate(candidate) {\n            if (that._iceCandidateCallbacks[streamId]) {\n                that._iceCandidateCallbacks[streamId](candidate);\n            }\n        });\n        setupStateListener.call(that, streamId, peerConnection);\n\n        var offerSessionDescription = new phenixRTC.RTCSessionDescription({\n            type: 'offer',\n            sdp: offerSdp\n        });\n        var mediaConstraints = {mandatory: {}};\n\n        if (phenixRTC.browser === 'Chrome' || phenixRTC.browser === 'ReactNative') {\n            mediaConstraints.mandatory.OfferToReceiveVideo = createOptions.receiveVideo === true;\n            mediaConstraints.mandatory.OfferToReceiveAudio = createOptions.receiveAudio === true;\n        } else {\n            mediaConstraints.mandatory.offerToReceiveVideo = createOptions.receiveVideo === true;\n            mediaConstraints.mandatory.offerToReceiveAudio = createOptions.receiveAudio === true;\n        }\n\n        if (typeof phenixRTC.global.Promise === 'function') {\n            return peerConnection.setRemoteDescription(offerSessionDescription)\n                .then(_.bind(onSetRemoteDescriptionSuccess, that, peerConnection))\n                .then(function() {\n                    return peerConnection.createAnswer(mediaConstraints);\n                })\n                .then(_.bind(onCreateAnswerSuccess, that))\n                .then(function(answerSdp) {\n                    return new phenixRTC.global.Promise(function(resolve, reject) {\n                        setRemoteAnswer.call(that, streamId, answerSdp, resolve, reject);\n                    });\n                })\n                .then(function(sessionDescription) {\n                    return peerConnection.setLocalDescription(sessionDescription);\n                })\n                .then(_.bind(onSetLocalDescriptionSuccess, that, peerConnection))\n                .then(function() {\n                    that._logger.info('[%s] Peer connection setup completed', streamId);\n                })\n                .then(createPublisher)\n                .catch(onFailure);\n        }\n\n        that._logger.info('[%s] Using legacy peer connection api to publish', streamId);\n\n        peerConnection.setRemoteDescription(offerSessionDescription, function() {\n            onSetRemoteDescriptionSuccess.call(that, peerConnection);\n\n            peerConnection.createAnswer(function(answerSdp) {\n                onCreateAnswerSuccess.call(that, answerSdp);\n\n                setRemoteAnswer.call(that, streamId, answerSdp, function(sessionDescription) {\n                    peerConnection.setLocalDescription(sessionDescription, function() {\n                        onSetLocalDescriptionSuccess.call(that, peerConnection);\n\n                        that._logger.info('[%s] Peer connection setup completed', streamId);\n\n                        createPublisher();\n                    }, onFailure);\n                }, onFailure);\n            }, onFailure, mediaConstraints);\n        }, onFailure);\n    }\n\n    function createViewerPeerConnection(peerConnectionConfig, streamId, offerSdp, streamTelemetry, callback, createOptions) {\n        if (phenixRTC.browser === 'IE') {\n            throw new Error('Subscribing in real-time not supported on IE');\n        }\n\n        var that = this;\n        var state = {\n            failed: false,\n            stopped: false\n        };\n        var hasCrypto = offerSdp.match(/a=crypto:/i);\n        var hasDataChannel = offerSdp.match(/m=application /i);\n        var peerConnection = new phenixRTC.RTCPeerConnection(peerConnectionConfig, {\n            'optional': [\n                {DtlsSrtpKeyAgreement: !hasCrypto}, {RtpDataChannels: hasDataChannel}\n            ]\n        });\n\n        shimPeerConnectionGetStreams(peerConnection);\n\n        that._peerConnections[streamId] = peerConnection;\n\n        if (phenixRTC.browser === 'Firefox' || phenixRTC.browser === 'Edge') {\n            if (offerSdp.match(/(\\nm=video)/g) && offerSdp.match(/(\\nm=audio)/g)) {\n                var firstSection = /(a=candidate)((.|\\n)*)(?=m=)/g;\n\n                offerSdp = offerSdp.replace(firstSection, offerSdp.match(firstSection) + 'a=end-of-candidates\\n');\n            }\n\n            offerSdp += 'a=end-of-candidates';\n\n            offerSdp = offerSdp.replace(/(\\na=ice-options:trickle)/g, '');\n        }\n\n        if (phenixRTC.browser === 'ReactNative') {\n            offerSdp = sdpUtil.setGroupLineOrderToMatchMediaSectionOrder(offerSdp);\n        }\n\n        var onFailure = function onFailure(status) {\n            if (state.failed) {\n                return;\n            }\n\n            if (status instanceof Error) {\n                that._logger.info('[%s] Failed to setup peer connection', streamId, status);\n\n                status = 'failed';\n            }\n\n            state.failed = true;\n            state.stopped = true;\n\n            delete that._peerConnections[streamId];\n            delete that._mediaStreams[streamId];\n            delete that._iceCandidateCallbacks[streamId];\n\n            closePeerConnection.call(that, streamId, peerConnection, 'failure');\n\n            callback.call(that, undefined, status || 'failed');\n        };\n\n        setupStreamAddedListener.call(that, streamId, state, peerConnection, streamTelemetry, callback, createOptions);\n        setupIceCandidateListener.call(that, streamId, peerConnection, function onIceCandidate(candidate) {\n            if (that._iceCandidateCallbacks[streamId]) {\n                that._iceCandidateCallbacks[streamId](candidate);\n            }\n        });\n        setupStateListener.call(that, streamId, peerConnection);\n\n        var offerSessionDescription = new phenixRTC.RTCSessionDescription({\n            type: 'offer',\n            sdp: offerSdp\n        });\n        var mediaConstraints = {mandatory: {}};\n\n        if (phenixRTC.browser === 'Chrome' || phenixRTC.browser === 'ReactNative') {\n            mediaConstraints.mandatory.OfferToReceiveVideo = createOptions.receiveVideo !== false;\n            mediaConstraints.mandatory.OfferToReceiveAudio = createOptions.receiveAudio !== false;\n        } else {\n            mediaConstraints.mandatory.offerToReceiveVideo = createOptions.receiveVideo !== false;\n            mediaConstraints.mandatory.offerToReceiveAudio = createOptions.receiveAudio !== false;\n        }\n\n        if (typeof phenixRTC.global.Promise === 'function') {\n            return peerConnection.setRemoteDescription(offerSessionDescription)\n                .then(_.bind(onSetRemoteDescriptionSuccess, that, peerConnection))\n                .then(function() {\n                    return peerConnection.createAnswer(mediaConstraints);\n                })\n                .then(_.bind(onCreateAnswerSuccess, that))\n                .then(function(answerSdp) {\n                    return new phenixRTC.global.Promise(function(resolve, reject) {\n                        setRemoteAnswer.call(that, streamId, answerSdp, resolve, reject);\n                    });\n                })\n                .then(function(sessionDescription) {\n                    return peerConnection.setLocalDescription(sessionDescription);\n                })\n                .then(_.bind(onSetLocalDescriptionSuccess, that, peerConnection))\n                .then(function() {\n                    that._logger.info('[%s] Peer connection setup completed', streamId);\n                })\n                .catch(onFailure);\n        }\n\n        that._logger.info('[%s] Using legacy peer connection api to subscribe', streamId);\n\n        peerConnection.setRemoteDescription(offerSessionDescription, function() {\n            onSetRemoteDescriptionSuccess.call(that, peerConnection);\n\n            peerConnection.createAnswer(function(answerSdp) {\n                onCreateAnswerSuccess.call(that, answerSdp);\n\n                setRemoteAnswer.call(that, streamId, answerSdp, function(sessionDescription) {\n                    peerConnection.setLocalDescription(sessionDescription, function() {\n                        onSetLocalDescriptionSuccess.call(that, peerConnection);\n\n                        that._logger.info('[%s] Peer connection setup completed', streamId);\n                    }, onFailure);\n                }, onFailure);\n            }, onFailure, mediaConstraints);\n        }, onFailure);\n    }\n\n    function onSetLocalDescriptionSuccess(peerConnection) {\n        this._logger.debug('Set local description [%s] [%s]', _.get(peerConnection, ['localDescription', 'type']), _.get(peerConnection, ['localDescription', 'sdp']));\n    }\n\n    function onSetRemoteDescriptionSuccess(peerConnection) {\n        this._logger.debug('Set remote description [%s] [%s]', _.get(peerConnection, ['localDescription', 'type']), _.get(peerConnection, ['remoteDescription', 'sdp']));\n    }\n\n    function onCreateAnswerSuccess(answerSdp) {\n        this._logger.info('Created answer [%s]', answerSdp.sdp);\n\n        return answerSdp;\n    }\n\n    function setRemoteAnswer(streamId, answerSdp, setRemoteAnswerCallback, onFailure) {\n        var that = this;\n\n        that._protocol.setAnswerDescription(streamId, answerSdp.sdp, function(error, response) {\n            if (error) {\n                that._logger.error('Failed to set answer description [%s]', error);\n\n                return onFailure();\n            } else if (response.status !== 'ok') {\n                that._logger.warn('Failed to set answer description, status [%s]', response.status);\n\n                return onFailure(response.status);\n            }\n\n            if (response && _.includes(response.options, 'ice-candidates')) {\n                that._iceCandidateCallbacks[streamId] = _.bind(onIceCandidate, that, streamId);\n            }\n\n            var localSdp = response.sessionDescription.sdp;\n\n            if (FeatureDetector.isIOS()) {\n                var version = _.get(FeatureDetector.getIOSVersion(), ['major']);\n\n                that._logger.info('iOS Version is [%s]', version);\n\n                if (version < 11) {\n                    localSdp = localSdp.replace('BUNDLE audio video', 'BUNDLE video audio'); // Without this only video-only streams work on iOS 10\n                }\n            }\n\n            var sessionDescription = new phenixRTC.RTCSessionDescription({\n                type: 'answer',\n                sdp: localSdp\n            });\n\n            setRemoteAnswerCallback(sessionDescription);\n        });\n    }\n\n    function onIceCandidate(streamId, candidate) {\n        var that = this;\n        var iceCandidates = this._pendingIceCandidates[streamId];\n\n        if (!iceCandidates) {\n            iceCandidates = this._pendingIceCandidates[streamId] = [];\n        }\n\n        if (candidate && _.get(candidate, ['candidate'])) {\n            iceCandidates.push(candidate);\n        } else {\n            if (that._addIceCandidatesTimeoutScheduled[streamId]) {\n                that._logger.debug('[%s] Dismissing scheduled batch for adding ICE candidates. Sending candidates immediately because there are no more candidates.', streamId);\n                clearTimeout(that._addIceCandidatesTimeoutScheduled[streamId]);\n            }\n\n            submitIceCandidates.call(that, streamId, ['completed']);\n\n            delete this._pendingIceCandidates[streamId];\n            delete this._addIceCandidatesTimeoutScheduled[streamId];\n        }\n\n        if (this._addIceCandidatesTimeoutScheduled[streamId]) {\n            that._logger.debug('[%s] Using existing batch for adding ICE candidates', streamId);\n\n            return;\n        }\n\n        this._addIceCandidatesTimeoutScheduled[streamId] = setTimeout(function() {\n            submitIceCandidates.call(that, streamId, []);\n\n            delete that._addIceCandidatesTimeoutScheduled[streamId];\n        }, accumulateIceCandidatesDuration);\n\n        this._disposables.add(new disposable.Disposable(function() {\n            if (that._addIceCandidatesTimeoutScheduled[streamId]) {\n                clearTimeout(that._addIceCandidatesTimeoutScheduled[streamId]);\n            }\n\n            delete that._pendingIceCandidates[streamId];\n            delete that._addIceCandidatesTimeoutScheduled[streamId];\n        }));\n    }\n\n    function submitIceCandidates(streamId, options) {\n        var iceCandidates = this._pendingIceCandidates[streamId] || [];\n\n        if (iceCandidates.length === 0 && options.length === 0) {\n            return;\n        }\n\n        var that = this;\n\n        delete that._pendingIceCandidates[streamId];\n\n        this._logger.info('[%s] Adding [%s] ICE Candidates with Options [%s]', streamId, iceCandidates.length, options);\n\n        this._protocol.addIceCandidates(streamId, iceCandidates, options, function(error, response) {\n            if (error) {\n                return that._logger.error('Failed to add ICE candidate [%s]', error);\n            } else if (response.status !== 'ok') {\n                return that._logger.warn('Failed to add ICE candidate, status [%s]', response.status);\n            }\n\n            if (_.includes(response.options, 'cancel')) {\n                delete that._iceCandidateCallbacks[streamId];\n            }\n        });\n    }\n\n    function createChunkedOrRtmpViewer(streamId, offerSdp, streamTelemetry, callback, options) {\n        var that = this;\n\n        var rtmpQuery = /a=x-rtmp:(rtmp:\\/\\/[^\\n]*)/m;\n        var rtmpMatch = offerSdp.match(rtmpQuery);\n        var dashMatch = offerSdp.match(/a=x-playlist:([^\\n]*[.]mpd\\??[^\\s]*)/m);\n        var hlsMatch = offerSdp.match(/a=x-playlist:([^\\n]*[.]m3u8\\??[^\\s]*)/m);\n        var manifestUrl = _.get(dashMatch, [1], '');\n        var playlistUrl = _.get(hlsMatch, [1], '');\n        var dashManifestOffered = dashMatch && dashMatch.length === 2;\n        var hlsPlaylistOffered = hlsMatch && hlsMatch.length === 2;\n        var rtmpOffered = !!rtmpMatch;\n        var publisherCapabilities = [];\n\n        if (dashManifestOffered || hlsPlaylistOffered) {\n            publisherCapabilities.push('streaming');\n        }\n\n        if (rtmpOffered) {\n            publisherCapabilities.push('rtmp');\n        }\n\n        var preferredFeature = this._featureDetector.getPreferredFeatureFromPublisherCapabilities(publisherCapabilities, true);\n\n        if (this._streamingSourceMapping) {\n            manifestUrl = manifestUrl.replace(this._streamingSourceMapping.patternToReplace, this._streamingSourceMapping.replacement);\n            playlistUrl = playlistUrl.replace(this._streamingSourceMapping.patternToReplace, this._streamingSourceMapping.replacement);\n        }\n\n        switch (preferredFeature) {\n        case streamEnums.types.rtmp.name:\n            var rtmpUris = [];\n            var env = environment.parseEnvFromPcastBaseUri(this._baseUri);\n\n            this._logger.info('Selecting flash playback for rtmp.');\n\n            while (rtmpMatch) {\n                var rtmpUriAndAttributes = _.get(rtmpMatch, [1], '');\n                var rtmpUri = _.get(rtmpUriAndAttributes.match(/(rtmp:\\/\\/[^\\n\\s]*)/), [0]);\n                var bitrate = _.get(rtmpUriAndAttributes.match(/bitrate=([^\\n\\s;]*)/), [1]);\n                var resolution = _.get(rtmpUriAndAttributes.match(/resolution=([^\\n\\s;]*)/), [1]);\n\n                offerSdp = offerSdp.replace(rtmpUriAndAttributes, '');\n\n                if (rtmpUri) {\n                    rtmpUris.push({\n                        uri: rtmpUri,\n                        bitrate: bitrate,\n                        resolution: resolution\n                    });\n                }\n\n                rtmpMatch = offerSdp.match(rtmpQuery);\n            }\n\n            return createLiveViewerOfKind.call(that, streamId, rtmpUris, streamEnums.types.rtmp.name, streamTelemetry, callback, _.assign({env: env}, this._rtmpOptions, options));\n        case streamEnums.types.dash.name:\n            this._logger.info('Selecting dash playback for live stream.');\n\n            options.isDrmProtectedContent = /[?&]drmToken=([^&]*)/.test(manifestUrl) || /x-widevine-service-certificate/.test(offerSdp);\n\n            if (options.isDrmProtectedContent) {\n                options.widevineServiceCertificateUrl = offerSdp.match(/a=x-widevine-service-certificate:([^\\n][^\\s]*)/m)[1];\n                options.playreadyLicenseUrl = offerSdp.match(/a=x-playready-license-url:([^\\n][^\\s]*)/m)[1];\n            }\n\n            return createLiveViewerOfKind.call(that, streamId, manifestUrl, streamEnums.types.dash.name, streamTelemetry, callback, options);\n        case streamEnums.types.hls.name:\n            this._logger.info('Selecting hls playback for live stream.');\n\n            options.isDrmProtectedContent = /[?&]drmToken=([^&]*)/.test(playlistUrl);\n\n            if (options.hlsTargetDuration) {\n                assert.isNumber(options.hlsTargetDuration, 'options.hlsTargetDuration');\n\n                playlistUrl = playlistUrl + (playlistUrl.indexOf('?') > -1 ? '&' : '?') + 'targetDuration=' + options.hlsTargetDuration;\n            }\n\n            return createLiveViewerOfKind.call(that, streamId, playlistUrl, streamEnums.types.hls.name, streamTelemetry, callback, _.assign({preferNative: FeatureDetector.shouldUseNativeHls}, options));\n        default:\n            break;\n        }\n\n        that._logger.warn('[%s] Device does not support [%s] playback. Creating live viewer stream failed.', streamId, FeatureDetector.mapPCastCapabilitiesToFeatures(publisherCapabilities));\n\n        return callback.call(that, undefined, 'failed');\n    }\n\n    function createLiveViewerOfKind(streamId, uri, kind, streamTelemetry, callback, options) {\n        var that = this;\n        var pending = 0;\n        var shaka = null;\n        var webPlayer = null;\n\n        if (!this._shakaLoader && !this._webPlayerLoader) {\n            that._logger.warn('[%s] No player available for [%s] and uri [%s]. Please provide a loader via options.', streamId, kind, uri);\n\n            that._protocol.destroyStream(streamId, 'unsupported-features', function(error, response) {\n                if (error) {\n                    that._logger.error('[%s] failed to destroy stream with unsupported features, [%s]', streamId, error);\n\n                    return;\n                } else if (response.status !== 'ok') {\n                    that._logger.warn('[%s] failed to destroy stream with unsupported features, status [%s]', streamId, response.status);\n\n                    return;\n                }\n            });\n\n            return callback.call(that, undefined, 'unsupported-features');\n        }\n\n        if (this._shakaLoader) {\n            pending++;\n        }\n\n        if (this._webPlayerLoader) {\n            pending++;\n        }\n\n        var loaded = function() {\n            if (!shaka && !webPlayer) {\n                that._logger.warn('[%s] No player available for [%s] and uri [%s]. Please make sure the loader properly provides the player.', streamId, kind, uri);\n\n                return callback.call(that, undefined, 'unsupported-features');\n            }\n\n            var liveStream = new PhenixLiveStream(kind, streamId, uri, streamTelemetry, options, shaka, webPlayer, that._logger);\n            var liveStreamDecorator = new StreamWrapper(kind, liveStream, that._logger);\n\n            var onPlayerError = function onPlayerError(source, event) {\n                that._logger.warn('Phenix Live Stream Player Error [%s] [%s]', source, event);\n\n                liveStreamDecorator.streamErrorCallback(source, event);\n            };\n\n            var onStop = function onStop(reason) {\n                if (!that._protocol) {\n                    return that._logger.warn('Unable to destroy stream [%s]', streamId);\n                }\n\n                that._protocol.destroyStream(streamId, reason || '', function(error, response) {\n                    if (error) {\n                        that._logger.error('[%s] failed to destroy stream, [%s]', streamId, error);\n\n                        return;\n                    } else if (response.status !== 'ok') {\n                        that._logger.warn('[%s] failed to destroy stream, status [%s]', streamId, response.status);\n\n                        return;\n                    }\n                });\n            };\n\n            streamTelemetry.setProperty('kind', kind);\n\n            liveStreamDecorator.on(streamEnums.streamEvents.playerError.name, onPlayerError);\n            liveStreamDecorator.on(streamEnums.streamEvents.stopped.name, onStop);\n\n            that._mediaStreams[streamId] = liveStreamDecorator;\n\n            callback.call(that, liveStreamDecorator.getPhenixMediaStream());\n        };\n\n        if (this._shakaLoader) {\n            this._shakaLoader(function(s) {\n                shaka = s;\n                pending--;\n\n                if (pending === 0) {\n                    return loaded();\n                }\n            });\n        }\n\n        if (this._webPlayerLoader) {\n            this._webPlayerLoader(function(w) {\n                webPlayer = w;\n                pending--;\n\n                if (pending === 0) {\n                    return loaded();\n                }\n            });\n        }\n\n        if (pending === 0) {\n            return loaded();\n        }\n    }\n\n    function transitionToStatus(newStatus, reason, suppressCallback) {\n        var oldStatus = this.getStatus();\n\n        if (oldStatus !== newStatus && !(isOfflineStatus(oldStatus) && newStatus === 'offline')) {\n            this._observableStatus.setValue(newStatus);\n\n            var protocol = this.getProtocol();\n            var sessionId = protocol ? protocol.getSessionId() : '';\n            this._logger.debug('[%s] Transition from [%s] to [%s] with reason [%s]', sessionId, oldStatus, newStatus, reason);\n\n            if (suppressCallback) {\n                return;\n            }\n\n            switch (newStatus) {\n            case 'connecting':\n            case 'reconnecting':\n            case 'reconnected':\n                break;\n            case 'critical-network-issue':\n            case 'unauthorized':\n            case 'reconnect-failed':\n            case 'offline':\n                return this._offlineCallback.call(this);\n            case 'online':\n                return this._onlineCallback.call(this);\n            default:\n                break;\n            }\n        }\n    }\n\n    function isOfflineStatus(status) {\n        return status === 'critical-network-issue' || status === 'offline';\n    }\n\n    function closePeerConnection(streamId, peerConnection, reason) {\n        if (peerConnection.signalingState === 'closed' || peerConnection.__closing) {\n            this._logger.debug('[%s] Peer connection is already closed [%s]', streamId, reason);\n\n            return;\n        }\n\n        this._logger.debug('[%s] close peer connection [%s]', streamId, reason);\n\n        peerConnection.close();\n        peerConnection.__closing = true;\n    }\n\n    function handleForeground() {\n        if (this._treatBackgroundAsOffline || this._reAuthenticateOnForeground) {\n            reconnected.call(this, 'entered-foreground');\n        }\n    }\n\n    function handleBackground() {\n        if (this._treatBackgroundAsOffline) {\n            transitionToStatus.call(this, 'offline', 'entered-background');\n        }\n    }\n\n    function parseProtobufMessage(message) {\n        if (!message) {\n            return message;\n        }\n\n        var parsedMessage = _.isArray(message) ? [] : {};\n        var processIndexOrKey = _.bind(removeNullValuesAndParseEnums, null, parsedMessage);\n\n        if (_.isArray(message)) {\n            _.forEach(message, processIndexOrKey);\n        } else {\n            _.forOwn(message, processIndexOrKey);\n        }\n\n        return parsedMessage;\n    }\n\n    function removeNullValuesAndParseEnums(parsedMessage, value, key) {\n        if (value === null) {\n            return;\n        }\n\n        if (_.isObject(value) || _.isArray(value)) {\n            return parsedMessage[key] = parseProtobufMessage(value);\n        }\n\n        if (!_.isString(value) || !_.isString(key)) {\n            return parsedMessage[key] = value;\n        }\n\n        var prefixedByKey = _.startsWith(value.toLowerCase(), key.toLowerCase());\n        var valueParsedWithoutKey = prefixedByKey ? value.substring(key.length, value.length).toLowerCase() : value;\n\n        parsedMessage[key] = valueParsedWithoutKey;\n    }\n\n    function applyVendorSpecificLogic(config) {\n        switch (phenixRTC.browser) {\n        case 'Firefox':\n            // Firefox doesn't support TURN with TCP/TLS https://bugzilla.mozilla.org/show_bug.cgi?id=1056934\n            removeTurnsServers(config);\n\n            break;\n        case 'Edge':\n            // Edge doesn't support TURN with TCP\n            forceTurnUdp(config);\n\n            break;\n        default:\n            break;\n        }\n\n        return config;\n    }\n\n    function removeTurnsServers(config) {\n        if (!config) {\n            return config;\n        }\n\n        _.forEach(config.iceServers, function(server) {\n            server.urls = _.filter(server.urls, function(url) {\n                return !_.startsWith(url, 'turns');\n            });\n        });\n\n        return config;\n    }\n\n    function forceTurnUdp(config) {\n        if (!config) {\n            return config;\n        }\n\n        _.forEach(config.iceServers, function(server) {\n            server.urls = _.map(server.urls, function(url) {\n                return url.replace('transport=tcp', 'transport=udp');\n            });\n        });\n\n        return config;\n    }\n\n    // Shim required. Webrtc adapter successfully shims but breaks Edge.\n    var shimPeerConnectionGetStreams = function(peerConnection) {\n        if (!_.isUndefined(peerConnection.onaddstream)) {\n            return;\n        }\n\n        var remoteStreams = [];\n        var localStreams = [];\n\n        _.addEventListener(peerConnection, 'track', function(event) {\n            _.forEach(event.streams, function(stream) {\n                if (!_.includes(remoteStreams, stream)) {\n                    remoteStreams.push(stream);\n                }\n            });\n        });\n\n        peerConnection.getRemoteStreams = function getRemoteStreams() {\n            return remoteStreams;\n        };\n\n        peerConnection.getLocalStreams = function getLocalStreams() {\n            return localStreams;\n        };\n\n        peerConnection.addStream = function addStream(stream) {\n            if (!_.includes(localStreams, stream)) {\n                localStreams.push(stream);\n            }\n\n            _.forEach(stream.getTracks(), function(track) {\n                peerConnection.addTrack(track, stream);\n            });\n        };\n    };\n\n    return PCast;\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__22__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var telemetryProto = {\n        \"package\": \"telemetry\",\n        \"messages\": [\n            {\n                \"name\": \"LogData\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"LogLevel\",\n                        \"name\": \"level\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"timestamp\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"category\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"message\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"source\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"fullQualifiedName\",\n                        \"id\": 11\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"userId\",\n                        \"id\": 7\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"environment\",\n                        \"id\": 8\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"version\",\n                        \"id\": 9\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"float\",\n                        \"name\": \"runtime\",\n                        \"id\": 10\n                    }\n                ]\n            },\n            {\n                \"name\": \"StoreLogRecords\",\n                \"fields\": [\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"LogData\",\n                        \"name\": \"records\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"StoreLogRecordsResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"storedRecords\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"MetricValue\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"string\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"float\",\n                        \"name\": \"float\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint64\",\n                        \"name\": \"uint64\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"int64\",\n                        \"name\": \"int64\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"bool\",\n                        \"name\": \"boolean\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"timestamp\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"MetricData\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"timestamp\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"source\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"resource\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"kind\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Metric\",\n                        \"name\": \"metric\",\n                        \"id\": 7\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"MetricValue\",\n                        \"name\": \"value\",\n                        \"id\": 8\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"MetricValue\",\n                        \"name\": \"previousValue\",\n                        \"id\": 9\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint64\",\n                        \"name\": \"elapsed\",\n                        \"id\": 10\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"fullQualifiedName\",\n                        \"id\": 11\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"environment\",\n                        \"id\": 12\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"version\",\n                        \"id\": 13\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"tool\",\n                        \"id\": 14\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"toolVersion\",\n                        \"id\": 15\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"float\",\n                        \"name\": \"runtime\",\n                        \"id\": 16\n                    }\n                ]\n            },\n            {\n                \"name\": \"SubmitMetricRecords\",\n                \"fields\": [\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"MetricData\",\n                        \"name\": \"records\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"SubmitMetricRecordsResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"storedRecords\",\n                        \"id\": 2\n                    }\n                ]\n            }\n        ],\n        \"enums\": [\n            {\n                \"name\": \"LogLevel\",\n                \"values\": [\n                    {\n                        \"name\": \"Trace\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"Debug\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"Info\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"Warn\",\n                        \"id\": 3\n                    },\n                    {\n                        \"name\": \"Error\",\n                        \"id\": 4\n                    },\n                    {\n                        \"name\": \"Fatal\",\n                        \"id\": 5\n                    }\n                ]\n            },\n            {\n                \"name\": \"Metric\",\n                \"values\": [\n                    {\n                        \"name\": \"RoundTripTime\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"DownlinkThroughputCapacity\",\n                        \"id\": 26\n                    },\n                    {\n                        \"name\": \"Initialized\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"Provisioned\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"SetupCompleted\",\n                        \"id\": 3\n                    },\n                    {\n                        \"name\": \"Offset\",\n                        \"id\": 4\n                    },\n                    {\n                        \"name\": \"TimeToFirstFrame\",\n                        \"id\": 5\n                    },\n                    {\n                        \"name\": \"Playing\",\n                        \"id\": 6\n                    },\n                    {\n                        \"name\": \"Stalled\",\n                        \"id\": 7\n                    },\n                    {\n                        \"name\": \"Buffering\",\n                        \"id\": 8\n                    },\n                    {\n                        \"name\": \"Seeking\",\n                        \"id\": 22\n                    },\n                    {\n                        \"name\": \"Stopped\",\n                        \"id\": 9\n                    },\n                    {\n                        \"name\": \"BitRateAdaptation\",\n                        \"id\": 10\n                    },\n                    {\n                        \"name\": \"ResolutionChanged\",\n                        \"id\": 11\n                    },\n                    {\n                        \"name\": \"DisplayResolutionChanged\",\n                        \"id\": 23\n                    },\n                    {\n                        \"name\": \"VideoBitRate\",\n                        \"id\": 28\n                    },\n                    {\n                        \"name\": \"AudioBitRate\",\n                        \"id\": 29\n                    },\n                    {\n                        \"name\": \"FrameRateChanged\",\n                        \"id\": 12\n                    },\n                    {\n                        \"name\": \"FramesDropped\",\n                        \"id\": 13\n                    },\n                    {\n                        \"name\": \"PacketsLost\",\n                        \"id\": 14\n                    },\n                    {\n                        \"name\": \"PictureLost\",\n                        \"id\": 15\n                    },\n                    {\n                        \"name\": \"PlayoutDelayChanged\",\n                        \"id\": 16\n                    },\n                    {\n                        \"name\": \"CodecChanged\",\n                        \"id\": 17\n                    },\n                    {\n                        \"name\": \"PlayerEvent\",\n                        \"id\": 21\n                    },\n                    {\n                        \"name\": \"MetricDropped\",\n                        \"id\": 18\n                    },\n                    {\n                        \"name\": \"NetworkOffline\",\n                        \"id\": 19\n                    },\n                    {\n                        \"name\": \"NetworkOnline\",\n                        \"id\": 20\n                    },\n                    {\n                        \"name\": \"NetworkType\",\n                        \"id\": 27\n                    },\n                    {\n                        \"name\": \"ApplicationForeground\",\n                        \"id\": 24\n                    },\n                    {\n                        \"name\": \"ApplicationBackground\",\n                        \"id\": 25\n                    }\n                ]\n            }\n        ]\n    };\n\n    return telemetryProto;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-rtc'\n], function(rtc) {\n    'use strict';\n\n    function AudioContext() {\n        this.init();\n    }\n\n    AudioContext.prototype.init = function init() {\n        if (!rtc.global.AudioContext && !rtc.global.webkitAudioContext) {\n            throw new Error('Browser does not support AudioContext');\n        }\n\n        this._audioContext = new (rtc.global.AudioContext || rtc.global.webkitAudioContext)();\n    };\n\n    AudioContext.prototype.getNativeAudioContext = function getNativeAudioContext() {\n        return this._audioContext;\n    };\n\n    AudioContext.prototype.toString = function toString() {\n        return 'AudioContext';\n    };\n\n    return AudioContext;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-rtc',\n    '../sdpUtil',\n    './PeerConnection'\n], function(_, assert, event, phenixRTC, sdpUtil, PeerConnection) {\n    'use strict';\n\n    var defaultMonitoringInterval = 4000;\n    var defaultConditionMonitoringInterval = 1500;\n    var defaultFrameRateThreshold = 2;\n    var defaultAudioBitRateThreshold = 5000;\n    var defaultVideoBitRateThreshold = 1000;\n    var defaultConditionCountForNotificationThreshold = 3;\n    var minMonitoringInterval = 500;\n    var minEdgeMonitoringInterval = 6000;\n    var minEdgeConditionCountForNotification = 2;\n\n    function PeerConnectionMonitor(name, peerConnection, logger) {\n        assert.isString(name, 'name');\n        assert.isObject(peerConnection, 'peerConnection');\n        assert.isObject(logger, 'logger');\n\n        this._name = name;\n        this._peerConnection = peerConnection;\n        this._logger = logger;\n        this._lastStats = {};\n    }\n\n    PeerConnectionMonitor.prototype.start = function(options, activeCallback, monitorCallback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(activeCallback, 'activeCallback');\n        assert.isFunction(monitorCallback, 'monitorCallback');\n\n        if (options.direction !== 'inbound' && options.direction !== 'outbound') {\n            throw new Error('Invalid monitoring direction');\n        }\n\n        var monitoringEnabled = Object.prototype.hasOwnProperty.call(options, 'monitoringInterval') ? options.monitoringInterval > 0 : true;\n\n        if (!monitoringEnabled) {\n            this._logger.info('[%s] Monitoring is disabled', name);\n\n            return;\n        }\n\n        this._frameRateFailureThreshold = options.frameRateThreshold || defaultFrameRateThreshold;\n        this._videoBitRateFailureThreshold = options.videoBitRateThreshold || defaultVideoBitRateThreshold;\n        this._audioBitRateFailureThreshold = options.audioBitRateThreshold || defaultAudioBitRateThreshold;\n        this._conditionCountForNotificationThreshold = options.conditionCountForNotificationThreshold || defaultConditionCountForNotificationThreshold;\n        this._monitoringInterval = Math.max(minMonitoringInterval, options.monitoringInterval || defaultMonitoringInterval);\n        this._conditionMonitoringInterval = Math.max(minMonitoringInterval, options.conditionMonitoringInterval || defaultConditionMonitoringInterval);\n        this._monitorFrameRate = Object.prototype.hasOwnProperty.call(options, 'monitorFrameRate') ? options.monitorFrameRate : true;\n        this._monitorBitRate = Object.prototype.hasOwnProperty.call(options, 'monitorBitRate') ? options.monitorBitRate : true;\n        this._monitorState = Object.prototype.hasOwnProperty.call(options, 'monitorState') ? options.monitorState : true;\n        this._pausedTracks = [];\n        this._calculatedMetricsEvent = new event.Event();\n\n        if (phenixRTC.browser === 'Edge') {\n            var conditionMaxDuration = this._conditionMonitoringInterval * this._conditionCountForNotificationThreshold;\n\n            this._monitoringInterval = Math.max(this._monitoringInterval, minEdgeMonitoringInterval);\n            this._conditionMonitoringInterval = Math.max(this._conditionMonitoringInterval, minEdgeMonitoringInterval);\n            this._conditionCountForNotificationThreshold = Math.max(Math.ceil(conditionMaxDuration / this._monitoringInterval), minEdgeConditionCountForNotification);\n\n            this._logger.info('Using modified options for optimal monitoring of PeerConnection on [Edge]. Monitor Interval [%s], Condition Monitor Interval [%s], Condition Count For Notification [%s]',\n                this._monitoringInterval, this._conditionMonitoringInterval, this._conditionCountForNotificationThreshold);\n        }\n\n        return monitorPeerConnection.call(this, this._name, this._peerConnection, options, activeCallback, monitorCallback);\n    };\n\n    PeerConnectionMonitor.prototype.setMonitorTrackState = function(track, state) {\n        assert.isObject(track, 'track');\n        assert.isBoolean(state, 'state');\n\n        try {\n            var peerConnectionTracks = getAllTracks.call(this, this._peerConnection);\n            var foundTrack = !!_.find(peerConnectionTracks, function(pcTrack) {\n                return pcTrack.id === track.id;\n            });\n\n            if (!foundTrack) {\n                return this._logger.warn('[%s] Unable to find track [%s] [%s] in peer connection', this._name, track.kind, track.id);\n            }\n        } catch (e) {\n            if (phenixRTC.browser === 'Firefox' && e.message === 'InvalidStateError: Peer connection is closed') {\n                this._logger.debug('Failed to verify monitor track due to closed peer connection');\n            } else {\n                this._logger.warn('Failed to verify monitor track due to [%s]', e.message);\n            }\n        }\n\n        if (!state) {\n            this._logger.info('[%s] Pausing monitoring of track [%s] [%s]', this._name, track.kind, track.id);\n\n            return this._pausedTracks.push(track);\n        }\n\n        var pausedTrackLength = this._pausedTracks.length;\n\n        this._pausedTracks = _.filter(this._pausedTracks, function(pausedTrack) {\n            return pausedTrack.id !== track.id;\n        });\n\n        if (pausedTrackLength !== this._pausedTracks.length) {\n            this._logger.info('[%s] Starting monitoring of track [%s] [%s] after it was paused', this._name, track.kind, track.id);\n        }\n    };\n\n    PeerConnectionMonitor.prototype.on = function(eventName, listener) {\n        assert.isStringNotEmpty(eventName, 'eventName');\n        assert.isFunction(listener, 'listener');\n\n        switch (eventName) {\n        case 'calculatedmetrics':\n            return this._calculatedMetricsEvent.listen(listener);\n        default:\n            throw new Error('Unsupported event ' + eventName);\n        }\n    };\n\n    PeerConnectionMonitor.prototype.toString = function() {\n        return 'PeerConnectionMonitor[' + this._name + ']';\n    };\n\n    function monitorPeerConnection(name, peerConnection, options, activeCallback, monitorCallback) {\n        var that = this;\n        var conditionCount = 0;\n        var frameRate = undefined;\n        var videoBitRate = undefined;\n        var audioBitRate = undefined;\n\n        function nextCheck() {\n            var selector = null;\n\n            getStats.call(that, peerConnection, options, selector, activeCallback, function successCallback(report) {\n                var hasFrameRate = false;\n                var hasVideoBitRate = false;\n                var hasAudioBitRate = false;\n\n                if (!activeCallback()) {\n                    return that._logger.info('[%s] Finished monitoring of peer connection', name);\n                }\n\n                function eachStats(stats) {\n                    if (options.direction === 'outbound' && stats.direction === 'upload') {\n                        switch (stats.mediaType) {\n                        case 'video':\n                            that._logger.debug('[%s] [%s] [%s] [%s] with RTT [%s], bitrate [%s], dropped frames [%s], frame rate [%s] and average encoding time [%s] ms (CPU limited=[%s])',\n                                name, options.direction, stats.mediaType, stats.ssrc, stats.rtt, stats.bitrateMean, stats.droppedFrames, stats.framerateMean, stats.avgEncode, stats.cpuLimitedResolution);\n\n                            frameRate = stats.framerateMean;\n                            videoBitRate = stats.uploadRate ? stats.uploadRate * 1000 : stats.uploadRate;\n                            hasFrameRate = true;\n                            hasVideoBitRate = true;\n\n                            if (options.setNetworkRTT) {\n                                options.setNetworkRTT(stats.rtt);\n                            }\n\n                            if (phenixRTC.browser === 'Edge') {\n                                hasFrameRate = false;\n                            }\n\n                            break;\n                        case 'audio':\n                            that._logger.debug('[%s] [%s] [%s] [%s] with RTT [%s], jitter [%s] and audio input level [%s]',\n                                name, options.direction, stats.mediaType, stats.ssrc, stats.rtt, stats.jitter, stats.audioInputLevel);\n                            hasAudioBitRate = true;\n                            audioBitRate = stats.uploadRate ? stats.uploadRate * 1000 : stats.uploadRate;\n\n                            if (options.setNetworkRTT) {\n                                options.setNetworkRTT(stats.rtt);\n                            }\n\n                            break;\n                        default:\n                            break;\n                        }\n                    }\n\n                    if (options.direction === 'inbound' && stats.direction === 'download') {\n                        switch (stats.mediaType) {\n                        case 'video':\n                            that._logger.debug('[%s] [%s] [%s] [%s] with framerate [%s], current delay [%s] ms and target delay [%s] ms',\n                                name, options.direction, stats.mediaType, stats.ssrc, stats.framerateMean, stats.currentDelay, stats.targetDelay);\n\n                            // Inbound frame rate may not be calculated correctly\n                            hasFrameRate = true;\n                            frameRate = stats.framerateMean || 0;\n                            hasVideoBitRate = true;\n                            videoBitRate = stats.downloadRate ? stats.downloadRate * 1000 : stats.downloadRate;\n\n                            if (phenixRTC.browser === 'Edge') {\n                                hasFrameRate = false;\n                            }\n\n                            break;\n                        case 'audio':\n                            that._logger.debug('[%s] [%s] [%s] [%s] with jitter [%s], jitter buffer [%s] ms, audio output level [%s], total audio energy [%s] and total samples duration [%s]',\n                                name, options.direction, stats.mediaType, stats.ssrc, stats.jitter, stats.jitterBuffer, stats.audioOutputLevel, stats.totalAudioEnergy, stats.totalSamplesDuration);\n\n                            hasAudioBitRate = true;\n                            audioBitRate = stats.downloadRate ? stats.downloadRate * 1000 : stats.downloadRate;\n\n                            break;\n                        default:\n                            break;\n                        }\n                    }\n                }\n\n                if (!report) {\n                    throw new Error('Report must be a valid PeerConnection.getStats Report');\n                }\n\n                _.forEach(report, eachStats);\n\n                if (_.isUndefined(audioBitRate) && _.isUndefined(videoBitRate)) {\n                    return setTimeout(nextCheck, that._monitoringInterval); // First measurement\n                }\n\n                var hasActiveAudio = sdpUtil.hasActiveAudio(peerConnection);\n                var hasActiveVideo = sdpUtil.hasActiveVideo(peerConnection);\n\n                if (hasVideoBitRate && videoBitRate === 0 || hasAudioBitRate && audioBitRate === 0 || hasFrameRate && frameRate === 0) {\n                    hasVideoBitRate = hasVideoBitRate && hasActiveVideo;\n                    hasAudioBitRate = hasAudioBitRate && hasActiveAudio;\n                    hasFrameRate = hasFrameRate && hasActiveVideo;\n                }\n\n                if (hasAudioBitRate || hasVideoBitRate || hasFrameRate) {\n                    that._logger.debug('[%s] [%s] Current bit rate is [%s] bps for audio and [%s] bps for video with [%s] FPS',\n                        name, options.direction, Math.ceil(audioBitRate || 0), Math.ceil(videoBitRate || 0), frameRate || '?');\n\n                    if (_.values(that._lastStats).length > 0) {\n                        that._calculatedMetricsEvent.fire([{\n                            videoBitRate: videoBitRate,\n                            audioBitRate: audioBitRate,\n                            frameRate: frameRate\n                        }]);\n                    }\n                }\n\n                var reasons = [];\n\n                if (that._monitorState\n                    && (peerConnection.connectionState === 'closed'\n                        || peerConnection.connectionState === 'disconnected'\n                        || peerConnection.connectionState === 'failed'\n                        || peerConnection.iceConnectionState === 'disconnected'\n                        || peerConnection.iceConnectionState === 'failed')) {\n                    var active = hasActiveAudio && hasActiveVideo;\n                    var tracks = getAllTracks.call(that, peerConnection);\n\n                    if (!active && sdpUtil.hasMediaSectionsInLocalSdp(peerConnection)) {\n                        that._logger.info('[%s] [%s] Finished monitoring of peer connection with [%s] inactive tracks', name, options.direction, tracks.length);\n\n                        return;\n                    }\n\n                    reasons.push('connection');\n                }\n\n                var peerConnectionTracks = options.direction === 'outbound' ?\n                    getLocalTracks.call(this, peerConnection) :\n                    getRemoteTracks.call(this, peerConnection);\n\n                if (that._monitorFrameRate && hasFrameRate && frameRate <= that._frameRateFailureThreshold && !areAllTracksOfTypePaused.call(that, 'video', peerConnectionTracks)) {\n                    reasons.push('frameRate');\n                }\n\n                if (that._monitorBitRate && hasAudioBitRate && audioBitRate <= that._audioBitRateFailureThreshold && !areAllTracksOfTypePaused.call(that, 'audio', peerConnectionTracks)) {\n                    reasons.push('audioBitRate');\n                }\n\n                if (that._monitorBitRate && hasVideoBitRate && videoBitRate <= that._videoBitRateFailureThreshold && !areAllTracksOfTypePaused.call(that, 'video', peerConnectionTracks)) {\n                    reasons.push('videoBitRate');\n                }\n\n                if (videoBitRate === 0 && hasActiveVideo && !areAllTracksOfTypePaused.call(that, 'video', peerConnectionTracks)) {\n                    reasons.push('noVideoData');\n                }\n\n                if (audioBitRate === 0 && hasActiveAudio && !areAllTracksOfTypePaused.call(that, 'audio', peerConnectionTracks)) {\n                    reasons.push('noAudioData');\n                }\n\n                var acknowledgeFailure = function acknowledgeFailure() {\n                    that._logger.info('[%s] [%s] Failure has been acknowledged', name, options.direction);\n\n                    conditionCount = Number.MIN_VALUE;\n\n                    setTimeout(nextCheck, that._monitoringInterval);\n                };\n\n                if (reasons.length > 0) {\n                    conditionCount++;\n                } else {\n                    conditionCount = 0;\n                }\n\n                if (conditionCount >= that._conditionCountForNotificationThreshold) {\n                    var failureMessage = '[' + name + '] [' + options.direction + '] Failure detected with frame rate [' + frameRate + '] FPS,'\n                        + ' audio bit rate [' + audioBitRate + '] bps'\n                        + ', video bit rate [' + videoBitRate + '] bps'\n                        + ', connection state [' + peerConnection.connectionState + '],'\n                        + ' and ice connection state [' + peerConnection.iceConnectionState + ']'\n                    + ' after [' + conditionCount + '] checks';\n                    var monitorEvent = {\n                        type: 'condition',\n                        reasons: reasons,\n                        message: failureMessage,\n                        report: report,\n                        frameRate: frameRate,\n                        videoBitRate: videoBitRate,\n                        audioBitRate: audioBitRate,\n                        acknowledgeFailure: acknowledgeFailure\n                    };\n\n                    if (!monitorCallback(null, monitorEvent)) {\n                        that._logger.info(failureMessage + ': [%s]', report);\n                    } else {\n                        acknowledgeFailure();\n                    }\n                } else {\n                    setTimeout(nextCheck, conditionCount > 0 ? that._conditionMonitoringInterval : that._monitoringInterval);\n                }\n            }, function errorCallback(error) {\n                monitorCallback(error, {\n                    type: 'error',\n                    message: 'Unable to get Connection statistics. Connection may have failed.'\n                });\n            });\n        }\n\n        setTimeout(nextCheck, that._monitoringInterval);\n    }\n\n    function getStats(peerConnection, options, selector, activeCallback, successCallback, errorCallback) {\n        if (!activeCallback()) {\n            return this._logger.info('[%s] Finished monitoring of peer connection', this._name);\n        }\n\n        var that = this;\n\n        phenixRTC.getStats(peerConnection, null, function(response) {\n            var report = PeerConnection.convertPeerConnectionStats(response, that._lastStats);\n\n            report = _.filter(report, function(stats) {\n                return options.direction === 'inbound' && stats.direction === 'download' || options.direction === 'outbound' && stats.direction === 'upload';\n            });\n\n            successCallback(report);\n        }, function(error) {\n            errorCallback(error);\n        });\n    }\n\n    function getAllTracks(peerConnection) {\n        var localTracks = getLocalTracks(peerConnection);\n        var remoteTracks = getRemoteTracks(peerConnection);\n\n        if (localTracks.length !== 0 && remoteTracks.length !== 0) {\n            var result = [];\n\n            _.forEach(localTracks, function(track) {\n                result.push(track);\n            });\n\n            _.forEach(remoteTracks, function(track) {\n                result.push(track);\n            });\n\n            return result;\n        } else if (localTracks.length !== 0) {\n            return localTracks;\n        } else if (remoteTracks.length !== 0) {\n            return remoteTracks;\n        }\n\n        return [];\n    }\n\n    function getLocalTracks(peerConnection) {\n        var tracks = peerConnection.getSenders ? _.map(peerConnection.getSenders(), function(receiver) {\n            return receiver.track;\n        }) : [];\n\n        tracks = _.filter(tracks, function(track) {\n            return !_.isNullOrUndefined(track);\n        });\n\n        if (tracks.length === 0) {\n            var streams = peerConnection.getLocalStreams ? peerConnection.getLocalStreams() : [];\n\n            return _.reduce(streams, function(tracks, stream) {\n                return tracks.concat(stream.getTracks());\n            }, []);\n        }\n\n        return tracks;\n    }\n\n    function getRemoteTracks(peerConnection) {\n        var tracks = peerConnection.getReceivers ? _.map(peerConnection.getReceivers(), function(sender) {\n            return sender.track;\n        }) : [];\n\n        tracks = _.filter(tracks, function(track) {\n            return !_.isNullOrUndefined(track);\n        });\n\n        if (tracks.length === 0) {\n            var streams = peerConnection.getRemoteStreams ? peerConnection.getRemoteStreams() : [];\n\n            return _.reduce(streams, function(tracks, stream) {\n                return tracks.concat(stream.getTracks());\n            }, []);\n        }\n\n        return tracks;\n    }\n\n    function areAllTracksOfTypePaused(kind, peerConnectionTracks) {\n        var pcTracksOfType = _.filter(peerConnectionTracks, function(track) {\n            return track.kind === kind;\n        });\n        var pausedTracksOfType = _.filter(this._pausedTracks, function(track) {\n            return track.kind === kind;\n        });\n\n        return _.reduce(pcTracksOfType, function(areAllPaused, track) {\n            if (!areAllPaused) {\n                return areAllPaused;\n            }\n\n            var isTrackPaused = !!_.find(pausedTracksOfType, function(pcTrack) {\n                return pcTrack.id === track.id;\n            });\n\n            return !track.enabled || isTrackPaused;\n        }, true);\n    }\n\n    return PeerConnectionMonitor;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var h264ProfileIdRegex = /profile-level-id=[^;\\n]*/;\n    var vp8Regex = /vp8/i;\n    var vp9Regex = /vp9/i;\n    var h264Regex = /h264/i;\n    var h265Regex = /h265/i;\n\n    function sdpUtil() {\n\n    }\n\n    sdpUtil.prototype.getH264ProfileIds = function getH264ProfileIds(offerSdp) {\n        assert.isStringNotEmpty(offerSdp, 'offerSdp');\n\n        var h264ProfileIds = [];\n        var h264ProfileIdMatch = offerSdp.match(h264ProfileIdRegex);\n        var restOfOffer = offerSdp;\n\n        while (h264ProfileIdMatch) {\n            var h264ProfileId = _.get(h264ProfileIdMatch, '0', '');\n\n            h264ProfileIds.push(h264ProfileId.split('=')[1]);\n\n            restOfOffer = restOfOffer.substring(h264ProfileIdMatch.index + h264ProfileId.length, offerSdp.length);\n            h264ProfileIdMatch = restOfOffer.match(h264ProfileIdRegex);\n        }\n\n        return h264ProfileIds;\n    };\n\n    sdpUtil.prototype.replaceH264ProfileId = function replaceH264ProfileId(offerSdp, profileIdToReplace, newProfileId) {\n        assert.isStringNotEmpty(offerSdp, 'offerSdp');\n        assert.isStringNotEmpty(newProfileId, 'newProfileId');\n\n        var profileIds = this.getH264ProfileIds(offerSdp);\n\n        if (!_.includes(profileIds, profileIdToReplace)) {\n            return offerSdp;\n        }\n\n        return offerSdp.replace('profile-level-id=' + profileIdToReplace, 'profile-level-id=' + newProfileId);\n    };\n\n    sdpUtil.prototype.getH264ProfileIdWithSameProfileAndEqualToOrHigherLevel = function(profileIds, replaceProfileId) {\n        if (_.includes(profileIds, replaceProfileId)) {\n            return replaceProfileId;\n        }\n\n        var nextProfileId = _.reduce(profileIds, function(selectedProfileId, profileId) {\n            var selectedProfile = parseInt(selectedProfileId.substring(0, 2), 16);\n            var selectedLevel = parseInt(selectedProfileId.substring(4, 6), 16);\n            var profile = parseInt(profileId.substring(0, 2), 16);\n            var level = parseInt(profileId.substring(4, 6), 16);\n\n            // We prefer the profile that we are replacing\n            if (selectedProfile !== profile) {\n                return selectedProfileId;\n            }\n\n            return selectedLevel >= level ? selectedProfileId : profileId;\n        }, replaceProfileId);\n\n        return nextProfileId === replaceProfileId ? null : nextProfileId;\n    };\n\n    sdpUtil.prototype.getH264ProfileIdWithSameOrHigherProfileAndEqualToOrHigherLevel = function(profileIds, replaceProfileId) {\n        var matchingProfile = this.getH264ProfileIdWithSameProfileAndEqualToOrHigherLevel(profileIds, replaceProfileId);\n\n        if (matchingProfile) {\n            return matchingProfile;\n        }\n\n        var nextProfileId = _.reduce(profileIds, function(selectedProfileId, profileId) {\n            var selectedProfile = parseInt(selectedProfileId.substring(0, 2), 16);\n            var selectedLevel = parseInt(selectedProfileId.substring(4, 6), 16);\n            var profile = parseInt(profileId.substring(0, 2), 16);\n            var level = parseInt(profileId.substring(4, 6), 16);\n\n            // We prefer the profile that we are replacing\n            if (selectedProfile < profile) {\n                return profileId;\n            } else if (profile < selectedProfile) {\n                return selectedProfileId;\n            }\n\n            return selectedLevel > level ? selectedProfileId : profileId;\n        }, replaceProfileId);\n\n        return nextProfileId === replaceProfileId ? null : nextProfileId;\n    };\n\n    sdpUtil.prototype.getSupportedCodecs = function getSupportedCodecs(offerSdp) {\n        assert.isStringNotEmpty(offerSdp, 'offerSdp');\n\n        var codecs = [];\n\n        if (vp8Regex.test(offerSdp)) {\n            codecs.push('VP8');\n        }\n\n        if (vp9Regex.test(offerSdp)) {\n            codecs.push('VP9');\n        }\n\n        if (h264Regex.test(offerSdp)) {\n            codecs.push('H264');\n        }\n\n        if (h265Regex.test(offerSdp)) {\n            codecs.push('H265');\n        }\n\n        return codecs;\n    };\n\n    sdpUtil.prototype.hasMediaSectionsInLocalSdp = function hasMediaSectionsInLocalSdp(peerConnection) {\n        var indexOfSection = this.findInSdpSections(peerConnection, function(section) {\n            return _.startsWith(section, 'video') || _.startsWith(section, 'audio');\n        });\n\n        return indexOfSection < 0;\n    };\n\n    sdpUtil.prototype.hasActiveAudio = function hasActiveAudio(peerConnection) {\n        var indexOfActiveVideo = this.findInSdpSections(peerConnection, function(section, index, remoteSections) {\n            if (_.startsWith(section, 'audio')) {\n                return !_.includes(section, 'a=inactive') && !_.includes(remoteSections[index], 'a=inactive');\n            }\n\n            return false;\n        });\n\n        return indexOfActiveVideo < 0;\n    };\n\n    sdpUtil.prototype.hasActiveVideo = function hasActiveVideo(peerConnection) {\n        var indexOfActiveVideo = this.findInSdpSections(peerConnection, function(section, index, remoteSections) {\n            if (_.startsWith(section, 'video')) {\n                return !_.includes(section, 'a=inactive') && !_.includes(remoteSections[index], 'a=inactive');\n            }\n\n            return false;\n        });\n\n        return indexOfActiveVideo < 0;\n    };\n\n    sdpUtil.prototype.findInSdpSections = function findInSdpSections(peerConnection, callback) {\n        var localSections = this.getLocalSdp(peerConnection).split('m=');\n        var remoteSections = this.getRemoteSdp(peerConnection).split('m=');\n\n        if (localSections.length !== remoteSections.length) {\n            return false;\n        }\n\n        return _.findIndex(localSections, function(section, index) {\n            return callback(section, index, remoteSections);\n        });\n    };\n\n    sdpUtil.prototype.getNumberOfActiveSections = function getNumberOfActiveSections(peerConnection) {\n        var sdp = this.getLocalSdp(peerConnection) || this.getRemoteSdp(peerConnection);\n        var sections = sdp.split('m=');\n\n        return _.filter(sections, function(section) {\n            return !_.includes(section, 'a=inactive') && (_.startsWith(section, 'audio') || _.startsWith(section, 'video'));\n        }).length;\n    };\n\n    sdpUtil.prototype.getLocalSdp = function getLocalSdp(peerConnection) {\n        return _.get(peerConnection, ['localDescription', 'sdp'], '');\n    };\n\n    sdpUtil.prototype.getRemoteSdp = function getLocalSdp(peerConnection) {\n        return _.get(peerConnection, ['remoteDescription', 'sdp'], '');\n    };\n\n    sdpUtil.prototype.setGroupLineOrderToMatchMediaSectionOrder = function setGroupLineOrderToMatchMediaSectionOrder(sdp) {\n        var groupLineSegment = sdp.match(/(?=a=group:BUNDLE).*/);\n        var mediaSegmentNamesString = _.get(_.get(groupLineSegment, [0], '').split('a=group:BUNDLE '), [1], '');\n        var mediaSegmentNames = mediaSegmentNamesString.split(' ');\n\n        var sortedMediaSegmentNames = mediaSegmentNames.sort(function(nameA, nameB) {\n            return sdp.indexOf('m=' + nameA) - sdp.indexOf('m=' + nameB);\n        });\n\n        if (sortedMediaSegmentNames.length > 0) {\n            sdp = sdp.replace(mediaSegmentNamesString, sortedMediaSegmentNames.join(' '));\n        }\n\n        return sdp;\n    };\n\n    return new sdpUtil();\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-rtc',\n    './ShakaRenderer',\n    './PhenixPlayerRenderer',\n    './FlashRenderer',\n    './stream.json'\n], function(_, assert, event, rtc, ShakaRenderer, PhenixPlayerRenderer, FlashRenderer, streamEnums) {\n    'use strict';\n\n    function PhenixLiveStream(type, streamId, uri, streamTelemetry, options, shaka, webPlayer, logger) {\n        this._type = type;\n        this._streamId = streamId;\n        this._uri = uri;\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._shaka = shaka;\n        this._webPlayer = webPlayer,\n        this._logger = logger;\n        this._renderers = [];\n        this._dimensionsChangedMonitor = null;\n        this._namedEvents = new event.NamedEvents();\n    }\n\n    PhenixLiveStream.prototype.on = function(name, callback) {\n        this._namedEvents.listen(name, callback);\n    };\n\n    PhenixLiveStream.prototype.createRenderer = function() {\n        var renderer = null;\n\n        switch (this._type) {\n        case streamEnums.types.dash.name:\n            if (this._webPlayer) {\n                renderer = new PhenixPlayerRenderer(this._streamId, this._uri, this._streamTelemetry, this._options, this._webPlayer, this._logger);\n            } else if (this._shaka) {\n                if (!this._shaka.Player.isBrowserSupported()) {\n                    this._logger.warn('[%s] Shaka does not support this browser', this._streamId);\n\n                    throw new Error('Shaka does not support this browser');\n                }\n\n                renderer = new ShakaRenderer(this._streamId, this._uri, this._streamTelemetry, this._options, this._shaka, this._logger);\n            }\n\n            break;\n        case streamEnums.types.hls.name:\n            renderer = new PhenixPlayerRenderer(this._streamId, this._uri, this._streamTelemetry, this._options, this._webPlayer, this._logger);\n\n            break;\n        case streamEnums.types.rtmp.name:\n            renderer = new FlashRenderer(this._streamId, this._uri, this._streamTelemetry, this._options, this._logger);\n\n            break;\n        default:\n            throw new Error('Unsupported Live stream Type ' + this._type);\n        }\n\n        var that = this;\n\n        renderer.on(streamEnums.rendererEvents.error.name, function(type, error) {\n            that._namedEvents.fire(streamEnums.streamEvents.playerError.name, [type, error]);\n        });\n        renderer.on(streamEnums.rendererEvents.ended.name, function(reason) {\n            that._renderers = _.filter(that._renderers, function(storedRenderer) {\n                return storedRenderer !== renderer;\n            });\n\n            if (that._renderers.length === 0) {\n                that._streamTelemetry.stop();\n                that._namedEvents.fire(streamEnums.streamEvents.playerEnded.name, [reason]);\n            }\n        });\n\n        this._renderers.push(renderer);\n\n        return renderer;\n    };\n\n    PhenixLiveStream.prototype.select = function select(trackSelectCallback) { // eslint-disable-line no-unused-vars\n        this._logger.warn('[%s] selection of tracks not supported for [%s] live streams', this._streamId, this._type);\n\n        return this;\n    };\n\n    PhenixLiveStream.prototype.setStreamEndedCallback = function setStreamEndedCallback(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.streamEndedCallback = callback;\n    };\n\n    PhenixLiveStream.prototype.setStreamErrorCallback = function setStreamErrorCallback(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.streamErrorCallback = callback;\n    };\n\n    PhenixLiveStream.prototype.stop = function stop(reason) {\n        if (!this.isActive()) {\n            return;\n        }\n\n        this._logger.info('[%s] stop [live] media stream with reason [%s]', this._streamId, reason);\n\n        this._namedEvents.fire(streamEnums.streamEvents.stopped.name, [reason]);\n\n        this._isStopped = true;\n    };\n\n    PhenixLiveStream.prototype.monitor = function monitor(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n    };\n\n    PhenixLiveStream.prototype.getMonitor = function getMonitor() {\n        return null;\n    };\n\n    PhenixLiveStream.prototype.addBitRateThreshold = function addBitRateThreshold(threshold, callback) {\n        assert.isFunction(callback, 'callback');\n\n        return;\n    };\n\n    PhenixLiveStream.prototype.getStream = function getStream() {\n        this._logger.debug('[%s] [%s] This type of stream has no internal stream object', this._streamId, this._type);\n\n        return null;\n    };\n\n    PhenixLiveStream.prototype.isActive = function isActive() {\n        return !this._isStopped;\n    };\n\n    PhenixLiveStream.prototype.getStreamId = function getStreamId() {\n        return this._streamId;\n    };\n\n    PhenixLiveStream.prototype.getStats = function getStats() {\n        this._logger.debug('[%s] [%s] This type of stream has no stats', this._streamId, this._type);\n\n        return null;\n    };\n\n    PhenixLiveStream.prototype.getRenderer = function getRenderer() {\n        return _.get(this._renderers, [0], null);\n    };\n\n    PhenixLiveStream.canPlaybackType = function canPlaybackType(type) {\n        var deviceSupportsDashPlayback = !!rtc.global.MediaSource;\n        var deviceSupportsHlsPlayback = deviceSupportsDashPlayback || (typeof document === 'object' && document.createElement('video').canPlayType('application/vnd.apple.mpegURL') === 'maybe');\n\n        switch (type) {\n        case streamEnums.types.dash.name:\n            return deviceSupportsDashPlayback;\n        case streamEnums.types.hls.name:\n            return deviceSupportsHlsPlayback;\n        case streamEnums.types.rtmp.name:\n            return FlashRenderer.isSupported();\n        default:\n            return false;\n        }\n    };\n\n    return PhenixLiveStream;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var maximumBitRateDefault = 3; // 3 x target bitrate\n\n    function BitRateMonitor(name, monitor, getLimit) {\n        assert.isStringNotEmpty(name, 'name');\n        assert.isObject(monitor, 'monitor');\n        assert.isFunction(getLimit, 'getLimit');\n\n        this._name = name;\n        this._monitor = monitor;\n        this._getLimit = getLimit || _.noop;\n    }\n\n    BitRateMonitor.prototype.addThreshold = function(threshold, callback) {\n        var thresholds = getThresholdList(threshold);\n        var lastThresholdIndex = null;\n        var that = this;\n\n        return that._monitor.on('calculatedmetrics', function(metrics) {\n            var limit = that._getLimit();\n            var totalBitRate = metrics.videoBitRate + metrics.audioBitRate;\n            var currentClosestThresholdIndex = getClosestThresholdIndexToButNotBelow(thresholds, totalBitRate / limit);\n            var currentRatioThreshold = _.get(thresholds, [currentClosestThresholdIndex]);\n            var currentBitRateThreshold = currentRatioThreshold * limit;\n            var lastRatioThreshold = _.get(thresholds, [lastThresholdIndex], 1);\n            var lastBitRateThreshold = lastRatioThreshold * limit;\n\n            if (limit === 0) {\n                return;\n            }\n\n            if (lastThresholdIndex === null) {\n                return lastThresholdIndex = currentClosestThresholdIndex;\n            }\n\n            if (currentClosestThresholdIndex === lastThresholdIndex) {\n                return;\n            }\n\n            if (currentClosestThresholdIndex < lastThresholdIndex) {\n                callback({\n                    isIncreasing: false,\n                    bitRate: totalBitRate,\n                    currentThreshold: currentBitRateThreshold,\n                    targetBitRate: limit,\n                    index: currentClosestThresholdIndex,\n                    lastIndex: lastThresholdIndex,\n                    message: that._name + ' bit rate is below ' + currentRatioThreshold + ' * ' + limit + ' threshold of ' + currentBitRateThreshold + ' with a bit rate of ' + totalBitRate\n                });\n            } else if (currentClosestThresholdIndex > lastThresholdIndex) {\n                callback({\n                    isIncreasing: true,\n                    bitRate: totalBitRate,\n                    currentThreshold: lastBitRateThreshold,\n                    targetBitRate: limit,\n                    index: currentClosestThresholdIndex,\n                    lastIndex: lastThresholdIndex,\n                    message: that._name + ' bit rate is above ' + lastRatioThreshold + ' * ' + limit + ' threshold of ' + lastBitRateThreshold + ' with a bit rate of ' + totalBitRate\n                });\n            }\n\n            lastThresholdIndex = currentClosestThresholdIndex;\n        });\n    };\n\n    function getClosestThresholdIndexToButNotBelow(thresholds, ratio) {\n        return _.reduce(thresholds, function(closestIndex, threshold, index) {\n            if (closestIndex === null && threshold >= ratio) {\n                return index;\n            }\n\n            if (threshold < thresholds[closestIndex] && threshold >= ratio) {\n                return index;\n            }\n\n            return closestIndex;\n        }, null);\n    }\n\n    function getThresholdList(threshold) {\n        var thresholds = [];\n\n        if (_.isArray(threshold)) {\n            _.forEach(threshold, function(value) {\n                assert.isNumber(value, 'threshold');\n            });\n\n            thresholds = threshold.sort();\n        } else if (_.isObject(threshold)) {\n            assert.isNumber(threshold.levels, 'threshold.levels');\n\n            for (var i = 0; i < threshold.levels; i++) {\n                thresholds.push(i / threshold.levels);\n            }\n        } else {\n            assert.isNumber(threshold, 'threshold');\n\n            thresholds.push(threshold);\n        }\n\n        thresholds.push(maximumBitRateDefault); // Upper bound\n\n        return thresholds;\n    }\n\n    return BitRateMonitor;\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__29__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    '../authentication/AuthenticationService',\n    './Room',\n    './ImmutableRoom',\n    './Member',\n    '../chat/RoomChatService',\n    './room.json',\n    './member.json'\n], function(_, assert, observable, disposable, AuthenticationService, Room, ImmutableRoom, Member, RoomChatService, roomEnums, memberEnums) {\n    'use strict';\n\n    var notInRoomResponse = _.freeze({status: 'not-in-room'});\n    var alreadyInRoomResponse = _.freeze({status: 'already-in-room'});\n    var inAnotherRoomResponse = _.freeze({status: 'in-another-room'});\n\n    function RoomService(pcast) {\n        this._self = new observable.Observable(null);\n        this._activeRoom = new observable.Observable(null);\n        this._cachedRoom = new observable.Observable(null);\n        this._roomChatService = null;\n\n        this._authenticationService = new AuthenticationService(pcast);\n\n        this.setPCast(pcast);\n    }\n\n    RoomService.prototype.setPCast = function setPCast(pcast) {\n        assert.isObject(pcast, 'pcast');\n        assert.isFunction(pcast.getLogger, 'pcast.getLogger');\n        assert.isFunction(pcast.getProtocol, 'pcast.getProtocol');\n\n        if (this._pcast) {\n            this._logger.info('Resetting pcast instance for room service');\n        }\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n        this._protocol = pcast.getProtocol();\n\n        assert.isObject(this._logger, 'this._logger');\n        assert.isObject(this._protocol, 'this._protocol');\n\n        this._authenticationService.setPCast(pcast);\n\n        if (this._roomChatService) {\n            this._roomChatService.setPCast(pcast);\n        }\n\n        if (this._started) {\n            this._disposables.dispose();\n\n            setupSubscriptions.call(this);\n        }\n    };\n\n    RoomService.prototype.start = function start(role, screenName) {\n        if (this._started) {\n            this._logger.warn('RoomService already started.');\n\n            return;\n        }\n\n        assert.isStringNotEmpty(role, 'role');\n        assert.isStringNotEmpty(screenName, 'screenName');\n\n        var myState = memberEnums.states.passive.name;\n        var mySessionId = this._authenticationService.getPCastSessionId();\n        var myScreenName = screenName;\n        var myStreams = [];\n        var myLastUpdate = _.now();\n        var roomService = this;\n\n        var self = new Member(roomService, myState, mySessionId, myScreenName, role, myStreams, myLastUpdate);\n\n        this._self = new observable.Observable(self);\n        this._disposables = new disposable.DisposableList();\n\n        setupSubscriptions.call(this);\n\n        this._started = true;\n\n        return self;\n    };\n\n    RoomService.prototype.getRoomInfo = function getRoomInfo(roomId, alias, callback) {\n        if (roomId) {\n            assert.isStringNotEmpty(roomId, 'roomId');\n        } else {\n            assert.isStringNotEmpty(alias, 'alias');\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        getRoomInfoRequest.call(this, roomId, alias, callback);\n    };\n\n    RoomService.prototype.createRoom = function createRoom(room, callback) {\n        assert.isObject(room, 'room');\n        assert.isStringNotEmpty(room.name, 'room.name');\n        assert.isStringNotEmpty(room.type, 'room.type');\n        assert.isString(room.description, 'room.description');\n        assert.isFunction(callback, 'callback');\n\n        createRoomRequest.call(this, room, callback);\n    };\n\n    RoomService.prototype.enterRoom = function enterRoom(roomId, alias, callback) {\n        if (roomId) {\n            assert.isStringNotEmpty(roomId, 'roomId');\n        } else {\n            assert.isStringNotEmpty(alias, 'alias');\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        enterRoomRequest.call(this, roomId, alias, callback);\n    };\n\n    RoomService.prototype.leaveRoom = function leaveRoom(callback, isForceLeaveRoom) {\n        var that = this;\n\n        return leaveRoomRequest.call(that, callback, isForceLeaveRoom);\n    };\n\n    RoomService.prototype.getChatService = function getChatService() {\n        if (!this._roomChatService && this._activeRoom.getValue()) {\n            this._roomChatService = new RoomChatService(this);\n        }\n\n        return this._roomChatService;\n    };\n\n    RoomService.prototype.getSelf = function getSelf() {\n        return this._self.getValue();\n    };\n\n    RoomService.prototype.getObservableActiveRoom = function getObservableActiveRoom() {\n        return this._activeRoom;\n    };\n\n    RoomService.prototype.updateSelf = function updateSelf(callback) {\n        assert.isFunction(callback, 'callback');\n\n        updateMemberRequest.call(this, this.getSelf(), callback);\n    };\n\n    RoomService.prototype.updateMember = function updateMember(member, callback) {\n        assert.isFunction(callback, 'callback');\n        assert.isObject(member, 'member');\n\n        updateMemberRequest.call(this, member, callback);\n    };\n\n    RoomService.prototype.updateRoom = function updateRoom(callback) {\n        assert.isFunction(callback, 'callback');\n\n        updateRoomRequest.call(this, callback);\n    };\n\n    RoomService.prototype.revertRoomChanges = function revertRoomChanges() {\n        var activeRoom = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n\n        if (!activeRoom || !cachedRoom) {\n            return this._logger.warn('Unable to revert changes to room. Not currently in a room.');\n        }\n\n        activeRoom._update(cachedRoom.toJson());\n    };\n\n    RoomService.prototype.revertMemberChanges = function revertMemberChanges(member) {\n        assert.isObject(member, 'member');\n\n        var cachedMember = findMemberInObservableRoom(member.getSessionId(), this._cachedRoom);\n        var activeMember = findMemberInObservableRoom(member.getSessionId(), this._activeRoom);\n\n        if (!cachedMember || !activeMember) {\n            return this._logger.warn('Unable to revert changes to member. Member is currently not in room.');\n        }\n\n        activeMember._update(cachedMember.toJson());\n    };\n\n    RoomService.prototype.isInRoom = function isInRoom() {\n        return !!this._activeRoom.getValue();\n    };\n\n    RoomService.prototype.toString = function toString() {\n        return 'RoomService';\n    };\n\n    RoomService.prototype.stop = function stop(reason) {\n        var activeRoom = this._activeRoom.getValue();\n        var that = this;\n\n        this._logger.info('Stopping room service with reason [%s]', reason);\n\n        if (activeRoom) {\n            return this.leaveRoom(function(error, response) {\n                if (error) {\n                    that._logger.warn('Failure to stop room service. Unable to leave room', error);\n                }\n\n                if (response && response.status !== 'ok') {\n                    that._logger.warn('Failure to stop room service. Unable to leave room. Status: [%s]', response.status);\n                }\n\n                if (response && response.status === 'ok') {\n                    resetRoomModels.call(that);\n\n                    that._started = false;\n                }\n            });\n        }\n\n        resetRoomModels.call(this);\n\n        that._started = false;\n    };\n\n    function resetRoomModels() {\n        this._self.setValue(null);\n        this._activeRoom.setValue(null);\n        this._cachedRoom.setValue(null);\n        this._roomChatService = null;\n\n        if (this._disposables) {\n            this._disposables.dispose();\n        }\n\n        this._disposables = null;\n    }\n\n    function resetSelf(sessionId) {\n        var self = this._self.getValue().toJson();\n        var roomService = this;\n\n        this._logger.info('Resetting self after sessionId changed to [%s]', sessionId);\n\n        this._self.setValue(new Member(roomService, self.state, sessionId || '', self.screenName, self.role, self.streams, self.lastUpdate));\n    }\n\n    function reenterRoom() {\n        var that = this;\n\n        var activeRoom = that._activeRoom.getValue();\n\n        if (!_.isObject(activeRoom)) {\n            return;\n        }\n\n        var self = that._self.getValue();\n\n        if (!self) {\n            return;\n        }\n\n        var selfSessionId = self.getSessionId();\n\n        if (!selfSessionId) {\n            return;\n        }\n\n        var roomId = activeRoom.getRoomId();\n        var alias = activeRoom.getObservableAlias().getValue();\n\n        that._logger.info('[%s] Re-entering room [%s]', roomId, alias);\n\n        if (that._roomChatService) {\n            that._logger.info('Performing soft reset on room chat service for room [%s]', roomId);\n            that._roomChatService.stop();\n        }\n\n        enterRoomRequest.call(that, roomId, alias, function() {\n            if (that._roomChatService) {\n                that._logger.info('[%s] Refreshing room chat service after re-entering room [%s]', roomId, alias);\n\n                that._roomChatService.start(that._roomChatService.getBatchSize());\n            }\n\n            that._logger.info('[%s] Room [%s] completed reset', roomId, alias);\n        }, {reenter: true});\n    }\n\n    // Handle events\n    function onRoomEvent(event) {\n        assert.isObject(event, 'event');\n        assert.isString(event.roomId, 'event.roomId');\n        assert.isString(event.eventType, 'event.eventType');\n        assert.isArray(event.members, 'event.members');\n\n        _.forEach(event.members, function(member) {\n            assert.isObject(member, 'member');\n        });\n\n        var that = this;\n\n        switch (event.eventType) {\n        case roomEnums.events.memberJoined.name:\n            that._logger.debug('[%s] Member joined [%s]', event.roomId, event.members);\n\n            return onMembersJoinsRoom.call(that, event.roomId, event.members);\n        case roomEnums.events.memberLeft.name:\n            that._logger.debug('[%s] Member left [%s]', event.roomId, event.members);\n\n            return onMembersLeavesRoom.call(that, event.roomId, event.members);\n        case roomEnums.events.memberUpdated.name:\n            that._logger.debug('[%s] Member updated [%s]', event.roomId, event.members);\n\n            return onMembersUpdated.call(that, event.roomId, event.members);\n        case roomEnums.events.roomUpdated.name:\n            that._logger.debug('[%s] Room updated [%s]', event.roomId, event.room);\n\n            return onRoomUpdated.call(that, event.roomId, event.room);\n        case roomEnums.events.roomEnded.name:\n            that._logger.info('[%s] Room ended', event.roomId);\n\n            break;\n        default:\n            that._logger.warn('Unsupported room event [%s]', event.eventType);\n        }\n    }\n\n    function onMembersJoinsRoom(roomId, members) {\n        var room = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n\n        if (!room || room.getRoomId() !== roomId) {\n            return;\n        }\n\n        room._removeMembers(members);\n        room._addMembers(members);\n\n        cachedRoom._removeMembers(members);\n        cachedRoom._addMembers(members);\n\n        var that = this;\n\n        var memberIsSelf = function(member) {\n            return member.sessionId === that.getSelf().getSessionId();\n        };\n\n        var joinedSelf = _.find(members, memberIsSelf);\n        var selfInRoom = false;\n\n        if (joinedSelf) {\n            selfInRoom = replaceSelfInstanceInRoom.call(that, room);\n\n            room._updateMembers([joinedSelf]);\n        }\n\n        this._logger.info('[%s] Room has now [%d] members (Self is present in room [%s])', roomId, room.getObservableMembers().getValue().length, selfInRoom);\n    }\n\n    function onMembersLeavesRoom(roomId, members) {\n        var room = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n\n        if (!room || room.getRoomId() !== roomId) {\n            return;\n        }\n\n        var that = this;\n\n        var memberIsSelf = function(member) {\n            return member.sessionId === that.getSelf().getSessionId();\n        };\n\n        var leftSelf = _.find(members, memberIsSelf);\n        var self = this.getSelf();\n\n        if (self && leftSelf) {\n            self.getObservableLastUpdate().setValue(leftSelf.lastUpdate);\n        }\n\n        room._removeMembers(members);\n        cachedRoom._removeMembers(members);\n\n        this._logger.info('[%s] Room has now [%d] members', roomId, room.getObservableMembers().getValue().length);\n    }\n\n    function onMembersUpdated(roomId, members) {\n        var room = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n\n        if (!room || room.getRoomId() !== roomId) {\n            return;\n        }\n\n        // To help reduce conflicts when different properties are sequentially changing\n        var membersWithOnlyPropertiesThatChanged = getDifferencesBetweenCachedRoomMembersAndUpdatedMembers.call(this, members);\n\n        room._updateMembers(membersWithOnlyPropertiesThatChanged);\n        cachedRoom._updateMembers(membersWithOnlyPropertiesThatChanged);\n\n        this._logger.info('[%s] Room has [%d] updated members', roomId, members.length);\n    }\n\n    function onRoomUpdated(roomId, room) {\n        var activeRoom = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n\n        if (!activeRoom || activeRoom.getRoomId() !== roomId) {\n            return;\n        }\n\n        cachedRoom._update(room);\n        activeRoom._update(room);\n    }\n\n    function handlePCastSessionIdChanged(sessionId) {\n        if (this.getSelf() && this.getSelf().getSessionId() === (sessionId || '')) {\n            this._logger.info('[%s] Skip session ID change since it is the same as in self model', sessionId);\n\n            return;\n        }\n\n        resetSelf.call(this, sessionId);\n    }\n\n    function handleSelfUpdated(self) {\n        var that = this;\n\n        if (!self) {\n            return;\n        }\n\n        if (!self.getSessionId()) {\n            return;\n        }\n\n        var activeRoom = that._activeRoom.getValue();\n\n        if (!activeRoom) {\n            return;\n        }\n\n        that._logger.info('[%s] Updating self in room after update', activeRoom.getRoomId());\n\n        updateMemberRequest.call(this, this.getSelf(), function(error, response) {\n            if (_.get(response, ['status']) === 'ok') {\n                that._logger.info('[%s] Updated self in room after update', activeRoom.getRoomId());\n            } else {\n                that._logger.info('[%s] Self was not updated in room after update', activeRoom.getRoomId());\n            }\n        });\n    }\n\n    function findMemberInObservableRoom(sessionId, observableRoom) {\n        var room = observableRoom.getValue();\n        var members = room.getObservableMembers().getValue();\n\n        return findMemberInMembers(sessionId, members);\n    }\n\n    function findMemberInMembers(sessionId, members) {\n        return _.find(members, function(member) {\n            return sessionId === member.getSessionId();\n        });\n    }\n\n    function handlePCastStatusChange(status) {\n        this._logger.info('PCast status changed from [%s] to [%s]', this._lastPcastStatus, status);\n\n        this._lastPcastStatus = status;\n\n        if (status === 'online') {\n            reenterRoom.call(this);\n        }\n    }\n\n    function setupSubscriptions() {\n        var roomEventSubscription = this._protocol.onEvent('chat.RoomEvent', _.bind(onRoomEvent, this));\n        var selfSubscription = this._self.subscribe(_.bind(handleSelfUpdated, this));\n        var pcastStatusSubscription = this._authenticationService.getObservableStatus().subscribe(_.bind(handlePCastStatusChange, this));\n        var pcastSessionIdSubscription = this._authenticationService.getObservableSessionId().subscribe(_.bind(handlePCastSessionIdChanged, this));\n\n        this._disposables.add(roomEventSubscription);\n        this._disposables.add(selfSubscription);\n        this._disposables.add(pcastStatusSubscription);\n        this._disposables.add(pcastSessionIdSubscription);\n    }\n\n    function getDifferencesBetweenCachedRoomMembersAndUpdatedMembers(members) {\n        var that = this;\n\n        return _.map(members, function(member) {\n            var cachedMember = findMemberInObservableRoom(member.sessionId, that._cachedRoom);\n            var placeholderMember = new Member(that, member.state, member.sessionId, member.screenName, member.role, member.streams, member.lastUpdate);\n            var memberWithOnlyDifferentProperties = buildMemberForRequest(placeholderMember, cachedMember);\n\n            memberWithOnlyDifferentProperties.lastUpdate = member.lastUpdate;\n\n            return memberWithOnlyDifferentProperties;\n        });\n    }\n\n    // Requests to server\n    function buildMemberForRequest(member, memberToCompare) {\n        var memberForRequest = findDifferencesInMember(member, memberToCompare);\n\n        memberForRequest.sessionId = member.getSessionId();\n        // Last valid update from server. Handles collisions.\n        memberForRequest.lastUpdate = memberToCompare ? memberToCompare.getLastUpdate() : _.now();\n\n        return memberForRequest;\n    }\n\n    function findDifferencesInMember(member, memberToCompare) {\n        if (!memberToCompare) {\n            return member.toJson();\n        }\n\n        var memberForRequest = {};\n        var newMember = member.toJson();\n        var cachedMember = memberToCompare.toJson();\n        var differences = _.findDifferences(newMember, cachedMember, true);\n\n        _.forEach(differences, function(key) {\n            memberForRequest[key] = newMember[key];\n        });\n\n        return memberForRequest;\n    }\n\n    function getRoomInfoRequest(roomId, alias, callback) {\n        this._authenticationService.assertAuthorized();\n\n        var that = this;\n\n        this._protocol.getRoomInfo(roomId, alias,\n            function handleCreateRoomResponse(error, response) {\n                if (error) {\n                    that._logger.error('Request to get room info failed with error [%s]', error);\n\n                    return callback(error, null);\n                }\n\n                var result = {status: response.status};\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('Request to get room info failed with status [%s]', response.status);\n\n                    return callback(null, result);\n                }\n\n                result.room = _.freeze(createImmutableRoomFromResponse.call(that, response));\n\n                callback(null, result);\n            }\n        );\n    }\n\n    function createRoomRequest(room, callback) {\n        this._authenticationService.assertAuthorized();\n\n        var that = this;\n\n        var validatedRoom = getValidRoomObject.call(that, room);\n\n        this._protocol.createRoom(validatedRoom, function handleCreateRoomResponse(error, response) {\n            if (error) {\n                that._logger.error('Creating room failed with error [%s]', error);\n\n                return callback(error, null);\n            }\n\n            var result = {status: response.status};\n\n            if (response.status !== 'ok' && response.status !== 'already-exists') {\n                that._logger.warn('Creating room failed with status [%s]', response.status);\n\n                return callback(null, result);\n            }\n\n            result.room = _.freeze(createImmutableRoomFromResponse.call(that, response));\n\n            callback(null, result);\n        });\n    }\n\n    function getValidRoomObject(room) {\n        var roomService = this;\n\n        return (new Room(roomService, '', room.alias, room.name, room.description, room.type, [], room.bridgeId, room.pin)).toJson();\n    }\n\n    function enterRoomRequest(roomId, alias, callback, options) {\n        var reenter = _.get(options, 'reenter') === true;\n        var activeRoom = this._activeRoom.getValue();\n\n        if (activeRoom) {\n            var isSameRoom = roomId === activeRoom.getRoomId() || alias === activeRoom.getObservableAlias().getValue();\n\n            if (isSameRoom && !reenter) {\n                this._logger.info('Unable to join room. Already in [%s]/[%s] room.', activeRoom.getRoomId(), activeRoom.getObservableAlias().getValue());\n\n                return callback(null, _.assign({room: activeRoom}, isSameRoom ? alreadyInRoomResponse : inAnotherRoomResponse));\n            }\n        }\n\n        this._authenticationService.assertAuthorized();\n\n        var self = this._self.getValue();\n\n        var screenName = self.getObservableScreenName().getValue();\n        var role = self.getObservableRole().getValue();\n        var selfForRequest = buildMemberForRequest.call(this, self, null);\n        var enterRoomOptions = [];\n        var timestamp = _.now();\n\n        if (reenter) {\n            enterRoomOptions.push('reenter');\n        }\n\n        this._logger.info('Enter room [%s]/[%s] with screen name [%s] and role [%s]', roomId, alias, screenName, role);\n\n        var that = this;\n\n        if (that._isEnteringRoom) {\n            that._logger.info('[%s] We are already entering the room [%s], skipping', roomId, alias);\n\n            return;\n        }\n\n        that._isEnteringRoom = true;\n\n        this._protocol.enterRoom(roomId, alias, selfForRequest, enterRoomOptions, timestamp,\n            function handleEnterRoomResponse(error, response) {\n                that._isEnteringRoom = false;\n\n                if (error) {\n                    that._logger.error('Joining of room failed with error [%s]', error);\n\n                    return callback(error, null);\n                }\n\n                var result = {status: response.status};\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('Joining of room failed with status [%s]', response.status);\n\n                    return callback(null, result);\n                }\n\n                result.room = initializeRoomAndBuildCache.call(that, response);\n\n                if (response.status === 'ok' && response.self) {\n                    that.getSelf()._update(response.self);\n                }\n\n                that._logger.info('Successfully entered room [%s]/[%s]', roomId, alias);\n\n                callback(null, result);\n            }\n        );\n    }\n\n    function leaveRoomRequest(callback, isForceLeaveRoom) {\n        var room = this._activeRoom.getValue();\n\n        if (!_.isBoolean(isForceLeaveRoom)) {\n            isForceLeaveRoom = true;\n        }\n\n        if (!room) {\n            this._logger.info('Not currently in a room.');\n\n            return callback(null, notInRoomResponse);\n        }\n\n        if (this._authenticationService.getPCastSessionId() === '' || this._authenticationService.getPCastSessionId() === null) {\n            this._logger.warn('Unable to leave room. We are currently not connected. Status [%s]', this._lastPcastStatus);\n\n            return;\n        }\n\n        if (this._isLeavingRoom) {\n            return;\n        }\n\n        this._authenticationService.assertAuthorized();\n\n        var roomId = room.getRoomId();\n        var timestamp = _.now();\n\n        this._logger.info('Leave room [%s]', roomId);\n\n        var that = this;\n\n        this._isLeavingRoom = true;\n\n        setTimeout(function() {\n            that._activeRoom.setValue(null);\n            that._cachedRoom.setValue(null);\n\n            if (isForceLeaveRoom) {\n                that._isLeavingRoom = false;\n                callback(null, {status: 'ok'});\n            }\n        });\n\n        this._protocol.leaveRoom(roomId, timestamp,\n            function handleLeaveRoomResponse(error, response) {\n                that._isLeavingRoom = false;\n\n                if (error) {\n                    that._logger.error('Leaving room failed with error [%s]', error);\n\n                    if (isForceLeaveRoom) {\n                        return;\n                    }\n\n                    return callback(error, null);\n                }\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('Leaving room failed with status [%s]', response.status);\n                }\n\n                if (isForceLeaveRoom) {\n                    return;\n                }\n\n                return callback(null, {status: response.status});\n            }\n        );\n    }\n\n    function updateMemberRequest(member, callback) {\n        if (!this._activeRoom.getValue()) {\n            this._logger.warn('Not in a room. Please Enter a room before updating member.');\n\n            return callback(null, notInRoomResponse);\n        }\n\n        this._authenticationService.assertAuthorized();\n\n        var activeRoom = this._activeRoom.getValue();\n        var roomId = activeRoom.getRoomId();\n        var memberIsSelf = member.getSessionId() === this.getSelf().getSessionId();\n        var cachedMember = findMemberInObservableRoom(member.getSessionId(), this._cachedRoom);\n\n        var memberForRequest = buildMemberForRequest.call(this, member, cachedMember);\n        var timestamp = _.now();\n        var wasSelfAudienceMember = memberIsSelf && !cachedMember;\n        var isSelfBecomingAudience = memberIsSelf && memberForRequest.role === memberEnums.roles.audience.name;\n\n        if (wasSelfAudienceMember) {\n            memberForRequest.lastUpdate = member.getObservableLastUpdate().getValue();\n        }\n\n        this._logger.info('Updating member info [%s] for active room [%s]', memberForRequest, roomId);\n\n        var that = this;\n\n        this._protocol.updateMember(roomId, memberForRequest, timestamp,\n            function handleUpdateMemberResponse(error, response) {\n                if (error) {\n                    that._logger.error('Update of member failed with error [%s]', error);\n\n                    return callback(error, null);\n                }\n\n                var result = {\n                    status: response.status,\n                    lastUpdate: response.lastUpdate\n                };\n\n                if (response.status !== 'ok') {\n                    that._logger.info('Update of member failed with status [%s]', response.status);\n                }\n\n                if (response.status === 'ok' && isSelfBecomingAudience && _.isNumber(response.lastUpdate)) {\n                    that.getSelf().getObservableLastUpdate().setValue(response.lastUpdate);\n                }\n\n                callback(null, result);\n            }\n        );\n    }\n\n    function updateRoomRequest(callback) {\n        if (!this._activeRoom.getValue()) {\n            this._logger.warn('Not in a room. Please Enter a room before updating member.');\n\n            return callback(null, notInRoomResponse);\n        }\n\n        this._authenticationService.assertAuthorized();\n\n        var room = this._activeRoom.getValue();\n        var timestamp = _.now();\n\n        var that = this;\n\n        this._protocol.updateRoom(room.toJson(), timestamp,\n            function handleUpdateMemberResponse(error, response) {\n                if (error) {\n                    that._logger.error('Update of room failed with error [%s]', error);\n\n                    return callback(error, null);\n                }\n\n                var result = {status: response.status};\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('Update of room failed with status [%s]', response.status);\n                }\n\n                callback(null, result);\n            }\n        );\n    }\n\n    function createImmutableRoomFromResponse(response) {\n        var roomInfo = response.room;\n        var members = response.members || [];\n        var roomService = this;\n\n        return new ImmutableRoom(roomService, roomInfo.roomId, roomInfo.alias, roomInfo.name, roomInfo.description, roomInfo.type, members, roomInfo.bridgeId, roomInfo.pin);\n    }\n\n    function createRoomFromResponse(response) {\n        var roomInfo = response.room;\n        var members = response.members;\n        var roomService = this;\n\n        return new Room(roomService, roomInfo.roomId, roomInfo.alias, roomInfo.name, roomInfo.description, roomInfo.type, members, roomInfo.bridgeId, roomInfo.pin);\n    }\n\n    function initializeRoomAndBuildCache(response) {\n        var activeRoom = this._activeRoom.getValue();\n        var cachedRoom = this._cachedRoom.getValue();\n        var room = createRoomFromResponse.call(this, response);\n        // The cached room does not contain a reference to the self object so updates to self and room are detected by comparing it against the cached room\n        var newCachedRoom = createRoomFromResponse.call(this, response);\n\n        replaceSelfInstanceInRoom.call(this, room);\n\n        if (activeRoom && cachedRoom) {\n            this._logger.debug('[%s] Updating existing room model.', activeRoom.getRoomId());\n            activeRoom._update(response.room);\n            cachedRoom._update(response.room);\n\n            activeRoom.getObservableMembers().setValue(room.getObservableMembers().getValue());\n            cachedRoom.getObservableMembers().setValue(newCachedRoom.getObservableMembers().getValue());\n\n            return activeRoom;\n        }\n\n        this._activeRoom.setValue(room);\n        this._cachedRoom.setValue(newCachedRoom);\n\n        return room;\n    }\n\n    function replaceSelfInstanceInRoom(room) {\n        var self = this._self.getValue();\n        var members = room.getObservableMembers().getValue();\n\n        var selfIndex = _.findIndex(members, function(member) {\n            return self.getSessionId() === member.getSessionId();\n        });\n\n        if (selfIndex < 0) {\n            this._logger.debug('Self not in server room model.');\n\n            return false;\n        }\n\n        self._update(members[selfIndex].toJson());\n\n        members[selfIndex] = self;\n\n        room.getObservableMembers().setValue(members);\n\n        return true;\n    }\n\n    return RoomService;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    function AuthenticationService(pcast) {\n        this.setPCast(pcast);\n    }\n\n    AuthenticationService.prototype.setPCast = function setPCast(pcast) {\n        assert.isObject(pcast, 'pcast');\n        assert.isFunction(pcast.getObservableStatus, 'pcast.getObservableStatus');\n        assert.isFunction(pcast.getLogger, 'pcast.getLogger');\n        assert.isFunction(pcast.getProtocol, 'pcast.getProtocol');\n\n        if (pcast === this._pcast) {\n            return;\n        }\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n        this._protocol = pcast.getProtocol();\n\n        assert.isObject(this._logger, 'this._logger');\n        assert.isObject(this._protocol, 'this._protocol');\n        assert.isFunction(this._protocol.getObservableSessionId, 'this._protocol.getObservableSessionId');\n        assert.isFunction(this._pcast.getObservableStatus, 'this._pcast.getObservableStatus');\n\n        this._sessionId = this._protocol.getObservableSessionId();\n        this._status = this._pcast.getObservableStatus();\n    };\n\n    AuthenticationService.prototype.checkAuthorized = function assertAuthorized() {\n        if (!validPCastStatus(this.getPCastStatus())) {\n            return false;\n        }\n\n        if (!validPCastSessionId(this.getPCastSessionId())) {\n            return false;\n        }\n\n        return true;\n    };\n\n    AuthenticationService.prototype.assertAuthorized = function assertAuthorized() {\n        if (!validPCastStatus(this.getPCastStatus())) {\n            throw new Error('Unable to perform action. Status [' + this.getPCastStatus() + ']. Please wait to reconnect.');\n        }\n\n        if (!validPCastSessionId(this.getPCastSessionId())) {\n            throw new Error('Unable to perform action. Invalid sessionId [' + this.getPCastSessionId() + '] with status [' + this.getPCastStatus() + ']');\n        }\n    };\n\n    AuthenticationService.prototype.getObservableSessionId = function getObservableSessionId() {\n        return this._sessionId;\n    };\n\n    AuthenticationService.prototype.getObservableStatus = function getObservableStatus() {\n        return this._status;\n    };\n\n    AuthenticationService.prototype.getPCastSessionId = function getPCastSessionId() {\n        return this._sessionId.getValue();\n    };\n\n    AuthenticationService.prototype.getPCastStatus = function getPCastStatus() {\n        return this._status.getValue();\n    };\n\n    function validPCastSessionId(sessionId) {\n        return sessionId !== null && sessionId !== undefined && sessionId !== '';\n    }\n\n    function validPCastStatus(status) {\n        return status !== null && status !== undefined && status !== '' && status.toLowerCase() !== 'offline';\n    }\n\n    return AuthenticationService;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    './Member',\n    './room.json'\n], function(_, assert, observable, Member, room) {\n    'use strict';\n    var roomTypes = room.types;\n\n    function Room(roomService, id, alias, name, description, type, members, bridgeId, pin) {\n        this.init(roomService, id, alias, name, description, type, members, bridgeId, pin);\n    }\n\n    Room.prototype.init = function init(roomService, id, alias, name, description, type, members, bridgeId, pin) {\n        assert.isObject(roomService, 'roomService');\n        assert.isStringNotEmpty(name, 'name');\n        assert.isString(description, 'description');\n        assert.isArray(members, 'members');\n\n        if (id) {\n            assert.isStringNotEmpty(id, 'id');\n        }\n\n        if (alias) {\n            assert.isStringNotEmpty(alias, 'alias');\n        }\n\n        if (bridgeId) {\n            assert.isStringNotEmpty(bridgeId, 'bridgeId');\n        }\n\n        if (pin) {\n            assert.isStringNotEmpty(pin, 'pin');\n        }\n\n        this._roomId = new observable.Observable(id);\n        this._alias = new observable.Observable(alias);\n        this._name = new observable.Observable(name);\n        this._description = new observable.Observable(description);\n        this._type = new observable.Observable(type, assertIsValidRoomType);\n        this._members = new observable.ObservableArray([]).extend({\n            method: \"notifyWhenChangesStop\",\n            timeout: 400\n        });\n        this._options = new observable.ObservableArray();\n        this._bridgeId = new observable.Observable(bridgeId);\n        this._pin = new observable.Observable(pin);\n        this._roomService = roomService;\n\n        setMembers.call(this, members);\n    };\n\n    Room.prototype.getRoomId = function getRoomId() {\n        return this._roomId.getValue();\n    };\n\n    Room.prototype.getObservableAlias = function getObservableAlias() {\n        return this._alias;\n    };\n\n    Room.prototype.getObservableName = function getObservableName() {\n        return this._name;\n    };\n\n    Room.prototype.getObservableDescription = function getObservableDescription() {\n        return this._description;\n    };\n\n    Room.prototype.getObservableType = function getObservableType() {\n        return this._type;\n    };\n\n    Room.prototype.getObservableMembers = function getObservableMembers() {\n        return this._members;\n    };\n\n    Room.prototype.getObservableBridgeId = function getObservableBridgeId() {\n        return this._bridgeId;\n    };\n\n    Room.prototype.getObservablePin = function getObservablePin() {\n        return this._pin;\n    };\n\n    Room.prototype.toString = function toString() {\n        return this._type.getValue() + '[' + this._roomId.getValue() + ']';\n    };\n\n    Room.prototype.toJson = function toJson() {\n        return {\n            roomId: this._roomId.getValue(),\n            alias: this._alias.getValue(),\n            name: this._name.getValue(),\n            description: this._description.getValue(),\n            type: this._type.getValue(),\n            pin: this._pin.getValue(),\n            bridgeId: this._bridgeId.getValue()\n        };\n    };\n\n    Room.prototype.commitChanges = function commitChanges(callback) {\n        assert.isObject(this._roomService, 'this._roomService');\n\n        this._roomService.updateRoom(this, callback);\n    };\n\n    Room.prototype.reload = function reload() {\n        assert.isObject(this._roomService, 'this._roomService');\n\n        this._roomService.revertRoomChanges(this);\n    };\n\n    Room.prototype._update = function update(room) {\n        if (!_.isObject(room)) {\n            return;\n        }\n\n        if (room.roomId) {\n            this._roomId.setValue(room.roomId);\n        }\n\n        if (room.alias) {\n            this._alias.setValue(room.alias);\n        }\n\n        if (room.name) {\n            this._name.setValue(room.name);\n        }\n\n        if (room.description) {\n            this._description.setValue(room.description);\n        }\n\n        if (room.type) {\n            this._type.setValue(room.type);\n        }\n\n        if (room.options) {\n            this._options.setValue(room.options);\n        }\n\n        if (room.bridgeId) {\n            this._bridgeId.setValue(room.bridgeId);\n        }\n\n        if (room.pin) {\n            this._pin.setValue(room.pin);\n        }\n\n        if (room.members) {\n            // DO NOTHING -- members updated by member events\n        }\n    };\n\n    Room.prototype._addMembers = function addMembers(members) {\n        var that = this;\n\n        var newMembers = mapMembers(members, this._roomService);\n\n        _.forEach(newMembers, function(member) {\n            that._members.push(member);\n        });\n    };\n\n    Room.prototype._removeMembers = function removeMembers(members) {\n        var that = this;\n\n        _.forEach(members, function(member) {\n            that._members.remove(function(observableMember) {\n                return member.sessionId === observableMember.getSessionId()\n                    && member.lastUpdate >= observableMember.getObservableLastUpdate().getValue();\n            });\n        });\n    };\n\n    Room.prototype._updateMembers = function updateMembers(members) {\n        _.forEach(this._members.getValue(), function(observableMember) {\n            var memberToUpdate = _.find(members, function(member) {\n                return observableMember.getSessionId() === member.sessionId && member.lastUpdate > observableMember.getObservableLastUpdate().getValue();\n            });\n\n            if (memberToUpdate) {\n                observableMember._update(memberToUpdate);\n            }\n        });\n    };\n\n    function setMembers(members) {\n        var newMembers = mapMembers(members, this._roomService);\n\n        this._members.setValue(newMembers);\n    }\n\n    function mapMembers(members, roomService) {\n        return _.map(members, function(member) {\n            return new Member(roomService, member.state, member.sessionId, member.screenName, member.role, member.streams, member.lastUpdate);\n        });\n    }\n\n    function assertIsValidRoomType(type) {\n        type = _.getEnumName(roomTypes, type);\n\n        if (!type) {\n            throw new Error('\"type\" must be a valid room type');\n        }\n\n        return type;\n    }\n\n    return Room;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    './Stream',\n    './member.json'\n], function(_, assert, observable, Stream, member) {\n    'use strict';\n    var memberRoles = member.roles;\n    var memberStates = member.states;\n\n    function Member(roomService, state, sessionId, screenName, role, streams, lastUpdate) {\n        this.init(roomService, state, sessionId, screenName, role, streams, lastUpdate);\n    }\n\n    Member.prototype.init = function init(roomService, state, sessionId, screenName, role, streams, lastUpdate) {\n        assert.isObject(roomService, 'roomService');\n        assert.isString(sessionId, 'sessionId');\n        assert.isString(screenName, 'screenName');\n        assert.isArray(streams, 'streams');\n        assert.isNumber(_.utc(lastUpdate), 'lastUpdate');\n\n        this._sessionId = new observable.Observable(sessionId);\n        this._screenName = new observable.Observable(screenName);\n        this._streams = new observable.ObservableArray([]);\n\n        this._state = new observable.Observable(state, assertIsValidMemberState).extend({rateLimit: 500});\n        this._role = new observable.Observable(role, assertIsValidMemberRole);\n        this._lastUpdate = new observable.Observable(lastUpdate, _.utc);\n        this._roomService = roomService;\n\n        this.setStreams(streams);\n    };\n\n    Member.prototype.getObservableState = function getObservableState() {\n        return this._state;\n    };\n\n    Member.prototype.getSessionId = function getSessionId() {\n        return this._sessionId.getValue();\n    };\n\n    Member.prototype.getObservableScreenName = function getObservableScreenName() {\n        return this._screenName;\n    };\n\n    Member.prototype.getObservableRole = function getObservableRole() {\n        return this._role;\n    };\n\n    Member.prototype.getObservableStreams = function getObservableStreams() {\n        return this._streams;\n    };\n\n    Member.prototype.getObservableLastUpdate = function getObservableLastUpdate() {\n        return this._lastUpdate;\n    };\n\n    Member.prototype.getLastUpdate = function getLastUpdate() {\n        return this._lastUpdate.getValue();\n    };\n\n    Member.prototype.getStreams = function getStreams() {\n        return _.map(this._streams.getValue(), function mapToJson(stream) {\n            return stream.toJson();\n        });\n    };\n\n    Member.prototype.getRoomService = function getRoomService() {\n        return this._roomService;\n    };\n\n    Member.prototype.commitChanges = function commitChanges(callback) {\n        assert.isObject(this._roomService, 'this._roomService');\n\n        this._roomService.updateMember(this, callback);\n    };\n\n    Member.prototype.reload = function reload() {\n        assert.isObject(this._roomService, 'this._roomService');\n\n        this._roomService.revertMemberChanges(this);\n    };\n\n    Member.prototype.setStreams = function setStreams(streams) {\n        var newStreams = _.map(streams, function(stream) {\n            return createNewObservableStream(stream);\n        });\n\n        this._streams.setValue(newStreams);\n    };\n\n    Member.prototype.toString = function toString() {\n        return this.getObservableRole().getValue() + '[' + this.getObservableScreenName().getValue() + ',' + this.getSessionId() + ']';\n    };\n\n    Member.prototype.toJson = function toJson() {\n        var member = {\n            sessionId: this._sessionId.getValue(),\n            screenName: this._screenName.getValue(),\n            role: this._role.getValue(),\n            state: this._state.getValue(),\n            streams: [],\n            lastUpdate: this._lastUpdate.getValue()\n        };\n\n        _.forEach(this._streams.getValue(), function(stream) {\n            member.streams.push(stream.toJson());\n        });\n\n        return member;\n    };\n\n    Member.prototype._update = function update(member) {\n        if (!_.isObject(member)) {\n            return;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(member, 'state')) {\n            this._state.setValue(member.state);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(member, 'screenName')) {\n            this._screenName.setValue(member.screenName);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(member, 'role')) {\n            this._role.setValue(member.role);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(member, 'lastUpdate')) {\n            this._lastUpdate.setValue(member.lastUpdate);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(member, 'streams')) {\n            updateStreams.call(this, member.streams);\n        }\n    };\n\n    function createNewObservableStream(stream) {\n        return new Stream(stream.uri, stream.type, stream.audioState, stream.videoState);\n    }\n\n    function updateStreams(streams) {\n        // Iterate through new streams object, update those that have changed, push new ones, remove old ones\n        var oldObservableStreams = this._streams.getValue();\n        var newObservableStreams = [];\n\n        _.forEach(streams, function(stream) {\n            var pcastStreamId = Stream.parsePCastStreamIdFromStreamUri(stream.uri);\n            var streamToUpdate = _.find(oldObservableStreams, function(observableStream) {\n                var hasSameUri = observableStream.getUri() === stream.uri;\n                var hasSamePCastStreamId = observableStream.isPCastStream() && observableStream.getPCastStreamId() === pcastStreamId;\n                var hasSameIdentifier = hasSameUri || hasSamePCastStreamId;\n\n                return observableStream.getType() === stream.type && hasSameIdentifier;\n            });\n\n            if (streamToUpdate) {\n                streamToUpdate._update(stream);\n            } else {\n                streamToUpdate = createNewObservableStream(stream);\n            }\n\n            newObservableStreams.push(streamToUpdate);\n        });\n\n        this._streams.setValue(newObservableStreams);\n    }\n\n    function assertIsValidMemberRole(role) {\n        assert.isValidType(role, memberRoles, 'memberRole');\n\n        return _.getEnumName(memberRoles, role);\n    }\n\n    function assertIsValidMemberState(state) {\n        assert.isValidType(state, memberStates, 'memberState');\n\n        return _.getEnumName(memberStates, state);\n    }\n\n    return Member;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var trackEnums = {\n        states: {\n            trackEnabled: {\n                id: 0,\n                name: 'TrackEnabled'\n            },\n            trackDisabled: {\n                id: 1,\n                name: 'TrackDisabled'\n            },\n            trackEnded: {\n                id: 2,\n                name: 'TrackEnded'\n            }\n        }\n    };\n\n    return trackEnums;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-rtc',\n    './ResolutionProvider'\n], function(_, assert, RTC, ResolutionProvider) {\n    'use strict';\n\n    function UserMediaResolver(pcast, options) {\n        assert.isObject(pcast, 'pcast');\n\n        if (options) {\n            assert.isObject(options, 'options');\n        }\n\n        if (options && options.screenShare) {\n            assert.isFunction(options.screenShare, 'options.screenShare');\n        }\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n        this._options = options || {};\n        this._onScreenShare = _.get(options, ['onScreenShare']);\n    }\n\n    UserMediaResolver.prototype.getUserMedia = function getUserMedia(deviceOptions, callback) {\n        assert.isObject(deviceOptions, 'deviceOptions');\n\n        var resolutionProvider = new ResolutionProvider(this._options);\n        var resolution = resolutionProvider.getDefaultResolution();\n        var frameRate = resolutionProvider.getDefaultFrameRate();\n\n        getUserMediaWithOptions.call(this, deviceOptions, resolution, frameRate, resolutionProvider, callback);\n    };\n\n    UserMediaResolver.prototype.getVendorSpecificConstraints = function getVendorSpecificConstraints(deviceOptions, resolution, frameRate) {\n        resolution = resolution || {};\n\n        if (!deviceOptions || (!deviceOptions.audio && !deviceOptions.video && !deviceOptions.screen && !deviceOptions.screenAudio)) {\n            throw new Error('Invalid device options. Must pass in at least one device option.');\n        }\n\n        if ((RTC.browser === 'Firefox' && RTC.browserVersion > 38)\n            || (RTC.browser === 'Chrome' && RTC.browserVersion > 52 && !deviceOptions.screen && !deviceOptions.screenAudio)\n            || (RTC.browser === 'Safari' && RTC.browserVersion > 10)\n            || (RTC.browser === 'Opera' && RTC.browserVersion > 40)) {\n            return setUserMediaOptionsForNewerBrowser(deviceOptions, resolution, frameRate);\n        }\n\n        if (RTC.browser === 'Edge') {\n            return setUserMediaOptionsForEdge(deviceOptions, resolution, frameRate);\n        }\n\n        return setUserMediaOptionsForOtherBrowsers(deviceOptions, resolution, frameRate);\n    };\n\n    function setUserMediaOptionsForEdge(deviceOptions, resolution, frameRate) {\n        var video = deviceOptions.video;\n        var audio = deviceOptions.audio;\n        var screen = deviceOptions.screen;\n        var width = resolution.width;\n        var height = resolution.height;\n        var constraints = {};\n\n        if (video) {\n            constraints.video = {\n                height: {\n                    min: height,\n                    max: height,\n                    exact: height\n                },\n                width: {\n                    min: width,\n                    max: width,\n                    exact: width\n                },\n                frameRate: frameRate\n            };\n\n            if (video.deviceId) {\n                constraints.video.deviceId = video.deviceId;\n            }\n\n            if (video.facingMode) {\n                constraints.video.facingMode = video.facingMode;\n            }\n\n            if (!width) {\n                delete constraints.video.width;\n            }\n\n            if (!height) {\n                delete constraints.video.height;\n            }\n\n            if (!frameRate) {\n                delete constraints.video.frameRate;\n            }\n\n            if (!width && !height && !frameRate && !video.deviceId && !video.facingMode) {\n                constraints.video = true;\n            }\n        }\n\n        if (audio) {\n            constraints.audio = true;\n\n            if (audio.deviceId) {\n                constraints.audio = {deviceId: audio.deviceId};\n            }\n        }\n\n        if (screen) {\n            constraints.screen = true;\n        }\n\n        return constraints;\n    }\n\n    function setUserMediaOptionsForNewerBrowser(deviceOptions, resolution, frameRate) {\n        var video = deviceOptions.video;\n        var audio = deviceOptions.audio;\n        var screen = deviceOptions.screen;\n        var screenAudio = deviceOptions.screenAudio;\n        var width = resolution.width;\n        var height = resolution.height;\n        var constraints = {};\n\n        if (video) {\n            constraints.video = {\n                height: {\n                    min: height,\n                    ideal: height,\n                    max: height\n                },\n                width: {\n                    min: width,\n                    ideal: width,\n                    max: width\n                },\n                frameRate: {\n                    ideal: frameRate,\n                    max: frameRate\n                }\n            };\n\n            if (video.deviceId) {\n                constraints.video.deviceId = {exact: video.deviceId};\n            }\n\n            if (video.facingMode) {\n                constraints.video.facingMode = video.facingMode;\n            }\n\n            if (!width) {\n                delete constraints.video.width;\n            }\n\n            if (!height) {\n                delete constraints.video.height;\n            }\n\n            if (!frameRate) {\n                delete constraints.video.frameRate;\n            }\n\n            if (!width && !height && !frameRate && !video.deviceId && !video.facingMode) {\n                constraints.video = true;\n            }\n        }\n\n        if (audio) {\n            constraints.audio = {};\n\n            if (audio.deviceId) {\n                constraints.audio.deviceId = {exact: audio.deviceId};\n            }\n\n            if (audio.mediaSource) {\n                constraints.audio.mediaSource = audio.mediaSource;\n            }\n\n            if (audio.mediaSourceId) {\n                constraints.audio.mediaSourceId = audio.mediaSourceId;\n            }\n\n            if (!audio.deviceId && !audio.mediaSource && !audio.mediaSourceId) {\n                constraints.audio = true;\n            }\n        }\n\n        if (screenAudio) {\n            constraints.screenAudio = {};\n\n            if (screenAudio.deviceId) {\n                constraints.screenAudio.deviceId = {exact: screenAudio.deviceId};\n            }\n\n            if (screenAudio.mediaSource) {\n                constraints.screenAudio.mediaSource = screenAudio.mediaSource;\n            }\n\n            if (screenAudio.mediaSourceId) {\n                constraints.screenAudio.mediaSourceId = screenAudio.mediaSourceId;\n            }\n\n            if (!screenAudio.deviceId && !screenAudio.mediaSource && !screenAudio.mediaSourceId) {\n                constraints.screenAudio = true;\n            }\n        }\n\n        if (screen) {\n            constraints.screen = {\n                height: {\n                    min: height,\n                    ideal: height,\n                    max: height\n                },\n                width: {\n                    min: width,\n                    ideal: width,\n                    max: width\n                },\n                frameRate: {\n                    ideal: frameRate,\n                    max: frameRate\n                }\n            };\n\n            if (!width) {\n                delete constraints.screen.width;\n            }\n\n            if (!height) {\n                delete constraints.screen.height;\n            }\n\n            if (!frameRate) {\n                delete constraints.screen.frameRate;\n            }\n\n            if (screen.mediaSource) {\n                constraints.screen.mediaSource = screen.mediaSource;\n            }\n\n            if (!width && !height && !frameRate && !screen.mediaSource) {\n                constraints.screen = true;\n            }\n        }\n\n        if (screen && video) {\n            constraints.screen = true;\n        }\n\n        return constraints;\n    }\n\n    function setUserMediaOptionsForOtherBrowsers(deviceOptions, resolution, frameRate) {\n        var video = deviceOptions.video;\n        var audio = deviceOptions.audio;\n        var screen = deviceOptions.screen;\n        var screenAudio = deviceOptions.screenAudio;\n        var width = resolution.width;\n        var height = resolution.height;\n        var constraints = {};\n\n        if (video) {\n            constraints.video = {\n                mandatory: {\n                    minHeight: height,\n                    maxHeight: height,\n                    minWidth: width,\n                    maxWidth: width,\n                    maxFrameRate: frameRate\n                }\n            };\n\n            if (video.deviceId) {\n                constraints.video.mandatory.sourceId = video.deviceId;\n            }\n\n            if (video.facingMode) {\n                constraints.video.facingMode = video.facingMode;\n            }\n\n            if (video.mediaSource) {\n                constraints.video.mandatory.mediaSource = video.mediaSource;\n            }\n\n            if (video.mediaSourceId) {\n                constraints.video.mandatory.mediaSourceId = video.mediaSourceId;\n            }\n\n            if (!width) {\n                delete constraints.video.mandatory.minWidth;\n                delete constraints.video.mandatory.maxWidth;\n            }\n\n            if (!height) {\n                delete constraints.video.mandatory.minHeight;\n                delete constraints.video.mandatory.maxHeight;\n            }\n\n            if (!frameRate) {\n                delete constraints.video.mandatory.maxFrameRate;\n            }\n\n            if (!width && !height && !frameRate && !video.deviceId && !video.facingMode && !video.mediaSource && !video.mediaSourceId) {\n                constraints.video = true;\n            }\n        }\n\n        if (audio) {\n            constraints.audio = {mandatory: {}};\n\n            if (audio.deviceId) {\n                constraints.audio.mandatory.sourceId = audio.deviceId;\n            }\n\n            if (audio.mediaSource) {\n                constraints.audio.mandatory.mediaSource = audio.mediaSource;\n            }\n\n            if (audio.mediaSourceId) {\n                constraints.audio.mandatory.mediaSourceId = audio.mediaSourceId;\n            }\n\n            if (!audio.deviceId && !audio.mediaSource && !audio.mediaSourceId) {\n                constraints.audio = true;\n            }\n        }\n\n        if (screenAudio) {\n            constraints.screenAudio = {mandatory: {}};\n\n            if (screenAudio.deviceId) {\n                constraints.screenAudio.mandatory.sourceId = screenAudio.deviceId;\n            }\n\n            if (screenAudio.mediaSource) {\n                constraints.screenAudio.mandatory.mediaSource = screenAudio.mediaSource;\n            }\n\n            if (screenAudio.mediaSourceId) {\n                constraints.screenAudio.mandatory.mediaSourceId = screenAudio.mediaSourceId;\n            }\n\n            if (!screenAudio.deviceId && !screenAudio.mediaSource && !screenAudio.mediaSourceId) {\n                constraints.screenAudio = true;\n            }\n        }\n\n        if (screen) {\n            constraints.screen = {\n                mandatory: {\n                    minHeight: height,\n                    maxHeight: height,\n                    minWidth: width,\n                    maxWidth: width,\n                    maxFrameRate: frameRate\n                }\n            };\n\n            if (!width) {\n                delete constraints.screen.mandatory.minWidth;\n                delete constraints.screen.mandatory.maxWidth;\n            }\n\n            if (!height) {\n                delete constraints.screen.mandatory.minHeight;\n                delete constraints.screen.mandatory.maxHeight;\n            }\n\n            if (!frameRate) {\n                delete constraints.screen.mandatory.maxFrameRate;\n            }\n\n            if (screen.mediaSource) {\n                constraints.screen.mandatory.mediaSource = screen.mediaSource;\n            }\n\n            if (screen.mediaSourceId) {\n                constraints.screen.mandatory.mediaSourceId = screen.mediaSourceId;\n            }\n\n            if (!width && !height && !frameRate && !screen.mediaSource) {\n                constraints.screen = true;\n            }\n        }\n\n        if (screen && video) {\n            constraints.screen = true;\n        }\n\n        return constraints;\n    }\n\n    function getUserMediaWithOptions(deviceOptions, resolution, frameRate, resolutionProvider, callback) {\n        var constraints = this.getVendorSpecificConstraints(deviceOptions, resolution || {}, frameRate);\n        var hasVideo = !!constraints.video;\n        var that = this;\n\n        this._pcast.getUserMedia(constraints, function(pcast, status, userMedia, error) {\n            if (status === 'ok') {\n                that._logger.info('Acquired user media with constraints [%s]', constraints);\n\n                return callback(null, {\n                    userMedia: userMedia,\n                    options: {\n                        frameRate: hasVideo ? frameRate : null,\n                        resolution: hasVideo ? _.get(resolution, ['resolution'], null) : null,\n                        aspectRatio: hasVideo ? _.get(resolution, ['aspectRatio'], null) : null\n                    }\n                });\n            }\n\n            that._logger.info('Failed to acquire user media with constraints [%s]', constraints);\n\n            var nextResolution = resolution;\n            var nextFrameRate = frameRate;\n            var constraintName = getConstraintNameFromError(error);\n\n            if (error && (\n                error.name === 'ConstraintNotSatisfiedError'\n                || error.name === 'OverconstrainedError'\n                || error.constructor.name === 'OverconstrainedError'\n                || (error.code === 'unavailable' && RTC.browser === 'Edge'))\n            ) {\n                switch (constraintName.toLowerCase()) {\n                case 'width':\n                case 'height':\n                    if (!resolution || !resolutionProvider.canResolveNextResolution()) {\n                        break;\n                    }\n\n                    that._logger.warn('Unable to get user media with constraint [%s] with height [%s] and width [%s]. Retrying with next closest resolution.',\n                        constraintName, nextResolution.height, nextResolution.width);\n                    nextResolution = resolutionProvider.getNextResolution(resolution.height, resolution.aspectRatio);\n\n                    return getUserMediaWithOptions.call(that, deviceOptions, nextResolution, nextFrameRate, resolutionProvider, callback);\n                case 'framerate':\n                default:\n                    // Always try without frame rate if constraint name is not defined\n                    if (frameRate) {\n                        that._logger.warn('Unable to get user media with constraint [%s] and frame rate [%s]. Retrying without frame rate constraint.', constraintName, frameRate);\n                        nextFrameRate = null;\n\n                        return getUserMediaWithOptions.call(that, deviceOptions, nextResolution, nextFrameRate, resolutionProvider, callback);\n                    }\n\n                    // Then try to reduce resolution\n                    if (!resolution || !resolutionProvider.canResolveNextResolution()) {\n                        break;\n                    }\n\n                    that._logger.warn('Unable to get user media with constraint [%s] with height [%s] and width [%s]. Retrying with next closest resolution.',\n                        constraintName, nextResolution.height, nextResolution.width);\n                    nextResolution = resolutionProvider.getNextResolution(resolution.height, resolution.aspectRatio);\n\n                    return getUserMediaWithOptions.call(that, deviceOptions, nextResolution, nextFrameRate, resolutionProvider, callback);\n                }\n            }\n\n            that._logger.error('Unable to get user media with status [%s]', status, error);\n\n            return callback(error);\n        }, function(constraints) {\n            var clientConstraints = constraints;\n\n            if (that._onScreenShare && RTC.browser === 'Chrome') {\n                var normalizedConstraints = normalizeChromeScreenShareConstraints(constraints);\n\n                clientConstraints = that._onScreenShare(normalizedConstraints);\n\n                var resolution;\n\n                if (clientConstraints.resolution && clientConstraints.aspectRatio) {\n                    switch (this._defaultAspectRatio) {\n                    // Portrait\n                    case '9x16':\n                    case '3x4':\n                        resolution = {\n                            width: clientConstraints.resolution,\n                            height: resolutionProvider.calculateLongerDimensionByAspectRatio(clientConstraints.resolution, clientConstraints.aspectRatio)\n                        };\n\n                        break;\n                    // Landscape\n                    case '16x9':\n                    case '4x3':\n                    default:\n                        resolution = {\n                            width: resolutionProvider.calculateLongerDimensionByAspectRatio(clientConstraints.resolution, clientConstraints.aspectRatio),\n                            height: clientConstraints.resolution\n                        };\n\n                        break;\n                    }\n                }\n\n                clientConstraints = getChromeScreenShareConstraints.call(that, normalizedConstraints, resolution, clientConstraints.frameRate);\n            }\n\n            return clientConstraints;\n        });\n    }\n\n    function normalizeChromeScreenShareConstraints(constraints) {\n        var chromeVideoSource = _.get(constraints, ['video', 'mandatory', 'chromeMediaSource']);\n        var chromeAudioSource = _.get(constraints, ['audio', 'mandatory', 'chromeMediaSource']);\n        var chromeVideoSourceId = _.get(constraints, ['video', 'mandatory', 'chromeMediaSourceId']);\n        var chromeAudioSourceId = _.get(constraints, ['audio', 'mandatory', 'chromeMediaSourceId']);\n        var normalizedConstraints = {};\n\n        if (chromeVideoSource || chromeAudioSourceId) {\n            _.set(normalizedConstraints, ['screen', 'mediaSource'], chromeVideoSource);\n            _.set(normalizedConstraints, ['screen', 'mediaSourceId'], chromeVideoSourceId);\n        }\n\n        if (chromeAudioSource || chromeAudioSourceId) {\n            _.set(normalizedConstraints, ['screenAudio', 'mediaSource'], chromeAudioSource);\n            _.set(normalizedConstraints, ['screenAudio', 'mediaSourceId'], chromeAudioSourceId);\n        }\n\n        return normalizedConstraints;\n    }\n\n    function getChromeScreenShareConstraints(constraints, resolution, frameRate) {\n        var screenShareConstraints = this.getVendorSpecificConstraints(constraints, resolution, frameRate);\n\n        if (screenShareConstraints.screen) {\n            screenShareConstraints.video = screenShareConstraints.screen;\n            delete screenShareConstraints.screen;\n        }\n\n        if (screenShareConstraints.screenAudio) {\n            screenShareConstraints.audio = screenShareConstraints.screenAudio;\n            delete screenShareConstraints.screenAudio;\n        }\n\n        var chromeVideoSource = _.get(screenShareConstraints, ['video', 'mandatory', 'mediaSource']);\n        var chromeAudioSource = _.get(screenShareConstraints, ['audio', 'mandatory', 'mediaSource']);\n        var chromeVideoSourceId = _.get(screenShareConstraints, ['video', 'mandatory', 'mediaSourceId']);\n        var chromeAudioSourceId = _.get(screenShareConstraints, ['audio', 'mandatory', 'mediaSourceId']);\n\n        if (chromeVideoSource || chromeVideoSourceId) {\n            _.set(screenShareConstraints, ['video', 'mandatory', 'chromeMediaSource'], chromeVideoSource);\n            _.set(screenShareConstraints, ['video', 'mandatory', 'chromeMediaSourceId'], chromeVideoSourceId);\n            delete screenShareConstraints.video.mandatory.mediaSource;\n            delete screenShareConstraints.video.mandatory.mediaSourceId;\n        }\n\n        if (chromeAudioSource || chromeAudioSourceId) {\n            _.set(screenShareConstraints, ['audio', 'mandatory', 'chromeMediaSource'], chromeAudioSource);\n            _.set(screenShareConstraints, ['audio', 'mandatory', 'chromeMediaSourceId'], chromeAudioSourceId);\n            delete screenShareConstraints.audio.mandatory.mediaSource;\n            delete screenShareConstraints.audio.mandatory.mediaSourceId;\n        }\n\n        return screenShareConstraints;\n    }\n\n    function getConstraintNameFromError(error) {\n        if (error.constraintName) {\n            return error.constraintName;\n        }\n\n        if (error.constraint) {\n            return error.constraint;\n        }\n\n        return '';\n    }\n\n    return UserMediaResolver;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    '../AdminApiProxyClient',\n    '../userMedia/UserMediaResolver',\n    '../PCast',\n    'phenix-rtc',\n    '../streaming/shaka.json'\n], function(_, assert, observable, AdminApiProxyClient, UserMediaResolver, PCast, rtc, shakaEnums) {\n    'use strict';\n\n    var instanceCounter = 0;\n    var unauthorizedStatus = 'unauthorized';\n    var capacityBackoffTimeout = 1000;\n    var defaultPrerollSkipDuration = 500;\n    var defaultUserActionOnlineTimeout = 20000;\n    var defaultReconnectOptions = {\n        maxOfflineTime: 3 * 60 * 1000,\n        maxReconnectFrequency: 60 * 1000\n    };\n\n    function PCastExpress(options) {\n        assert.isObject(options, 'options');\n\n        if (options.authToken) {\n            assert.isStringNotEmpty(options.authToken, 'options.authToken');\n        }\n\n        if (options.authToken && options.adminApiProxyClient) {\n            throw new Error('Do not pass \"options.adminApiProxyClient\" if you are using \"options.authToken\"');\n        }\n\n        if (options.onError) {\n            assert.isFunction(options.onError, 'options.onError');\n        }\n\n        if (!_.isNullOrUndefined(options.onlineTimeout)) {\n            assert.isNumber(options.onlineTimeout, 'options.onlineTimeout');\n\n            if (options.onlineTimeout < 0) {\n                throw new Error('\"options.onlineTimeout\" must be a positive number');\n            }\n        }\n\n        if (options.reconnectOptions) {\n            assert.isObject(options.reconnectOptions, 'options.reconnectOptions');\n            assert.isNumber(options.reconnectOptions.maxOfflineTime, 'options.reconnectOptions.maxOfflineTime');\n            assert.isNumber(options.reconnectOptions.maxReconnectFrequency, 'options.reconnectOptions.maxReconnectFrequency');\n        }\n\n        if (options.adminApiProxyClient) {\n            assert.isObject(options.adminApiProxyClient, 'options.adminApiProxyClient');\n            assert.isFunction(options.adminApiProxyClient.createAuthenticationToken, 'options.adminApiProxyClient.createAuthenticationToken');\n        }\n\n        this._instanceId = ++instanceCounter;\n        this._pcastObservable = new observable.Observable(null).extend({rateLimit: 0});\n        this._sessionIdObservable = new observable.Observable(null).extend({rateLimit: 0});\n        this._publishers = {};\n        this._adminApiProxyClient = options.adminApiProxyClient;\n        this._isInstantiated = false;\n        this._reconnectCount = 0;\n        this._reauthCount = 0;\n        this._disposed = false;\n        this._authToken = options.authToken;\n        this._onError = options.onError;\n        this._options = options;\n        this._onlineTimeout = _.isNumber(options.onlineTimeout) ? options.onlineTimeout : defaultUserActionOnlineTimeout;\n        this._reconnectOptions = options.reconnectOptions || defaultReconnectOptions;\n        this._logger = null;\n        this._ignoredStreamEnds = {};\n\n        instantiatePCast.call(this);\n\n        // After logger is instantiated\n        if (!options.adminApiProxyClient) {\n            if (options.backendUri || _.isString(options.backendUri)) {\n                this._logger.warn('Passing options.backendUri is deprecated. Please create an instance of the sdk.net.AdminApiProxyClient and pass that instead');\n            }\n\n            if (options.authenticationData) {\n                this._logger.warn('Passing options.authenticationData is deprecated. Please create an instance of the sdk.net.AdminApiProxyClient and pass that instead');\n            }\n        }\n    }\n\n    PCastExpress.prototype.toString = function toString() {\n        return 'PCastExpress[' + this._instanceId + ']';\n    };\n\n    PCastExpress.prototype.dispose = function dispose() {\n        if (this._listedForCriticalNetworkRecoveryDisposable) {\n            this._listedForCriticalNetworkRecoveryDisposable.dispose();\n            this._listedForCriticalNetworkRecoveryDisposable = null;\n        }\n\n        if (this._pcastObservable.getValue()) {\n            this._pcastObservable.getValue().stop();\n            this._pcastObservable.setValue(null);\n        }\n\n        if (this._sessionIdObservable.getValue()) {\n            this._sessionIdObservable.setValue(null);\n        }\n\n        if (_.isNumber(this._instantiatePCastTimeoutId)) {\n            clearTimeout(this._instantiatePCastTimeoutId);\n            this._instantiatePCastTimeoutId = null;\n        }\n\n        if (this._adminApiProxyClient) {\n            this._adminApiProxyClient.dispose();\n        }\n\n        if (this.sessionIdSubscription) {\n            this.sessionIdSubscription.dispose();\n        }\n\n        if (this._sessionIdObservable && this._sessionIdObservable.dispose) {\n            this._sessionIdObservable.dispose();\n        }\n\n        this._reconnectCount = 0;\n        this._reauthCount = 0;\n        this._disposed = true;\n\n        this._logger.info('[%s] Disposed PCast Express instance', this);\n    };\n\n    PCastExpress.prototype.getPCast = function getPCast() {\n        return this._pcastObservable.getValue();\n    };\n\n    PCastExpress.prototype.getPCastObservable = function() {\n        return this._pcastObservable;\n    };\n\n    PCastExpress.prototype.getSessionIdObservable = function() {\n        return this._sessionIdObservable;\n    };\n\n    PCastExpress.prototype.getAdminAPI = function getAdminAPI() {\n        return this._adminApiProxyClient;\n    };\n\n    PCastExpress.prototype.getUserMedia = function(options, callback) {\n        var that = this;\n\n        assert.isObject(options.mediaConstraints, 'options.mediaConstraints');\n        assert.isFunction(callback, 'callback');\n\n        if (options.resolution) {\n            assert.isNumber(options.resolution, 'options.resolution');\n        }\n\n        if (options.frameRate) {\n            assert.isNumber(options.frameRate, 'options.frameRate');\n        }\n\n        if (options.aspectRatio) {\n            assert.isStringNotEmpty(options.aspectRatio, 'options.aspectRatio');\n        }\n\n        if (options.onResolveMedia) {\n            assert.isFunction(options.onResolveMedia, 'options.onResolveMedia');\n        }\n\n        if (options.onScreenShare) {\n            assert.isFunction(options.onScreenShare, 'options.onScreenShare');\n        }\n\n        if (that._pcastObservable.getValue()) {\n            return resolveUserMedia.call(that, that._pcastObservable.getValue(), options, callback);\n        }\n\n        var pcastSubscription = that._pcastObservable.subscribe(function(pcast) {\n            if (!pcast) {\n                return;\n            }\n\n            pcastSubscription.dispose();\n\n            resolveUserMedia.call(that, pcast, options, callback);\n        });\n    };\n\n    PCastExpress.prototype.publish = function publish(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        if (options.capabilities) {\n            assert.isArray(options.capabilities, 'options.capabilities');\n        }\n\n        if (options.connectOptions) {\n            assert.isArray(options.connectOptions, 'options.connectOptions');\n        }\n\n        if (options.mediaConstraints) {\n            assert.isObject(options.mediaConstraints, 'options.mediaConstraints');\n        } else {\n            assert.isObject(options.userMediaStream, 'options.userMediaStream');\n        }\n\n        if (options.videoElement) {\n            assert.isObject(options.videoElement, 'options.videoElement');\n        }\n\n        if (options.monitor) {\n            assert.isObject(options.monitor, 'options.monitor');\n            assert.isFunction(options.monitor.callback, 'options.monitor.callback');\n\n            if (options.monitor.options) {\n                assert.isObject(options.monitor.options, 'options.monitor.options');\n            }\n        }\n\n        if (options.publishToken) {\n            assert.isStringNotEmpty(options.publishToken, 'options.publishToken');\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n        }\n\n        if (options.publishToken && options.streamToken) {\n            throw new Error('Do not pass streamToken with publishToken. Please use publishToken.');\n        }\n\n        var that = this;\n\n        this.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (options.userMediaStream) {\n                return getStreamingTokenAndPublish.call(that, options.userMediaStream, options, false, callback);\n            }\n\n            that.getUserMedia(options, function(error, response) {\n                if (error) {\n                    return callback(error);\n                }\n\n                if (response.status !== 'ok') {\n                    return callback(null, response);\n                }\n\n                getStreamingTokenAndPublish.call(that, response.userMedia, options, true, callback);\n            });\n        }, options.isContinuation);\n    };\n\n    var connectOptionCapabilities = ['streaming', 'low-latency', 'on-demand', 'uld', 'vvld', 'vld', 'ld', 'sd', 'hd', 'fhd', 'uhd'];\n\n    PCastExpress.prototype.publishRemote = function publishRemote(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n        assert.isStringNotEmpty(options.streamUri, 'options.streamUri');\n\n        if (options.capabilities) {\n            assert.isArray(options.capabilities, 'options.capabilities');\n        }\n\n        if (options.connectOptions) {\n            assert.isArray(options.connectOptions, 'options.connectOptions');\n        }\n\n        if (options.mediaConstraints) {\n            throw new Error('Invalid argument: mediaConstraints, passed on publishRemote. Local media not allowed when publishing remote content.');\n        }\n\n        if (options.videoElement) {\n            throw new Error('May not preview remote stream. Please subscribe to view.');\n        }\n\n        if (options.prerollSkipDuration) {\n            assert.isNumber(options.prerollSkipDuration, 'options.prerollSkipDuration');\n        }\n\n        if (options.monitor) {\n            assert.isObject(options.monitor, 'options.monitor');\n            assert.isFunction(options.monitor.callback, 'options.monitor.callback');\n\n            if (options.monitor.options) {\n                assert.isObject(options.monitor.options, 'options.monitor.options');\n            }\n        }\n\n        if (options.frameRate) {\n            assert.isObject(options.frameRate, 'options.frameRate');\n\n            if (options.frameRate.exact) {\n                assert.isNumber(options.frameRate.exact, 'options.frameRate.exact');\n            }\n\n            if (options.frameRate.max) {\n                assert.isNumber(options.frameRate.max, 'options.frameRate.max');\n            }\n        }\n\n        if (options.publishToken) {\n            assert.isStringNotEmpty(options.publishToken, 'options.publishToken');\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n        }\n\n        if (options.publishToken && options.streamToken) {\n            throw new Error('Do not pass streamToken with publishToken. Please use publishToken.');\n        }\n\n        var that = this;\n\n        this.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            var remoteOptions = _.assign({\n                connectOptions: [],\n                capabilities: []\n            }, options);\n\n            if (!_.includes(remoteOptions.capabilities, 'publish-uri')) {\n                remoteOptions.capabilities.push('publish-uri');\n            }\n\n            _.forEach(connectOptionCapabilities, function(capability) {\n                if (_.includes(remoteOptions.capabilities, capability)) {\n                    remoteOptions.connectOptions.push('publisher-capability=' + capability);\n                }\n            });\n\n            if (options.frameRate && options.frameRate.exact) {\n                remoteOptions.connectOptions.push('source-uri-video-fps=' + options.frameRate.exact);\n            }\n\n            if (options.frameRate && options.frameRate.max) {\n                remoteOptions.connectOptions.push('source-uri-video-fps-max=' + options.frameRate.max);\n            }\n\n            remoteOptions.connectOptions.push('source-uri-preroll-skip-duration=' + (_.isNumber(options.prerollSkipDuration) ? options.prerollSkipDuration : defaultPrerollSkipDuration).toString());\n\n            getStreamingTokenAndPublish.call(that, remoteOptions.streamUri, remoteOptions, false, callback);\n        });\n    };\n\n    PCastExpress.prototype.publishStreamToExternal = function publishStreamToExternal(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n        assert.isStringNotEmpty(options.streamId, 'options.streamId');\n        assert.isStringNotEmpty(options.externalUri, 'options.externalUri');\n\n        if (options.capabilities) {\n            assert.isArray(options.capabilities, 'options.capabilities');\n        }\n\n        if (options.connectOptions) {\n            assert.isArray(options.connectOptions, 'options.connectOptions');\n        }\n\n        if (options.mediaConstraints) {\n            throw new Error('Invalid argument: mediaConstraints, passed on publishStreamToExternal. Local media not allowed when publishing remote content.');\n        }\n\n        if (options.videoElement) {\n            throw new Error('May not preview external stream. Please subscribe to view.');\n        }\n\n        if (options.monitor) {\n            assert.isObject(options.monitor, 'options.monitor');\n            assert.isFunction(options.monitor.callback, 'options.monitor.callback');\n\n            if (options.monitor.options) {\n                assert.isObject(options.monitor.options, 'options.monitor.options');\n            }\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n        }\n\n        var that = this;\n\n        this.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            var remoteOptions = _.assign({\n                connectOptions: [],\n                capabilities: []\n            }, options);\n\n            if (!_.includes(remoteOptions.capabilities, 'egress')) {\n                remoteOptions.capabilities.push('egress');\n            }\n\n            if (!_.includes(remoteOptions.capabilities, 'egress-own-stream')) {\n                remoteOptions.capabilities.push('egress-own-stream');\n            }\n\n            getStreamingTokenAndPublish.call(that, remoteOptions.externalUri, remoteOptions, false, callback);\n        });\n    };\n\n    PCastExpress.prototype.publishScreen = function publishScreen(options, callback) {\n        var publishScreenOptions = _.assign({mediaConstraints: {screen: true}}, options);\n\n        _.set(publishScreenOptions, ['monitor', 'options'], _.assign({}, {\n            monitorFrameRate: false,\n            videoBitRateThreshold: 100,\n            conditionCountForNotificationThreshold: 8\n        }, _.get(publishScreenOptions, ['monitor', 'options'], {})));\n\n        return this.publish(publishScreenOptions, callback);\n    };\n\n    PCastExpress.prototype.subscribe = function subscribe(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n        assert.isStringNotEmpty(options.streamId, 'options.streamId');\n\n        if (options.videoElement) {\n            assert.isObject(options.videoElement, 'options.videoElement');\n        }\n\n        if (options.monitor) {\n            assert.isObject(options.monitor, 'options.monitor');\n            assert.isFunction(options.monitor.callback, 'options.monitor.callback');\n\n            if (options.monitor.options) {\n                assert.isObject(options.monitor.options, 'options.monitor.options');\n            }\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n        } else {\n            assert.isObject(options.capabilities, 'options.capabilities');\n        }\n\n        if (options.subscriberOptions) {\n            assert.isObject(options.subscriberOptions, 'options.subscriberOptions');\n        }\n\n        var that = this;\n\n        this.waitForOnline(function(error) {\n            if (error) {\n                that._logger.error('[%s] Failed to subscribe after error waiting for online status', this, error);\n\n                return callback(error);\n            }\n\n            if (options.streamToken) {\n                return subscribeToStream.call(that, options.streamToken, options, callback);\n            }\n\n            if (!options.streamToken && !that._adminApiProxyClient) {\n                throw new Error('Use stream token, or set adminApiProxyClient');\n            }\n\n            that._logger.info('[%s] [%s] Generating stream token for subscribing to origin [%s]', this, that._pcastObservable.getValue().getProtocol().getSessionId(), options.streamId);\n\n            that._adminApiProxyClient.createStreamTokenForSubscribing(that._pcastObservable.getValue().getProtocol().getSessionId(), options.capabilities, options.streamId, null, function(error, response) {\n                if (error) {\n                    that._logger.error('[%s] Failed to create stream token for subscribing', this, error);\n\n                    return callback(error);\n                }\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('[%s] Failed to create stream token for subscribing with status [%s]', this, response.status);\n\n                    return callback(null, response);\n                }\n\n                subscribeToStream.call(that, response.streamToken, options, callback);\n            });\n        }, options.isContinuation);\n    };\n\n    PCastExpress.prototype.subscribeToScreen = function subscribeToScreen(options, callback) {\n        var subscribeToScreenOptions = _.assign({}, options);\n\n        _.set(subscribeToScreenOptions, ['monitor', 'options'], _.assign({}, {\n            monitorFrameRate: false,\n            videoBitRateThreshold: 100,\n            conditionCountForNotificationThreshold: 8\n        }, _.get(subscribeToScreenOptions, ['monitor', 'options'], {})));\n\n        return this.subscribe(subscribeToScreenOptions, callback);\n    };\n\n    PCastExpress.prototype.waitForOnline = function waitForOnline(callback, isNotUserAction) {\n        assert.isFunction(callback, 'callback');\n\n        if (this._pcastObservable.getValue() && this._pcastObservable.getValue().getStatus() === 'online') {\n            return callback();\n        }\n\n        var that = this;\n        var disposeOfWaitTimeout = isNotUserAction ? _.get(that._reconnectOptions, ['maxOfflineTime']) : this._onlineTimeout;\n        var pcastSubscription = null;\n        var statusSubscription = null;\n        var onlineTimeoutId = setTimeout(function() {\n            that._logger.info('[%s] Disposing of online listener after [%s] ms', this, disposeOfWaitTimeout);\n\n            if (pcastSubscription) {\n                pcastSubscription.dispose();\n            }\n\n            if (statusSubscription) {\n                statusSubscription.dispose();\n            }\n\n            if (that._disposed) {\n                that._logger.info('[%s] Instance was disposed while waiting for online, ignoring callback', this);\n\n                return;\n            }\n\n            callback(new Error('timeout'));\n        }, disposeOfWaitTimeout);\n\n        this._logger.info('[%s] Waiting for online status before continuing. Timeout set to [%s]', this, disposeOfWaitTimeout);\n\n        var subscribeToStatusChange = function(pcast) {\n            if (statusSubscription) {\n                statusSubscription.dispose();\n            }\n\n            if (!pcast) {\n                return;\n            }\n\n            statusSubscription = pcast.getObservableStatus().subscribe(function(status) {\n                if (that._disposed) {\n                    that._logger.info('[%s] Instance was disposed while waiting for online, canceling waiting and skip triggering callback', this);\n\n                    clearTimeout(onlineTimeoutId);\n                    statusSubscription.dispose();\n                    pcastSubscription.dispose();\n\n                    return;\n                }\n\n                if (status !== 'online') {\n                    that._logger.info('[%s] Still waiting for online status before continuing. Current status is [%s]', this, status);\n\n                    return;\n                }\n\n                clearTimeout(onlineTimeoutId);\n                statusSubscription.dispose();\n                pcastSubscription.dispose();\n\n                return callback();\n            }, {initial: 'notify'});\n        };\n\n        pcastSubscription = this._pcastObservable.subscribe(subscribeToStatusChange, {initial: 'notify'});\n    };\n\n    PCastExpress.prototype.parseCapabilitiesFromToken = function parseCapabilitiesFromToken(streamToken) {\n        var pcast = this._pcastObservable.getValue();\n\n        return pcast.parseCapabilitiesFromToken(streamToken);\n    };\n\n    PCastExpress.prototype.parseRoomOrChannelIdFromToken = function parseRoomOrChannelIdFromToken(streamToken) {\n        var pcast = this._pcastObservable.getValue();\n\n        return pcast.parseRoomOrChannelIdFromToken(streamToken);\n    };\n\n    PCastExpress.prototype.parseRoomOrChannelAliasFromToken = function parseRoomOrChannelAliasFromToken(streamToken) {\n        var pcast = this._pcastObservable.getValue();\n\n        return pcast.parseRoomOrChannelAliasFromToken(streamToken);\n    };\n\n    function instantiatePCast() {\n        var that = this;\n\n        var authenticationCallback = function(_, status) {\n            if (status === 'critical-network-issue') {\n                return onPCastStatusChange.call(that, status);\n            }\n        };\n\n        if (!this._pcastObservable.getValue()) {\n            var pcastOptions = _.assign({logger: this._logger}, this._options);\n\n            this._pcastObservable.setValue(new PCast(pcastOptions));\n        }\n\n        if (!this._logger) {\n            this._logger = this._pcastObservable.getValue().getLogger();\n        }\n\n        if (!this._pcastStatusSubscription) {\n            this._pcastStatusSubscription = this._pcastObservable.getValue().getObservableStatus().subscribe(_.bind(onPCastStatusChange, this));\n        }\n\n        if (this.sessionIdSubscription) {\n            this.sessionIdSubscription.dispose();\n        }\n\n        var handleSessionIdChange = function(sessionId) {\n            this._sessionIdObservable.setValue(sessionId);\n        };\n\n        this.sessionIdSubscription = this._pcastObservable.getValue().getObservableSessionId().subscribe(_.bind(handleSessionIdChange, this));\n\n        if (this._authToken) {\n            return this._pcastObservable.getValue().start(this._authToken, authenticationCallback, _.noop, _.noop);\n        }\n\n        if (!this._authToken && !that._adminApiProxyClient) {\n            throw new Error('Use auth token, or set adminApiProxyClient');\n        }\n\n        this._adminApiProxyClient.createAuthenticationToken(function(error, response) {\n            if (error && error.message === 'timeout') {\n                return onPCastStatusChange.call(that, error.message);\n            }\n\n            if (error) {\n                return handleError.call(that, error);\n            }\n\n            if (response.status !== 'ok') {\n                return onPCastStatusChange.call(that, response.status);\n            }\n\n            if (!that._pcastObservable.getValue()) {\n                that._logger.warn('[%s] Unable to authenticate. PCast not instantiated.', this);\n\n                return;\n            }\n\n            that._pcastObservable.getValue().start(response.authenticationToken, _.noop, _.noop, _.noop);\n        });\n    }\n\n    function onPCastStatusChange(status) {\n        switch (status) {\n        case 'timeout':\n        case 'critical-network-issue':\n            if (this._pcastObservable.getValue()) {\n                this._pcastObservable.getValue().stop('recovery');\n                this._pcastObservable.setValue(null);\n            }\n\n            if (this._sessionIdObservable.getValue()) {\n                this._sessionIdObservable.setValue(null);\n            }\n\n            if (this._pcastStatusSubscription) {\n                this._pcastStatusSubscription.dispose();\n                this._pcastStatusSubscription = null;\n            }\n\n            this._reconnectCount++;\n\n            return instantiateWithBackoff.call(this);\n        case 'reconnect-failed':\n        case 'unauthorized':\n            delete this._authToken;\n\n            if (!this._adminApiProxyClient) {\n                return handleError.call(this, new Error(status));\n            }\n\n            this._reauthCount++;\n\n            if (this._reauthCount > 1) {\n                return handleError.call(this, new Error(status));\n            }\n\n            this._logger.info('[%s] Attempting to create new authToken and re-connect after [%s] response', this, unauthorizedStatus);\n\n            return getAuthTokenAndReAuthenticate.call(this);\n        case 'capacity':\n        case 'network-unavailable':\n            this._reconnectCount++;\n\n            return instantiateWithBackoff.call(this);\n        case 'online':\n            if (!this._isInstantiated) {\n                this._logger.info('[%s] Successfully instantiated', this);\n            } else {\n                this._logger.info('[%s] Successfully reconnected (reconnectCount=[%s],reauthCount=[%s])', this, this._reconnectCount, this._reauthCount);\n            }\n\n            this._reauthCount = 0;\n            this._reconnectCount = 0;\n            this._isInstantiated = true;\n\n            return;\n        case 'reconnecting':\n        case 'reconnected':\n        case 'connecting':\n            break; // Everything ok\n        case 'offline':\n            return;\n        case 'failed':\n        default:\n            return handleError.call(this, new Error(status));\n        }\n    }\n\n    function instantiateWithBackoff() {\n        var that = this;\n        var staticTimeout = Math.min(capacityBackoffTimeout * that._reconnectCount * that._reconnectCount, this._reconnectOptions.maxReconnectFrequency);\n        var maxOffsetInSeconds = Math.min(staticTimeout / 10000, 5);\n        var randomLinearOffset = Math.random() * maxOffsetInSeconds * 1000;\n        var timeoutWithRandomOffset = staticTimeout + randomLinearOffset;\n\n        this._logger.info('[%s] Waiting for [%s] ms before continuing to attempt to reconnect to PCast', this, timeoutWithRandomOffset);\n\n        this._instantiatePCastTimeoutId = setTimeout(function() {\n            if (!that._pcastObservable.getValue() || !that._pcastObservable.getValue().isStarted()) {\n                return instantiatePCast.call(that);\n            }\n\n            return getAuthTokenAndReAuthenticate.call(that);\n        }, timeoutWithRandomOffset);\n    }\n\n    function getAuthTokenAndReAuthenticate() {\n        var that = this;\n\n        this._adminApiProxyClient.createAuthenticationToken(function(error, response) {\n            if (error && error.message === 'timeout') {\n                return onPCastStatusChange.call(that, error.message);\n            }\n\n            if (error) {\n                return handleError.call(that, error);\n            }\n\n            if (response.status !== 'ok') {\n                return onPCastStatusChange.call(that, response.status);\n            }\n\n            if (!that._pcastObservable.getValue()) {\n                that._logger.warn('[%s] Unable to authenticate. PCast not instantiated.', this);\n\n                return;\n            }\n\n            that._pcastObservable.getValue().reAuthenticate(response.authenticationToken);\n        });\n    }\n\n    function handleError(e) {\n        if (!this._onError) {\n            throw e;\n        }\n\n        this._onError(e);\n    }\n\n    function resolveUserMedia(pcast, options, callback) {\n        var userMediaResolver = new UserMediaResolver(pcast, {\n            aspectRatio: options.aspectRatio,\n            resolution: options.resolution,\n            frameRate: options.frameRate,\n            resolutionSelectionStrategy: options.resolutionSelectionStrategy,\n            onScreenShare: function(screenOptions) {\n                screenOptions = options.onScreenShare ? options.onScreenShare(screenOptions) : screenOptions;\n\n                if (screenOptions.resolution) {\n                    assert.isNumber(screenOptions.resolution, 'clientOptions.resolution');\n                }\n\n                if (screenOptions.frameRate) {\n                    assert.isNumber(screenOptions.frameRate, 'screenOptions.frameRate');\n                }\n\n                if (screenOptions.aspectRatio) {\n                    assert.isStringNotEmpty(screenOptions.aspectRatio, 'screenOptions.aspectRatio');\n                }\n\n                return _.assign({resolution: screenOptions.resolution}, screenOptions);\n            }\n        });\n\n        userMediaResolver.getUserMedia(options.mediaConstraints, function(error, response) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (options.onResolveMedia) {\n                options.onResolveMedia(response.options);\n            }\n\n            callback(null, _.assign({status: 'ok'}, response));\n        });\n    }\n\n    function getStreamingTokenAndPublish(userMediaOrUri, options, cleanUpUserMediaOnStop, callback) {\n        var that = this;\n\n        if (options.publishToken) {\n            try {\n                var capabilitiesFromPublishToken = that.parseCapabilitiesFromToken(options.publishToken);\n\n                options.capabilities = capabilitiesFromPublishToken;\n            } catch (e) {\n                return callback(new Error('Bad `publishToken`', e), {status: 'bad-token'});\n            }\n\n            return publishUserMediaOrUri.call(that, options.publishToken, userMediaOrUri, options, cleanUpUserMediaOnStop, callback);\n        }\n\n        if (options.streamToken) {\n            try {\n                var capabilitiesFromStreamToken = that.parseCapabilitiesFromToken(options.streamToken);\n\n                options.capabilities = capabilitiesFromStreamToken;\n            } catch (e) {\n                return callback(new Error('Bad `streamToken`', e), {status: 'bad-token'});\n            }\n\n            return publishUserMediaOrUri.call(that, options.streamToken, userMediaOrUri, options, cleanUpUserMediaOnStop, callback);\n        }\n\n        if (options.capabilities) {\n            assert.isArray(options.capabilities, 'options.capabilities');\n        }\n\n        that.waitForOnline(function(error) {\n            if (error) {\n                that._logger.error('[%s] Failed to create stream token for publishing after waiting for online status', this, error);\n\n                return callback(error);\n            }\n\n            var sessionId = that._pcastObservable.getValue().getProtocol().getSessionId();\n            var isEgress = _.includes(options.capabilities, 'egress');\n            var generateStreamToken = _.bind(that._adminApiProxyClient.createStreamTokenForPublishing, that._adminApiProxyClient, sessionId, options.capabilities);\n\n            if (isEgress) {\n                generateStreamToken = _.bind(that._adminApiProxyClient.createStreamTokenForPublishingToExternal, that._adminApiProxyClient, sessionId, options.capabilities, options.streamId);\n            }\n\n            that._logger.info('[%s] [%s] Creating stream token for publishing', this, sessionId);\n\n            generateStreamToken(function(error, response) {\n                if (error) {\n                    that._logger.error('[%s] [%s] Failed to create stream token for publishing', this, sessionId, error);\n\n                    return callback(error);\n                }\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('[%s] [%s] Failed to create stream token for publishing with status [%s]', this, sessionId, response.status);\n\n                    return callback(null, response);\n                }\n\n                publishUserMediaOrUri.call(that, response.streamToken, userMediaOrUri, options, cleanUpUserMediaOnStop, callback);\n            });\n        }, options.isContinuation);\n    }\n\n    function publishUserMediaOrUri(streamToken, userMediaOrUri, options, cleanUpUserMediaOnStop, callback) {\n        var that = this;\n        var hasAlreadyAttachedMedia = false;\n        var cachedPublisher = null;\n\n        if (options.tags) {\n            assert.isArray(options.tags, 'options.tags');\n        }\n\n        if (options.connectOptions) {\n            assert.isArray(options.connectOptions, 'options.connectOptions');\n        }\n\n        var publishCallback = function publishCallback(pcast, status, publisher) {\n            var retryPublisher = function retryPublisher(reason) {\n                var optionsWithToken = _.assign({\n                    streamToken: streamToken,\n                    isContinuation: true\n                }, options);\n\n                that._logger.warn('[%s] Retrying publisher after failure with reason [%s]', this, reason);\n\n                that._ignoredStreamEnds[publisher.getStreamId()] = true;\n\n                if (reason === 'camera-track-failure') {\n                    publisher.stop(reason, false);\n                    that.publish(options, callback);\n                } else {\n                    publisher.stop(reason, true);\n                    getStreamingTokenAndPublish.call(that, userMediaOrUri, optionsWithToken, cleanUpUserMediaOnStop, callback);\n                }\n            };\n\n            if ((status === unauthorizedStatus && ((options.streamToken || options.publishToken) || !options.authFailure)) || status === 'timeout') {\n                that._logger.info('[%s] Attempting to create new streamToken and re-publish after [%s] response', this, unauthorizedStatus);\n\n                var reAuthOptions = _.assign({\n                    isContinuation: true,\n                    authFailure: true\n                }, options);\n\n                delete reAuthOptions.streamToken;\n                delete reAuthOptions.publishToken;\n\n                return getStreamingTokenAndPublish.call(that, userMediaOrUri, reAuthOptions, cleanUpUserMediaOnStop, callback);\n            }\n\n            if (status !== 'ok') {\n                that._logger.warn('[%s] Failure to publish with status [%s]', this, status);\n\n                if (cachedPublisher) {\n                    that._ignoredStreamEnds[cachedPublisher.getStreamId()] = true;\n                }\n\n                return callback(null, {status: status});\n            }\n\n            delete options.authFailure;\n\n            that._publishers[publisher.getStreamId()] = publisher;\n\n            cachedPublisher = publisher;\n\n            var isPublisher = true;\n            var noopCallback = function() {};\n\n            var publisherEndedCallback = _.bind(onPublisherOrStreamEnd, that, noopCallback, retryPublisher, isPublisher);\n\n            if (options.monitor) {\n                var monitorCallback = _.bind(onMonitorCallback, that, options.monitor.callback, retryPublisher);\n\n                publisher.monitor(options.monitor.options || {}, monitorCallback);\n\n                publisherEndedCallback = _.bind(onPublisherOrStreamEnd, that, options.monitor.callback, retryPublisher, isPublisher);\n            }\n\n            publisher.setPublisherEndedCallback(publisherEndedCallback);\n\n            var expressPublisher = createExpressPublisher.call(that, publisher, options.videoElement, cleanUpUserMediaOnStop);\n\n            if (options.videoElement && !hasAlreadyAttachedMedia) {\n                rtc.attachMediaStream(options.videoElement, userMediaOrUri, function(e) {\n                    if (e) {\n                        that._logger.warn('[%s] [%s] Failed to attach publish media stream to video element.', this, publisher.getStreamId(), e);\n\n                        return;\n                    }\n                });\n\n                hasAlreadyAttachedMedia = true;\n            }\n\n            callback(null, {\n                status: 'ok',\n                publisher: expressPublisher\n            });\n        };\n\n        that.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            that._pcastObservable.getValue().publish(streamToken, userMediaOrUri, publishCallback, options.tags, {connectOptions: options.connectOptions});\n        }, options.isContinuation);\n    }\n\n    function subscribeToStream(streamToken, options, callback) {\n        var that = this;\n        var cachedSubsciber = null;\n\n        var handleSubscribe = function(pcast, status, subscriber) {\n            var retrySubscriber = function retrySubscriber(reason) {\n                var retryOptions = _.assign({isContinuation: true}, options);\n\n                that._ignoredStreamEnds[subscriber.getStreamId()] = true;\n\n                subscriber.stop(reason);\n\n                that._logger.warn('[%s] [%s] Stream failure occurred with reason [%s]. Attempting to recover from failure.', this, options.streamId, reason);\n\n                subscribeToStream.call(that, streamToken, retryOptions, callback);\n            };\n\n            if (((!options.skipRetryOnUnauthorized && status === unauthorizedStatus && (options.streamToken || !options.authFailure)) || status === 'timeout') && that._adminApiProxyClient) {\n                that._logger.info('[%s] [%s] Attempting to create new streamToken and re-subscribe after [%s] response', this, options.streamId, unauthorizedStatus);\n\n                var reAuthOptions = _.assign({\n                    isContinuation: true,\n                    authFailure: true\n                }, options);\n\n                delete reAuthOptions.streamToken;\n\n                return that.subscribe(reAuthOptions, callback);\n            }\n\n            if (status === 'streaming-not-ready') {\n                that._logger.warn('[%s] Failure to subscribe with status [%s]. Try again in a few seconds.', this, status);\n\n                return callback(null, {\n                    status: status,\n                    retry: _.bind(retrySubscriber, that, status)\n                });\n            }\n\n            if (status !== 'ok') {\n                that._logger.warn('[%s] Failure to subscribe with status [%s]', this, status);\n\n                if (cachedSubsciber) {\n                    that._ignoredStreamEnds[cachedSubsciber.getStreamId()] = true;\n                }\n\n                return callback(null, {status: status});\n            }\n\n            delete options.authFailure;\n\n            var renderer;\n\n            cachedSubsciber = subscriber;\n\n            if (options.videoElement) {\n                renderer = subscriber.createRenderer();\n\n                renderer.start(options.videoElement);\n            }\n\n            var isPublisher = false;\n            var noopCallback = _.noop;\n            var subscriberEndedCallback = _.bind(onPublisherOrStreamEnd, that, noopCallback, retrySubscriber, isPublisher);\n\n            if (options.monitor) {\n                var monitorCallback = _.bind(onMonitorCallback, that, options.monitor.callback, retrySubscriber);\n\n                subscriber.monitor(options.monitor.options || {}, monitorCallback);\n\n                subscriberEndedCallback = _.bind(onPublisherOrStreamEnd, that, options.monitor.callback, retrySubscriber, isPublisher);\n            }\n\n            subscriber.setStreamEndedCallback(subscriberEndedCallback);\n\n            var expressSubscriber = createExpressSubscriber.call(that, subscriber, renderer);\n            var subscribeResponse = {\n                status: 'ok',\n                mediaStream: expressSubscriber\n            };\n\n            subscriber.setStreamErrorCallback(function(playerRenderer, errorType, error) {\n                if (errorType === 'real-time' && error.message === 'connection-timeout') {\n                    return retrySubscriber.call(that, error.message);\n                }\n\n                if (errorType === 'shaka' && error.severity !== shakaEnums.errorSeverity.critical.id) {\n                    return; // Ignore error\n                }\n\n                var RECOVERABLE = 1;\n\n                if (errorType === 'phenix-player' && error.severity === RECOVERABLE) {\n                    that._logger.warn('[%s] [%s] Recoverable error occurred while playing stream with Express API. Attempting to subscribe again.', this, expressSubscriber.getStreamId(), error);\n\n                    var reAuthOptions = _.assign({isContinuation: true}, options);\n\n                    delete reAuthOptions.streamToken;\n\n                    return that.subscribe(reAuthOptions, callback);\n                }\n\n                that._logger.warn('[%s] [%s] Error occurred while playing stream with Express API. Stopping stream.', this, expressSubscriber.getStreamId(), error);\n\n                expressSubscriber.stop();\n\n                return callback(error);\n            });\n\n            if (renderer) {\n                subscribeResponse.renderer = renderer;\n            }\n\n            callback(null, subscribeResponse);\n        };\n\n        that.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            var subscriberOptions = _.clone(options.subscriberOptions || {});\n\n            if (options.streamId) {\n                subscriberOptions.originStreamId = options.streamId;\n            }\n\n            that._pcastObservable.getValue().subscribe(streamToken, handleSubscribe, subscriberOptions);\n        }, options.isContinuation);\n    }\n\n    function createExpressPublisher(publisher, videoElement, cleanUpUserMediaOnStop) {\n        var that = this;\n        var publisherStop = _.bind(publisher.stop, publisher);\n\n        publisher.stop = function(reason, isInternal) {\n            that._logger.info('[%s] [%s] Stopping publisher with reason [%s]', that, publisher.getStreamId(), reason);\n\n            publisherStop(reason);\n\n            if (videoElement) {\n                videoElement.src = '';\n                videoElement.srcObject = null;\n            }\n\n            if (cleanUpUserMediaOnStop && publisher.getStream() && !isInternal) {\n                var nativeMediaStream = publisher.getStream();\n\n                if (nativeMediaStream) {\n                    nativeMediaStream.getTracks().forEach(function(track) {\n                        track.stop();\n                    });\n                }\n            }\n        };\n\n        publisher.enableAudio = function() {\n            return setStreamAudioTracksState.call(that, publisher, true);\n        };\n\n        publisher.disableAudio = function() {\n            return setStreamAudioTracksState.call(that, publisher, false);\n        };\n\n        publisher.enableVideo = function() {\n            return setStreamVideoTracksState.call(that, publisher, true);\n        };\n\n        publisher.disableVideo = function() {\n            return setStreamVideoTracksState.call(that, publisher, false);\n        };\n\n        // Publisher Ended Callback handled with normal callback route for express\n        publisher.setPublisherEndedCallback = function() {};\n\n        return publisher;\n    }\n\n    function createExpressSubscriber(subscriber, renderer) {\n        var that = this;\n        var subscriberStop = _.bind(subscriber.stop, subscriber);\n\n        subscriber.stop = function(reason) {\n            that._logger.info('[%s] [%s] Stopping subscriber with reason [%s]', that, subscriber, reason);\n\n            if (renderer) {\n                renderer.stop(reason);\n            }\n\n            subscriberStop(reason);\n        };\n\n        subscriber.enableAudio = function() {\n            return setStreamAudioTracksState(subscriber.getStream(), true);\n        };\n\n        subscriber.disableAudio = function() {\n            return setStreamAudioTracksState(subscriber.getStream(), false);\n        };\n\n        subscriber.enableVideo = function() {\n            return setStreamVideoTracksState(subscriber.getStream(), true);\n        };\n\n        subscriber.disableVideo = function() {\n            return setStreamVideoTracksState(subscriber.getStream(), false);\n        };\n\n        // Stream Ended Callback handled with normal callback route for express\n        subscriber.setStreamEndedCallback = function() {};\n\n        return subscriber;\n    }\n\n    function setStreamAudioTracksState(publisher, newState) {\n        var pcast = this.getPCast();\n\n        if (!pcast) {\n            return;\n        }\n\n        var streamId = publisher.getStreamId();\n        var peerConnectionDescription = pcast.getRemoteDescriptionSdp(streamId);\n\n        if (!peerConnectionDescription) {\n            return;\n        }\n\n        var stream = publisher.getStream();\n        var audioIndex = peerConnectionDescription.lastIndexOf('m=audio');\n\n        if (audioIndex < 0) {\n            return;\n        }\n\n        var endIndex = peerConnectionDescription.lastIndexOf('m=video');\n\n        if (endIndex < audioIndex) {\n            endIndex = peerConnectionDescription.length;\n        }\n\n        var trackConfiguration = peerConnectionDescription.substring(\n            audioIndex,\n            endIndex\n        );\n\n        if (trackConfiguration.includes('a=inactive')) {\n            return;\n        }\n\n        if (!stream) {\n            return;\n        }\n\n        setTracksEnabled(stream.getAudioTracks(), newState);\n\n        return newState;\n    }\n\n    function setStreamVideoTracksState(publisher, newState) {\n        var pcast = this.getPCast();\n\n        if (!pcast) {\n            return;\n        }\n\n        var streamId = publisher.getStreamId();\n        var peerConnectionDescription = pcast.getRemoteDescriptionSdp(streamId);\n\n        if (!peerConnectionDescription) {\n            return;\n        }\n\n        var stream = publisher.getStream();\n        var videoIndex = peerConnectionDescription.lastIndexOf('m=video');\n\n        if (videoIndex < 0) {\n            return;\n        }\n\n        var endIndex = peerConnectionDescription.lastIndexOf('m=audio');\n\n        if (endIndex < videoIndex) {\n            endIndex = peerConnectionDescription.length;\n        }\n\n        var trackConfiguration = peerConnectionDescription.substring(\n            videoIndex,\n            endIndex\n        );\n\n        if (trackConfiguration.includes('a=inactive')) {\n            return;\n        }\n\n        if (!stream) {\n            return;\n        }\n\n        setTracksEnabled(stream.getVideoTracks(), newState);\n\n        return newState;\n    }\n\n    function setTracksEnabled(tracks, enabled) {\n        assert.isArray(tracks, 'tracks');\n\n        _.forEach(tracks, function(track) {\n            track.updateState(enabled);\n        });\n    }\n\n    function onMonitorCallback(callback, retry, stream, reason, monitorEvent) { // eslint-disable-line no-unused-vars\n        switch (reason) {\n        case 'camera-track-failure':\n        case 'client-side-failure':\n            callback(null, _.assign({\n                status: reason,\n                retry: _.bind(retry, null, reason)\n            }, monitorEvent));\n\n            // Handle failure event, redo stream\n            break;\n        default:\n            // No failure has occurred, handle monitor event\n            break;\n        }\n    }\n\n    function onPublisherOrStreamEnd(monitorCallback, retry, isPublisher, publisherOrStream, reason, description) {\n        var response = {\n            status: 'stream-ended',\n            reason: reason,\n            description: description\n        };\n\n        if (this._ignoredStreamEnds[publisherOrStream.getStreamId()]) {\n            this._logger.info('[%s] Ignoring stream end due to recovery in progress [%s]', this, publisherOrStream.getStreamId());\n\n            return;\n        }\n\n        switch (reason) {\n        case 'egress-setup-failed': // Bad input params\n        case 'ended': // Normal operation\n        case 'censored': // Forced to stop\n            var endedResponse = {\n                status: reason,\n                reason: reason,\n                description: description\n            };\n\n            if (isPublisher) {\n                endedResponse.publisher = publisherOrStream;\n            } else {\n                endedResponse.mediaStream = publisherOrStream;\n            }\n\n            return monitorCallback(null, endedResponse);\n        case 'custom':\n            // Client ended publisher, do nothing\n            return monitorCallback(null, response);\n        case 'egress-failed':\n        case 'capacity':\n            // Don't inform the client, attempt to re-publish automatically after backoff\n            setTimeout(function() {\n                if (this._disposed) {\n                    return;\n                }\n\n                return retry(reason);\n            }, capacityBackoffTimeout);\n\n            return;\n        case 'failed':\n        case 'maintenance':\n        case 'overload':\n            // Don't inform the client, attempt to re-publish automatically\n            return retry(reason);\n        case 'app-background':\n        default:\n            // Give client option to re-publish\n            response.retry = retry;\n\n            return monitorCallback(null, response);\n        }\n    }\n\n    return PCastExpress;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-http',\n    'phenix-web-disposable'\n], function(_, assert, http, disposable) {\n    'use strict';\n\n    var networkUnavailableCode = 0;\n    var requestMaxTimeout = 20000;\n    var defaultRequestOptions = {\n        timeout: requestMaxTimeout,\n        retryOptions: {\n            backoff: 1.5,\n            delay: 1000,\n            maxAttempts: 3,\n            additionalRetryErrorCodes: [networkUnavailableCode]\n        }\n    };\n    var authenticationDataLocations = {\n        body: {\n            id: 1,\n            name: 'body'\n        },\n        header: {\n            id: 2,\n            name: 'header'\n        }\n    };\n    var defaultEndpointPaths = {\n        createStreamTokenPath: '/stream',\n        createAuthTokenPath: '/auth'\n    };\n    var requestTypes = {\n        auth: {\n            id: 1,\n            name: 'auth'\n        },\n        stream: {\n            id: 2,\n            name: 'stream'\n        }\n    };\n\n    function AdminApiProxyClient() {\n        this._requestHandler = null;\n        this._backendUri = '';\n        this._endpointPaths = defaultEndpointPaths;\n        this._authenticationData = {};\n        this._authenticationDataLocationInPayload = authenticationDataLocations.body.name;\n        this._disposables = new disposable.DisposableList();\n    }\n\n    AdminApiProxyClient.prototype.dispose = function() {\n        return this._disposables.dispose();\n    };\n\n    AdminApiProxyClient.prototype.toString = function() {\n        return 'AdminApiProxyClient[' +\n            'customRequestHandler=' + (!!this._requestHandler).toString() +\n            ',backendUri=' + this._backendUri +\n            ',authenticationDataLocationInPayload=' + this._authenticationDataLocationInPayload +\n            ',customEndpointPaths=' + (this._endpointPaths === defaultEndpointPaths).toString() +\n            ',customAuthenticationData=' + (_.keys(this._authenticationData).length > 0).toString() + ']';\n    };\n\n    AdminApiProxyClient.prototype.getBackendUri = function() {\n        return this._backendUri;\n    };\n\n    AdminApiProxyClient.prototype.setBackendUri = function(backendUri) {\n        assert.isString(backendUri, 'backendUri');\n\n        this._backendUri = backendUri;\n    };\n\n    AdminApiProxyClient.prototype.getEndpointPaths = function() {\n        return _.assign({}, this._endpointPaths);\n    };\n\n    AdminApiProxyClient.prototype.setEndpointPaths = function(endpointPaths) {\n        assert.isObject(endpointPaths, 'endpointPaths');\n\n        if (endpointPaths.createStreamTokenPath) {\n            assert.isStringNotEmpty(endpointPaths.createStreamTokenPath, 'endpointPaths.createStreamTokenPath');\n        }\n\n        if (endpointPaths.createAuthTokenPath) {\n            assert.isStringNotEmpty(endpointPaths.createAuthTokenPath, 'endpointPaths.createAuthTokenPath');\n        }\n\n        this._endpointPaths = _.assign({}, defaultEndpointPaths, endpointPaths);\n    };\n\n    AdminApiProxyClient.prototype.getAuthenticationData = function() {\n        return _.assign({}, this._authenticationData);\n    };\n\n    AdminApiProxyClient.prototype.setAuthenticationData = function(authenticationData) {\n        assert.isObject(authenticationData, 'authenticationData');\n\n        this._authenticationData = authenticationData;\n    };\n\n    AdminApiProxyClient.prototype.getAuthenticationDataLocationInPayload = function() {\n        return this._authenticationDataLocationInPayload;\n    };\n\n    AdminApiProxyClient.prototype.setAuthenticationDataLocationInPayload = function(authenticationDataLocationInPayload) {\n        assert.isValidType(authenticationDataLocationInPayload, authenticationDataLocations, 'authenticationDataLocationInPayload');\n\n        this._authenticationDataLocationInPayload = authenticationDataLocationInPayload;\n    };\n\n    AdminApiProxyClient.prototype.getRequestHandler = function() {\n        return this._requestHandler;\n    };\n\n    AdminApiProxyClient.prototype.setRequestHandler = function(callback) {\n        assert.isFunction(callback, 'callback');\n\n        if (this._backendUri) {\n            throw new Error('Conflicting parameter [backendUri]');\n        }\n\n        if (_.keys(this._authenticationData).length > 0) {\n            throw new Error('Conflicting parameter [authenticationData]');\n        }\n\n        if (this._authenticationDataLocationInPayload !== authenticationDataLocations.body.name) {\n            throw new Error('Conflicting parameter [authenticationDataLocationInPayload]');\n        }\n\n        if (this._endpointPaths !== defaultEndpointPaths) {\n            throw new Error('Conflicting parameter [endpointPaths]');\n        }\n\n        this._requestHandler = callback;\n    };\n\n    AdminApiProxyClient.prototype.createAuthenticationToken = function createAuthenticationToken(callback) {\n        if (this._requestHandler) {\n            return this._requestHandler(requestTypes.auth.name, {}, _.bind(handleOverrideRequestResponse, this, requestTypes.auth.name, callback));\n        }\n\n        if (!this._backendUri) {\n            callback(null, {status: 'unauthorized'});\n\n            return;\n        }\n\n        var requestWithoutCallback = bindAuthDataAndPrepareRequest.call(this, http.postWithRetry, http, this._backendUri + this._endpointPaths.createAuthTokenPath, {}, defaultRequestOptions);\n\n        return requestWithTimeout.call(this, requestWithoutCallback, callback);\n    };\n\n    AdminApiProxyClient.prototype.createStreamTokenForPublishing = function createStreamTokenForPublishing(sessionId, capabilities, callback) {\n        assert.isStringNotEmpty(sessionId, 'sessionId');\n        assert.isObject(capabilities, 'capabilities');\n\n        var data = {\n            sessionId: sessionId,\n            capabilities: capabilities\n        };\n\n        if (this._requestHandler) {\n            return this._requestHandler(requestTypes.stream.name, data, _.bind(handleOverrideRequestResponse, this, requestTypes.stream.name, callback));\n        }\n\n        if (!this._backendUri) {\n            callback(null, {status: 'unauthorized'});\n\n            return;\n        }\n\n        var requestWithoutCallback = bindAuthDataAndPrepareRequest.call(this, http.postWithRetry, http, this._backendUri + this._endpointPaths.createStreamTokenPath, data, defaultRequestOptions);\n\n        return requestWithTimeout.call(this, requestWithoutCallback, callback);\n    };\n\n    AdminApiProxyClient.prototype.createStreamTokenForPublishingToExternal = function createStreamTokenForPublishingToExternal(sessionId, capabilities, streamId, callback) {\n        this.createStreamTokenForSubscribing(sessionId, capabilities, streamId, null, callback);\n    };\n\n    AdminApiProxyClient.prototype.createStreamTokenForSubscribing = function createStreamTokenForSubscribing(sessionId, capabilities, streamId, alternateStreamIds, callback) {\n        assert.isStringNotEmpty(sessionId, 'sessionId');\n        assert.isObject(capabilities, 'capabilities');\n\n        if (!_.isNullOrUndefined(alternateStreamIds)) {\n            assert.isArray(alternateStreamIds, 'additionalStreamIds');\n\n            _.forEach(alternateStreamIds, function(alternateOriginStreamId) {\n                assert.isStringNotEmpty(alternateOriginStreamId, 'alternateOriginStreamId');\n            });\n        }\n\n        var data = {\n            sessionId: sessionId,\n            capabilities: capabilities,\n            originStreamId: streamId\n        };\n\n        if (alternateStreamIds && alternateStreamIds.length > 0) {\n            data.alternateOriginStreamIds = alternateStreamIds;\n        }\n\n        if (this._requestHandler) {\n            return this._requestHandler(requestTypes.stream.name, data, _.bind(handleOverrideRequestResponse, this, requestTypes.stream.name, callback));\n        }\n\n        if (!this._backendUri) {\n            callback(null, {status: 'unauthorized'});\n\n            return;\n        }\n\n        var requestWithoutCallback = bindAuthDataAndPrepareRequest.call(this, http.postWithRetry, http, this._backendUri + this._endpointPaths.createStreamTokenPath, data, defaultRequestOptions);\n\n        return requestWithTimeout.call(this, requestWithoutCallback, callback);\n    };\n\n    function requestWithTimeout(requestWithoutCallback, callback) {\n        var requestTimeoutId = null;\n        var requestDisposable = requestWithoutCallback(_.bind(handleResponse, this, function(error, response) {\n            clearTimeout(requestTimeoutId);\n\n            switch (_.get(error, ['code'])) {\n            case 401:\n                return callback(null, {status: 'unauthorized'});\n            case 404:\n                return callback(null, {status: 'origin-not-found'});\n            case 410:\n                return callback(null, {status: 'origin-ended'});\n            default:\n                return callback(error, response);\n            }\n        }));\n\n        requestTimeoutId = setTimeout(function() {\n            requestDisposable.dispose();\n            callback(new Error('timeout'));\n        }, requestMaxTimeout);\n\n        this._disposables.add(requestDisposable);\n        this._disposables.add(new disposable.Disposable(function() {\n            clearTimeout(requestTimeoutId);\n        }));\n\n        return requestDisposable;\n    }\n\n    function bindAuthDataAndPrepareRequest(method, scope, uri, data, options) {\n        switch (this._authenticationDataLocationInPayload) {\n        case authenticationDataLocations.body.name:\n            data = appendAuthDataTo.call(this, data);\n\n            break;\n        case authenticationDataLocations.header.name:\n            options = appendAuthHeaders.call(this, options);\n\n            break;\n        default:\n            throw new Error('Unsupported Authentication Mode ' + this._authenticationDataLocationInPayload);\n        }\n\n        return _.bind(method, scope, uri, JSON.stringify(data), options);\n    }\n\n    function appendAuthDataTo(data) {\n        return _.assign({}, data, this._authenticationData);\n    }\n\n    function appendAuthHeaders(options) {\n        if (options.headers) {\n            options.headers = _.assign({}, this._authenticationData, options.headers);\n\n            return options;\n        }\n\n        return _.assign({}, {headers: this._authenticationData}, options);\n    }\n\n    function handleResponse(callback, error, response) {\n        if (error) {\n            return callback(error, {});\n        }\n\n        var res = JSON.parse(response.data);\n\n        if (res.status !== 'ok') {\n            return callback(null, {status: res.status || 'status-code-missing'});\n        }\n\n        return callback(null, res);\n    }\n\n    function handleOverrideRequestResponse(type, callback, error, token) {\n        if (!token || error) {\n            return callback(error, {status: 'failed'});\n        }\n\n        var response = {status: 'ok'};\n\n        switch(type) {\n        case requestTypes.auth.name:\n            response.authenticationToken = token;\n\n            break;\n        case requestTypes.stream.name:\n            response.streamToken = token;\n\n            break;\n        default:\n            throw new Error('Unsupported request type ' + type);\n        }\n\n        return callback(error, response);\n    }\n\n    return AdminApiProxyClient;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    './PCastExpress',\n    '../room/RoomService',\n    './MemberSelector',\n    '../room/Stream',\n    '../room/room.json',\n    '../room/member.json',\n    '../room/stream.json',\n    '../room/track.json',\n    '../streaming/FeatureDetector'\n], function(_, assert, observable, disposable, PCastExpress, RoomService, MemberSelector, Stream, roomEnums, memberEnums, memberStreamEnums, trackEnums, FeatureDetector) {\n    'use strict';\n\n    var defaultStreamWildcardTokenRefreshInterval = 300000;\n    var streamingTypeCapabilities = ['streaming', 'rtmp'];\n\n    function RoomExpress(options) {\n        assert.isObject(options, 'options');\n\n        if (options.pcastExpress) {\n            assert.isObject(options.pcastExpress, 'options.pcastExpress');\n        }\n\n        this._pcastExpress = options.pcastExpress || new PCastExpress(options);\n        this._shouldDisposeOfPCastExpress = !options.pcastExpress;\n        this._roomServices = {};\n        this._externalPublishers = [];\n        this._roomServicePublishers = {};\n        this._activeRoomServices = [];\n        this._publisherDisposables = {};\n        this._logger = this._pcastExpress.getPCast().getLogger();\n        this._disposables = new disposable.DisposableList();\n        this._disposed = false;\n        this._featureDetector = new FeatureDetector(options.features);\n        this._isHandlingTrackChange = false;\n        this._handleStateChangeTimeOut = null;\n\n        var that = this;\n\n        this._pcastExpress.getPCastObservable().subscribe(function(pcast) {\n            if (!pcast) {\n                return;\n            }\n\n            that._logger.info('Resetting Room Express after change in pcast.');\n\n            that._pcastExpress.waitForOnline(function() {\n                var currentPCast = that._pcastExpress.getPCastObservable().getValue();\n\n                if (currentPCast !== pcast) {\n                    return;\n                }\n\n                _.forOwn(that._roomServices, function(roomService) {\n                    roomService.setPCast(pcast);\n                });\n            });\n        });\n    }\n\n    RoomExpress.prototype.dispose = function dispose() {\n        this._disposed = true;\n\n        disposeOfRoomServices.call(this);\n\n        if (this._shouldDisposeOfPCastExpress) {\n            this._pcastExpress.dispose();\n        }\n\n        this._disposables.dispose();\n\n        this._logger.info('Disposed Room Express Instance');\n    };\n\n    RoomExpress.prototype.getPCastExpress = function getPCastExpress() {\n        return this._pcastExpress;\n    };\n\n    // Responsible for creating room. Returns immutable room\n    RoomExpress.prototype.createRoom = function createRoom(options, callback) {\n        assert.isFunction(callback, 'callback');\n        assert.isObject(options.room, 'options.room');\n        assert.isStringNotEmpty(options.room.name, 'options.room.name');\n        assert.isStringNotEmpty(options.room.type, 'options.room.type');\n\n        if (options.room.description) {\n            assert.isStringNotEmpty(options.room.description, 'options.room.description');\n        }\n\n        var roomDescription = options.room.description || getDefaultRoomDescription(options.room.type);\n\n        createRoomService.call(this, null, null, function(error, roomServiceResponse) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (roomServiceResponse.status !== 'ok') {\n                return callback(null, roomServiceResponse);\n            }\n\n            var roomService = roomServiceResponse.roomService;\n            var roomToCreate = _.assign({}, options.room);\n\n            if (!roomToCreate.description) {\n                roomToCreate.description = roomDescription;\n            }\n\n            roomService.createRoom(roomToCreate, function(error, roomResponse) {\n                if (error) {\n                    return callback(error);\n                }\n\n                // Don't return room service. Not in room. Room returned is immutable\n                roomService.stop('create');\n\n                return callback(null, roomResponse);\n            });\n        });\n    };\n\n    RoomExpress.prototype.joinRoom = function joinRoom(options, joinRoomCallback, membersChangedCallback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(joinRoomCallback, 'joinRoomCallback');\n        assert.isStringNotEmpty(options.role, 'options.role');\n\n        if (membersChangedCallback) {\n            assert.isFunction(membersChangedCallback, 'membersChangedCallback');\n        }\n\n        if (options.screenName) {\n            assert.isStringNotEmpty(options.screenName, 'options.screenName');\n        }\n\n        if (options.roomId) {\n            assert.isStringNotEmpty(options.roomId, 'options.roomId');\n        }\n\n        if (options.alias) {\n            assert.isStringNotEmpty(options.alias, 'options.alias');\n        }\n\n        if (options.streams) {\n            assert.isArray(options.streams, 'options.streams');\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n\n            if (options.roomId) {\n                this._logger.warn('Trying to join room with both streamToken and roomId. Please only use streamToken.');\n            }\n\n            if (options.alias) {\n                this._logger.warn('Trying to join room with both streamToken and alias. Please only use streamToken.');\n            }\n\n            var roomId = this._pcastExpress.parseRoomOrChannelIdFromToken(options.streamToken);\n            var alias = this._pcastExpress.parseRoomOrChannelAliasFromToken(options.streamToken);\n\n            if (roomId) {\n                options.roomId = roomId;\n                this._logger.info('Room ID is set to [%s] from streamToken [%s]', roomId, options.streamToken);\n            }\n\n            if (alias) {\n                options.alias = alias;\n                this._logger.info('Alias is set to [%s] from streamToken [%s]', alias, options.streamToken);\n            }\n        }\n\n        var that = this;\n        var joinRoomWithPCast = function(pcast) {\n            if (!pcast) {\n                return;\n            }\n\n            joinRoomWithOptions.call(that, options, function(error, response) {\n                var joinRoomResponse = response;\n\n                if (joinRoomResponse && joinRoomResponse.roomService) {\n                    var leaveRoom = joinRoomResponse.roomService.leaveRoom;\n\n                    joinRoomResponse.roomService.leaveRoom = function(callback, isForceLeaveRoom) {\n                        if (subscription && pcast.getObservableStatus() !== 'offline') {\n                            subscription.dispose();\n                        }\n\n                        leaveRoom(callback, isForceLeaveRoom);\n                    };\n                }\n\n                joinRoomCallback(error, response);\n            }, membersChangedCallback);\n        };\n\n        if (this._pcastExpress.getPCastObservable()) {\n            return joinRoomWithPCast(this._pcastExpress.getPCastObservable());\n        }\n\n        var subscription = this._pcastExpress.getPCastObservable().subscribe(joinRoomWithPCast);\n    };\n\n    RoomExpress.prototype.publishToRoom = function publishToRoom(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n        assert.isObject(options.room, 'options.room');\n\n        var adminApi = this._pcastExpress.getAdminAPI();\n\n        if (options.streamUri) {\n            assert.isStringNotEmpty(options.streamUri, 'options.streamUri');\n        } else if (options.mediaConstraints) {\n            assert.isObject(options.mediaConstraints, 'options.mediaConstraints');\n        } else {\n            assert.isObject(options.userMediaStream, 'options.userMediaStream');\n        }\n\n        if (options.videoElement) {\n            assert.isObject(options.videoElement, 'options.videoElement');\n        }\n\n        if (options.screenName) {\n            assert.isStringNotEmpty(options.screenName, 'options.screenName');\n        }\n\n        if (options.tags) {\n            assert.isArray(options.tags, 'options.tags');\n        }\n\n        if (options.streamInfo) {\n            assert.isObject(options.streamInfo, 'options.streamInfo');\n        }\n\n        if (options.streamToken) {\n            assert.isStringNotEmpty(options.streamToken, 'options.streamToken');\n            this._logger.warn('`options.streamToken` is deprecated please use `options.publishToken`.');\n        }\n\n        if (options.publishToken && options.capabilities) {\n            throw new Error('Do not pass `options.capabilities` with `options.publishToken`. `options.publishToken` should include capabilities in the token.');\n        }\n\n        if (options.publishToken && options.streamToken) {\n            throw new Error('Do not pass `options.streamToken` with `options.publishToken`. Please use `options.publishToken`.');\n        }\n\n        if (options.streamToken && options.capabilities) {\n            throw new Error('Do not pass `options.capabilities` with `options.streamToken`. `options.streamToken` should include capabilities in the token.');\n        }\n\n        if (!options.streamToken && !options.publishToken && !adminApi) {\n            throw new Error('Pass `options.publishToken`, or set adminApiProxyClient on initiating room express');\n        }\n\n        if (options.viewerStreamSelectionStrategy) {\n            assert.isStringNotEmpty(options.viewerStreamSelectionStrategy, 'options.viewerStreamSelectionStrategy');\n        }\n\n        if (options.capabilities) {\n            assert.isArray(options.capabilities, 'options.capabilities');\n        }\n\n        if (_.isUndefined(options.enableWildcardCapability)) {\n            options.enableWildcardCapability = !(options.publishToken || options.streamToken);\n        }\n\n        assert.isValidType(options.streamType, memberStreamEnums.types, 'options.streamType');\n        assert.isValidType(options.memberRole, memberEnums.roles, 'options.memberRole');\n        assert.isBoolean(options.enableWildcardCapability, 'options.enableWildcardCapability');\n\n        var that = this;\n        var screenName = options.screenName || _.uniqueId();\n        var roomId = options.room.roomId;\n        var alias = options.room.alias;\n\n        if (options.publishToken || options.streamToken) {\n            roomId = this._pcastExpress.parseRoomOrChannelIdFromToken(options.publishToken || options.streamToken);\n            alias = this._pcastExpress.parseRoomOrChannelAliasFromToken(options.publishToken || options.streamToken);\n\n            this._logger.info('[%s] [%s] RoomId and Alias read from token [%s]', roomId, alias, options.publishToken || options.streamToken);\n        }\n\n        var activeRoomService = findActiveRoom.call(that, roomId, alias);\n\n        var publishToActiveRoom = function publishToActiveRoom(room, joinRoomResponse) {\n            var publishOptions = _.assign({\n                monitor: {\n                    callback: _.bind(monitorSubsciberOrPublisher, that, callback),\n                    options: {conditionCountForNotificationThreshold: 8}\n                },\n                streamInfo: {}\n            }, options);\n\n            if (room.getObservableType().getValue() === roomEnums.types.channel.name) {\n                publishOptions.tags = ['channelId:' + room.getRoomId(), 'channelAlias:' + room.getObservableAlias().getValue()].concat(publishOptions.tags || []);\n            } else {\n                publishOptions.tags = ['roomId:' + room.getRoomId(), 'roomAlias:' + room.getObservableAlias().getValue()].concat(publishOptions.tags || []);\n            }\n\n            if (options.streamUri) {\n                var remoteOptions = _.assign({connectOptions: []}, publishOptions);\n                var hasRoomConnectOptions = _.find(remoteOptions.connectOptions, function(option) {\n                    return _.startsWith(option, 'room-id');\n                });\n\n                if (!hasRoomConnectOptions) {\n                    remoteOptions.connectOptions = remoteOptions.connectOptions.concat([\n                        'room-id=' + room.getRoomId(),\n                        'member-role=' + options.memberRole,\n                        'member-stream-type=' + options.streamType,\n                        'screen-name=' + screenName\n                    ]);\n                }\n\n                if (options.enableWildcardCapability) {\n                    remoteOptions.connectOptions.concat([\n                        'member-stream-token-type=Wildcard',\n                        'member-stream-token-refresh-interval=' + defaultStreamWildcardTokenRefreshInterval\n                    ]);\n                }\n\n                var callbackWithNoRoomService = function(error, response) {\n                    callback(error, response ? _.assign({roomService: null}, response) : response);\n                };\n\n                return that._pcastExpress.publishRemote(remoteOptions, callbackWithNoRoomService);\n            }\n\n            var callbackWithRoomService = function(error, response) {\n                callback(error, response ? _.assign({roomService: joinRoomResponse.roomService}, response) : response);\n            };\n\n            publishAndUpdateSelf.call(that, publishOptions, room, callbackWithRoomService);\n        };\n\n        if (activeRoomService) {\n            var activeRoom = activeRoomService.getObservableActiveRoom().getValue();\n\n            publishToActiveRoom(activeRoom, {roomService: activeRoomService});\n\n            return;\n        }\n\n        var joinRoomAsPresenterOptions = _.assign({}, options, {\n            role: memberEnums.roles.audience.name,\n            roomId: roomId,\n            alias: alias\n        });\n\n        joinRoomWithOptions.call(this, joinRoomAsPresenterOptions, function joinRoomCallback(error, joinRoomWithOptionsResponse) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (joinRoomWithOptionsResponse.status !== 'ok') {\n                return callback(null, joinRoomWithOptionsResponse);\n            }\n\n            var activeRoom = joinRoomWithOptionsResponse.roomService.getObservableActiveRoom().getValue();\n            publishToActiveRoom(activeRoom, joinRoomWithOptionsResponse);\n        }, function membersChangedCallback() {\n            return null;\n        });\n    };\n\n    RoomExpress.prototype.publishScreenToRoom = function publishScreenToRoom(options, callback) {\n        var publishScreenOptions = _.assign({mediaConstraints: {screen: true}}, options);\n\n        this.publishToRoom(publishScreenOptions, callback);\n    };\n\n    RoomExpress.prototype.subscribeToMemberStream = function(memberStream, options, callback, defaultFeatureIndex) {\n        var capabilitiesFromStreamToken;\n        var that = this;\n\n        assert.isObject(memberStream, 'memberStream');\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        defaultFeatureIndex = _.isNumber(defaultFeatureIndex) ? defaultFeatureIndex : 0;\n\n        if (options.capabilities) {\n            throw new Error('subscribeToMemberStream options.capabilities is deprecated. Please use the constructor features option');\n        }\n\n        if (options.streamToken) {\n            capabilitiesFromStreamToken = getCapabilitiesFromTokenIfAble.call(that, options.streamToken);\n\n            if (!capabilitiesFromStreamToken) {\n                that._logger.warn('Failed to parse the `streamToken` [%s]', options.streamToken);\n\n                return callback(new Error('Bad `streamToken`'), {status: 'bad-token'});\n            }\n        }\n\n        var streamUri = memberStream.getUri();\n        var streamId = memberStream.getPCastStreamId();\n        var streamInfo = memberStream.getInfo();\n        var isScreen = _.get(streamInfo, ['isScreen'], false);\n        var streamToken = null;\n        var capabilities = streamInfo.capabilities || buildCapabilitiesFromPublisherWildcardTokens(streamUri) || [];\n        var publisherCapabilities = capabilitiesFromStreamToken || capabilities;\n        var preferredFeature = this._featureDetector.getPreferredFeatureFromPublisherCapabilities(publisherCapabilities);\n        var preferredFeatureCapability = FeatureDetector.mapFeatureToPCastCapability(preferredFeature);\n        var subscriberCapabilities = preferredFeatureCapability ? [preferredFeatureCapability] : [];\n        var featureCapabilities = this._featureDetector.getFeaturePCastCapabilities();\n        var isUsingDeprecatedSdk = false;\n\n        if (!streamId) {\n            this._logger.error('Invalid Member Stream. Unable to parse streamId from uri');\n\n            throw new Error('Invalid Member Stream. Unable to parse streamId from uri');\n        }\n\n        // TODO(dy) Remove backward compatibility when all publisher clients adapt to providing capabilities.\n        if (!_.hasIndexOrKey(streamInfo, 'capabilities')) {\n            if (!preferredFeature) {\n                var capability = _.get(featureCapabilities, [defaultFeatureIndex]);\n\n                if (!capability && defaultFeatureIndex >= featureCapabilities.length) {\n                    return callback(null, {status: 'no-supported-features'});\n                }\n\n                subscriberCapabilities = capability ? [capability] : [];\n                preferredFeature = capability ? _.get(FeatureDetector.mapPCastCapabilityToFeatures(capability), [0]) : null;\n            }\n\n            if (!streamInfo.streamTokenForLiveStream && preferredFeatureCapability === 'streaming') {\n                this._logger.warn('Streaming is not available for stream [%].', streamId);\n\n                return callback(null, {status: 'streaming-not-available'});\n            }\n\n            streamToken = parseStreamTokenFromStreamUri(streamUri, subscriberCapabilities);\n            isUsingDeprecatedSdk = true;\n        } else {\n            if (!preferredFeature) {\n                this._logger.warn('Unable to find supported feature. Publisher capabilities [%s]. Requested feature capabilities [%s]', streamInfo.capabilities, featureCapabilities);\n\n                return callback(null, {status: 'unsupported-features'});\n            }\n\n            streamToken = getStreamTokenForFeature(streamUri, preferredFeature);\n        }\n\n        this._logger.info('Subscribing to member stream with feature [%s] and pre-generated token [%s]', preferredFeature, !!streamToken);\n\n        var subscribeOptions = _.assign({}, {\n            streamId: streamId,\n            streamToken: streamToken,\n            capabilities: subscriberCapabilities\n        }, options);\n        var disposables = new disposable.DisposableList();\n\n        subscribeToMemberStream.call(this, subscribeOptions, isScreen, function(error, response) {\n            disposables.dispose();\n\n            if (response && response.status === 'ok' && response.mediaStream && response.mediaStream.getStream()) {\n                disposables.add(memberStream.getObservableAudioState().subscribe(function(state) {\n                    var monitor = response.mediaStream.getMonitor();\n                    var tracks = response.mediaStream.getStream().getAudioTracks();\n\n                    if (monitor && tracks.length === 1) {\n                        monitor.setMonitorTrackState(tracks[0], state === trackEnums.states.trackEnabled.name);\n                    }\n                }, {initial: 'notify'}));\n                disposables.add(memberStream.getObservableVideoState().subscribe(function(state) {\n                    var monitor = response.mediaStream.getMonitor();\n                    var tracks = response.mediaStream.getStream().getVideoTracks();\n\n                    if (monitor && tracks.length === 1) {\n                        monitor.setMonitorTrackState(tracks[0], state === trackEnums.states.trackEnabled.name);\n                    }\n                }, {initial: 'notify'}));\n            }\n\n            if (error && parseInt(error.category) === 6) {\n                return callback(error, {status: 'device-insecure'});\n            }\n\n            // TODO(dy) Remove backward compatibility when all publisher clients adapt to providing capabilities.\n            if (response && (response.status === 'failed' || response.status === 'streaming-not-available') && isUsingDeprecatedSdk && defaultFeatureIndex < featureCapabilities.length) {\n                that._logger.info('Attempting to subscribe to member stream with next available feature after failure');\n\n                return that.subscribeToMemberStream(memberStream, options, callback, defaultFeatureIndex + 1);\n            }\n\n            var responseWithOriginStreamId = _.assign({originStreamId: streamId}, response);\n\n            callback(error, responseWithOriginStreamId);\n        });\n    };\n\n    function getCapabilitiesFromTokenIfAble(streamToken) {\n        var that = this;\n\n        try {\n            var capabilitiesFromStreamToken = that._pcastExpress.parseCapabilitiesFromToken(streamToken);\n\n            return capabilitiesFromStreamToken;\n        } catch (e) {\n            return;\n        }\n    }\n\n    function disposeOfRoomServices() {\n        _.forOwn(this._roomServicePublishers, function(publishers) {\n            _.forEach(publishers, function(publisher) {\n                publisher.stop('dispose');\n            });\n        });\n        _.forOwn(this._roomServices, function(roomService) {\n            roomService.stop('dispose');\n        });\n\n        this._roomServicePublishers = {};\n        this._externalPublishers = [];\n        this._roomServices = {};\n        this._activeRoomServices = [];\n    }\n\n    function createRoomService(roomId, alias, callback) {\n        var that = this;\n        var uniqueId = _.uniqueId();\n\n        this._pcastExpress.waitForOnline(function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            var activeRoomService = findActiveRoom.call(that, roomId, alias);\n\n            if (activeRoomService) {\n                that._logger.info('Reusing room service for room [%s]/[%s]', roomId, alias);\n\n                return callback(null, {\n                    status: 'ok',\n                    roomService: activeRoomService\n                });\n            }\n\n            that._roomServices[uniqueId] = new RoomService(that._pcastExpress.getPCast());\n\n            var expressRoomService = createExpressRoomService.call(that, that._roomServices[uniqueId], uniqueId);\n\n            that._logger.info('Creating room service for room [%s]/[%s]', roomId, alias);\n\n            callback(null, {\n                status: 'ok',\n                roomService: expressRoomService\n            });\n        });\n    }\n\n    function findActiveRoom(roomId, alias) {\n        return _.find(this._activeRoomServices, function(roomService) {\n            var activeRoom = roomService.getObservableActiveRoom().getValue();\n\n            return activeRoom && (activeRoom.getRoomId() === roomId || activeRoom.getObservableAlias().getValue() === alias);\n        });\n    }\n\n    function createExpressRoomService(roomService, uniqueId) {\n        var that = this;\n        var roomServiceStop = roomService.stop;\n        var roomServiceLeaveRoom = roomService.leaveRoom;\n\n        roomService.stop = function() {\n            roomServiceStop.apply(roomService, arguments);\n\n            delete that._roomServices[uniqueId];\n        };\n\n        roomService.leaveRoom = function leaveRoom(callback, isForceLeaveRoom) {\n            var room = roomService.getObservableActiveRoom().getValue();\n\n            roomServiceLeaveRoom.call(roomService, function(error, response) {\n                if (error) {\n                    roomService.stop('leave-room-failure');\n\n                    return callback(error);\n                }\n\n                if (response.status !== 'ok' && response.status !== 'not-in-room') {\n                    return callback(null, response);\n                }\n\n                that._logger.info('Successfully disposed Express Room Service [%s]', room ? room.getRoomId() : 'Uninitialized');\n\n                roomService.stop('leave-room');\n\n                return callback(null, response);\n            }, isForceLeaveRoom);\n        };\n\n        return roomService;\n    }\n\n    function joinRoomWithOptions(options, joinRoomCallback, membersChangedCallback) {\n        var that = this;\n        var role = options.role;\n        var screenName = options.screenName || _.uniqueId();\n\n        createRoomService.call(that, options.roomId, options.alias, function(error, roomServiceResponse) {\n            if (error) {\n                return joinRoomCallback(error);\n            }\n\n            if (roomServiceResponse.status !== 'ok') {\n                return joinRoomCallback(null, roomServiceResponse);\n            }\n\n            var roomService = roomServiceResponse.roomService;\n            var activeRoomObservable = roomService.getObservableActiveRoom();\n            var activeRoom = activeRoomObservable.getValue();\n            var membersSubscription = null;\n            var setupMembersSubscription = function setupMembersSubscription() {\n                var room = activeRoomObservable.getValue();\n\n                if (!room) {\n                    that._logger.warn('Unable to setup members subscription. Not in room.');\n\n                    return;\n                }\n\n                that._logger.info('Setup member subscription for room [%s]', room.getRoomId());\n\n                membersSubscription = room.getObservableMembers().subscribe(membersChangedCallback, {initial: 'notify'});\n\n                that._disposables.add(activeRoomObservable.subscribe(function(newRoom) {\n                    if (membersSubscription) {\n                        membersChangedCallback([]);\n                        membersSubscription.dispose();\n                        membersSubscription = null;\n                    }\n\n                    if (!newRoom) {\n                        return;\n                    }\n\n                    membersSubscription = newRoom.getObservableMembers().subscribe(membersChangedCallback, {initial: 'notify'});\n                }));\n            };\n\n            if (!activeRoom) {\n                roomService.start(role, screenName);\n            }\n\n            if (options.streams && options.streams.length > 0) {\n                var stream = options.streams[0]; // TODO(dy) support multiple streams\n\n                if (options.streamsWildcardTokenCapabilities && !_.includes(options.streams[0].uri, Stream.getPCastPrefix())) {\n                    options.streams[0].uri = Stream.getPCastPrefix() + options.streams[0].uri;\n                    that._externalPublishers.push(options.streams[0].uri);\n                }\n\n                if (options.streamsWildcardTokenCapabilities && activeRoom && !_.includes(stream.uri, 'streamToken')) {\n                    return createViewerStreamTokensAndUpdateSelf.call(that, options, stream, activeRoom, function(error, response) {\n                        joinRoomCallback(error, _.assign({roomService: roomService}, response));\n\n                        if (membersChangedCallback) {\n                            return setupMembersSubscription();\n                        }\n                    });\n                }\n\n                var roleToJoin = options.streamsWildcardTokenCapabilities && !activeRoom && !_.includes(stream.uri, 'streamToken') ? memberEnums.roles.audience.name : options.role;\n\n                updateSelfStreamsAndRole.call(that, options.streams, roleToJoin, roomService, function(error) {\n                    if (error) {\n                        return joinRoomCallback(error);\n                    }\n                });\n            }\n\n            if (activeRoom) {\n                joinRoomCallback(null, {\n                    status: 'ok',\n                    roomService: roomService\n                });\n\n                if (membersChangedCallback) {\n                    setupMembersSubscription();\n                }\n\n                return;\n            }\n\n            roomService.enterRoom(options.roomId, options.alias, function(error, roomResponse) {\n                if (error) {\n                    roomService.stop('enter-room-failure');\n\n                    return joinRoomCallback(error);\n                }\n\n                if (roomResponse.status === 'not-found') {\n                    roomService.stop('enter-room-failure');\n\n                    return joinRoomCallback(null, {status: 'room-not-found'});\n                }\n\n                if (roomResponse.status !== 'ok' && roomResponse.status !== 'already-in-room') {\n                    roomService.stop('enter-room-failure');\n\n                    return joinRoomCallback(null, roomResponse);\n                }\n\n                var room = roomResponse.room;\n                var stream = _.get(options, ['streams', 0]); // TODO(dy) support multiple streams\n\n                that._activeRoomServices.push(roomService);\n\n                if (options.streamsWildcardTokenCapabilities && stream && !_.includes(stream.uri, 'streamToken')) {\n                    return createViewerStreamTokensAndUpdateSelf.call(that, options, stream, room, function(error, response) {\n                        joinRoomCallback(error, _.assign({roomService: roomService}, response));\n\n                        if (membersChangedCallback) {\n                            return setupMembersSubscription();\n                        }\n                    });\n                }\n\n                joinRoomCallback(null, {\n                    status: 'ok',\n                    roomService: roomService\n                });\n\n                if (membersChangedCallback) {\n                    return setupMembersSubscription();\n                }\n            });\n        });\n    }\n\n    function subscribeToMemberStream(subscribeOptions, isScreen, callback) {\n        var that = this;\n\n        var count = 0;\n        var handleSubscribe = function(error, response) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (response.status !== 'ok' && response.status !== 'streaming-not-ready') {\n                return callback(null, response);\n            }\n\n            count++;\n\n            if (response.status === 'streaming-not-ready' && count < 3) {\n                var retryTimeout = count * count * 1000;\n\n                that._logger.info('Waiting for [%s] ms before retrying after [streaming-not-ready] status.', retryTimeout);\n\n                var timeoutId = setTimeout(response.retry, retryTimeout);\n\n                that._disposables.add(new disposable.Disposable(function() {\n                    clearTimeout(timeoutId);\n                }));\n\n                return;\n            } else if (response.status === 'streaming-not-ready' && count >= 3) {\n                return callback(null, {status: response.status});\n            }\n\n            var subscribeResponse = _.assign({}, response, {status: 'ok'});\n\n            if (count > 1) {\n                subscribeResponse.reason = 'stream-failure-recovered';\n\n                return callback(null, subscribeResponse);\n            }\n\n            callback(null, subscribeResponse);\n        };\n\n        if (isScreen) {\n            return that._pcastExpress.subscribeToScreen(subscribeOptions, handleSubscribe);\n        }\n\n        return that._pcastExpress.subscribe(subscribeOptions, handleSubscribe);\n    }\n\n    function publishAndUpdateSelf(options, room, callback) {\n        var that = this;\n        var publisher;\n        var refreshTokenIntervalId;\n        var callbackWithPublisher = function(error, response) {\n            callback(error, response ? _.assign({publisher: publisher}, response) : response);\n        };\n\n        var handlePublish = function(error, response) {\n            if (refreshTokenIntervalId && publisher) {\n                clearInterval(refreshTokenIntervalId);\n            }\n\n            if (error) {\n                return callbackWithPublisher(error);\n            }\n\n            if (response.status !== 'ok') {\n                return callbackWithPublisher(null, response);\n            }\n\n            addPublisher.call(that, response.publisher, room);\n            removePublisher.call(that, publisher, room);\n\n            publisher = response.publisher;\n\n            that._publisherDisposables[publisher.getStreamId()] = new disposable.DisposableList();\n\n            var publisherStop = _.bind(publisher.stop, publisher);\n\n            publisher.stop = function() {\n                clearInterval(refreshTokenIntervalId);\n\n                removePublisher.call(that, publisher, room);\n\n                var streamsAfterStop = mapNewPublisherStreamToMemberStreams.call(that, null, room);\n                var roomService = findActiveRoom.call(that, room.getRoomId());\n                var publisherDisposable = that._publisherDisposables[publisher.getStreamId()];\n\n                if (publisherDisposable) {\n                    publisherDisposable.dispose();\n\n                    delete that._publisherDisposables[publisher.getStreamId()];\n                }\n\n                publisherStop.apply(publisher, arguments);\n\n                if (!roomService) {\n                    return;\n                }\n\n                updateSelfStreamsAndRoleAndEnterRoomIfNecessary.call(that, streamsAfterStop, streamsAfterStop.length === 0 ? memberEnums.roles.audience.name : options.memberRole, roomService, room, options, function(error) {\n                    if (error) {\n                        return callbackWithPublisher(error);\n                    }\n                });\n            };\n\n            listenForTrackStateChange.call(that, publisher, room, callbackWithPublisher);\n\n            if (options.enableWildcardCapability) {\n                refreshTokenIntervalId = setInterval(function() {\n                    that._logger.info('Refresh wildcard viewer stream token for [%s] interval of [%s] has expired. Creating new token.',\n                        publisher.getStreamId(), defaultStreamWildcardTokenRefreshInterval);\n\n                    var activeRoomService = findActiveRoom.call(that, room.getRoomId(), room.getObservableAlias().getValue());\n                    var activeRoom = activeRoomService ? activeRoomService.getObservableActiveRoom().getValue() : room;\n\n                    createOptionalViewerStreamTokensAndUpdateSelf.call(that, options, publisher, activeRoom, function ignoreSuccess(error, response) {\n                        if (error || response.status !== 'ok') {\n                            callbackWithPublisher(error, response);\n                        }\n                    });\n                }, defaultStreamWildcardTokenRefreshInterval);\n\n                that._disposables.add(new disposable.Disposable(function() {\n                    clearInterval(refreshTokenIntervalId);\n                }));\n            }\n\n            createOptionalViewerStreamTokensAndUpdateSelf.call(that, options, response.publisher, room, callbackWithPublisher);\n        };\n\n        if (_.get(options, ['mediaConstraints', 'screen'], false)) {\n            _.set(options, ['streamInfo', 'isScreen'], true);\n\n            return this._pcastExpress.publishScreen(options, handlePublish);\n        }\n\n        this._pcastExpress.publish(options, handlePublish);\n    }\n\n    function addPublisher(publisher, room) {\n        if (!this._roomServicePublishers[room.getRoomId()]) {\n            this._roomServicePublishers[room.getRoomId()] = [];\n        }\n\n        this._roomServicePublishers[room.getRoomId()].push(publisher);\n    }\n\n    function removePublisher(publisher, room) {\n        if (!this._roomServicePublishers[room.getRoomId()] || !publisher) {\n            return;\n        }\n\n        this._roomServicePublishers[room.getRoomId()] = _.filter(this._roomServicePublishers[room.getRoomId()], function(roomPublisher) {\n            return roomPublisher.getStreamId() !== publisher.getStreamId();\n        });\n    }\n\n    function createOptionalViewerStreamTokensAndUpdateSelf(options, publisher, room, callback) {\n        var that = this;\n        var streamType = options.streamType;\n        var streamInfo = options.streamInfo;\n        var capabilities = [];\n\n        if (options.streamToken) {\n            var capabilitiesFromStreamToken = getCapabilitiesFromTokenIfAble.call(that, options.streamToken);\n\n            if (!capabilitiesFromStreamToken) {\n                return callback(new Error('Bad `streamToken`'), {status: 'bad-token'});\n            }\n\n            capabilities = capabilitiesFromStreamToken;\n        } else {\n            capabilities = options.capabilities;\n        }\n\n        var publisherStream = mapStreamToMemberStream(publisher, streamType, streamInfo, capabilities);\n\n        if (!options.enableWildcardCapability) {\n            var activeRoomService = findActiveRoom.call(this, room.getRoomId(), room.getObservableAlias().getValue());\n            var updateSelfOptions = _.assign({}, options, {streams: mapNewPublisherStreamToMemberStreams.call(this, publisherStream, room)});\n\n            return updateSelfStreamsAndRoleAndEnterRoomIfNecessary.call(this, updateSelfOptions.streams, updateSelfOptions.memberRole, activeRoomService, room, updateSelfOptions, callback);\n        }\n\n        return createViewerStreamTokensAndUpdateSelf.call(this, options, publisherStream, room, callback);\n    }\n\n    function createViewerStreamTokensAndUpdateSelf(options, publisherStream, room, callback) {\n        var that = this;\n        var composeWithAdditionalStreams = options.viewerStreamSelectionStrategy === 'high-availability' && room.getObservableType().getValue() === roomEnums.types.channel.name;\n        var additionalStreamIds = [];\n        var handleJoinRoomCallback = callback;\n        var publisherStreamId = Stream.parsePCastStreamIdFromStreamUri(_.get(publisherStream, 'uri', ''));\n        var protocol = that.getPCastExpress().getPCast().getProtocol();\n        var sessionId = protocol ? protocol.getSessionId() : '';\n        var disposables = that._publisherDisposables[publisherStreamId];\n        var disposable;\n\n        if (!_.includes(publisherStream, 'capabilities')) {\n            if (options.streamToken) {\n                var capabilitiesFromStreamToken = getCapabilitiesFromTokenIfAble.call(that, options.streamToken);\n\n                if (!capabilitiesFromStreamToken) {\n                    return callback(new Error('Bad `streamToken`'), {status: 'bad-token'});\n                }\n\n                publisherStream = addStreamInfo(publisherStream, 'capabilities', capabilitiesFromStreamToken.join(','));\n            } else {\n                publisherStream = addStreamInfo(publisherStream, 'capabilities', options.capabilities.join(','));\n            }\n        }\n\n        if (composeWithAdditionalStreams) {\n            var membersWithSameContent = MemberSelector.getSimilarMembers(options.screenName, sessionId, room.getObservableMembers().getValue());\n\n            additionalStreamIds = getValidStreamIds(membersWithSameContent);\n\n            handleJoinRoomCallback = function(error, response) {\n                callback(error, response);\n\n                var roomService = _.get(response, 'roomService', findActiveRoom.call(that, room.getRoomId(), room.getObservableAlias().getValue()));\n\n                if (error || response.status !== 'ok' || disposable || !roomService) {\n                    return;\n                }\n\n                var activeRoom = roomService.getObservableActiveRoom().getValue();\n\n                disposable = activeRoom.getObservableMembers().subscribe(function(members) {\n                    var self = roomService.getSelf();\n                    var selfSessionId = self ? self.getSessionId() : '';\n                    var newMembersWithSameContent = MemberSelector.getSimilarMembers(options.screenName, selfSessionId, members);\n                    var newAdditionalStreamIds = getValidStreamIds(newMembersWithSameContent);\n                    var areTheSame = newAdditionalStreamIds.length === additionalStreamIds.length && _.reduce(newAdditionalStreamIds, function(areAllPreviousTheSame, streamId) {\n                        return areAllPreviousTheSame ? _.includes(additionalStreamIds, streamId) : areAllPreviousTheSame;\n                    }, true);\n                    var selfStreams = self ? self.getObservableStreams().getValue() : [];\n                    var publishedSelfStream = _.find(selfStreams, function(stream) {\n                        return stream.getPCastStreamId() === publisherStreamId;\n                    });\n\n                    if (!publishedSelfStream) {\n                        disposable.dispose();\n                        disposable = null;\n\n                        return;\n                    }\n\n                    if (areTheSame) {\n                        return;\n                    }\n\n                    that._logger.debug('Members with similar content to stream [%s] have changed. Generating new wildcard viewer token', publisherStreamId);\n\n                    disposable.dispose();\n                    disposable = null;\n\n                    createViewerStreamTokensAndUpdateSelf.call(that, options, publisherStream, activeRoom, function ignoreSuccess(error, response) {\n                        if (error || response.status !== 'ok') {\n                            callback(error, response);\n                        }\n                    });\n                });\n\n                if (disposables) {\n                    disposables.add(disposable);\n                }\n            };\n        }\n\n        return generateAllStreamTokensAndCreateStream.call(this, options.capabilities, publisherStreamId, additionalStreamIds, publisherStream, function(error, response) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (response.status !== 'ok') {\n                return callback(null, response);\n            }\n\n            var activeRoomService = findActiveRoom.call(that, room.getRoomId(), room.getObservableAlias().getValue());\n            var updateSelfOptions = _.assign({}, options, {streams: mapNewPublisherStreamToMemberStreams.call(that, publisherStream, room)});\n\n            return updateSelfStreamsAndRoleAndEnterRoomIfNecessary.call(that, updateSelfOptions.streams, updateSelfOptions.memberRole, activeRoomService, room, updateSelfOptions, handleJoinRoomCallback);\n        });\n    }\n\n    function generateAllStreamTokensAndCreateStream(publisherCapabilities, streamId, additionalStreamIds, stream, callback) {\n        var generateStreamTokenRequests = [];\n        var numberOfCompletedRequests = 0;\n        var requestCancelled = false;\n        var disposeOfRequests = function() {\n            _.forEach(generateStreamTokenRequests, function(disposable) {\n                disposable.dispose();\n            });\n        };\n\n        var completedRequestsCallback = function(error, response) {\n            if (requestCancelled) {\n                return;\n            }\n\n            if (error || response.status !== 'ok') {\n                disposeOfRequests();\n\n                requestCancelled = true;\n\n                return callback(error, response);\n            }\n\n            numberOfCompletedRequests++;\n\n            if (numberOfCompletedRequests === generateStreamTokenRequests.length) {\n                callback(null, {status: 'ok'});\n            }\n        };\n\n        this._logger.debug('Creating [real-time] and [broadcast] viewer wildcard stream token for published stream [%s] with [%s] additional streams', streamId, additionalStreamIds.length);\n\n        generateStreamTokenRequests.push(generateWildcardStreamTokenAndAppendToStream.call(this, [], streamId, additionalStreamIds, stream, 'streamToken', completedRequestsCallback));\n        generateStreamTokenRequests.push(generateWildcardStreamTokenAndAppendToStream.call(this, ['broadcast'], streamId, additionalStreamIds, stream, 'streamTokenForBroadcastStream', completedRequestsCallback));\n\n        var streamingTypePublisherCapabilities = _.filter(publisherCapabilities, _.bind(_.includes, null, streamingTypeCapabilities));\n\n        if (streamingTypePublisherCapabilities.length > 0) {\n            this._logger.debug('Creating [%s] viewer wildcard stream token for published stream [%s] with [%s] additional streams', streamingTypePublisherCapabilities, streamId, additionalStreamIds.length);\n\n            generateStreamTokenRequests.push(generateWildcardStreamTokenAndAppendToStream.call(this, streamingTypePublisherCapabilities, streamId, additionalStreamIds, stream, 'streamTokenForLiveStream', completedRequestsCallback));\n        }\n\n        if (_.includes(publisherCapabilities, 'drm')) {\n            this._logger.debug('Creating [drm-open-access] and [drm-hollywood] viewer wildcard stream token for published stream [%s] with [%s] additional streams', streamId, additionalStreamIds.length);\n\n            generateStreamTokenRequests.push(generateWildcardStreamTokenAndAppendToStream.call(this, ['streaming', 'drm-open-access'], streamId, additionalStreamIds, stream, 'streamTokenForLiveStreamWithDrmOpenAccess', completedRequestsCallback));\n            generateStreamTokenRequests.push(generateWildcardStreamTokenAndAppendToStream.call(this, ['streaming', 'drm-hollywood'], streamId, additionalStreamIds, stream, 'streamTokenForLiveStreamWithDrmHollywood', completedRequestsCallback));\n        }\n\n        return disposeOfRequests;\n    }\n\n    function generateWildcardStreamTokenAndAppendToStream(capabilities, streamId, additionalStreamIds, stream, tokenName, callback) {\n        var that = this;\n        var adminApi = that._pcastExpress.getAdminAPI();\n\n        if (!adminApi) {\n            throw new Error('Set \"options.enableWildcardCapability\" to \"false\", or set adminApiProxyClient on initiating room express');\n        }\n\n        return that._pcastExpress.getAdminAPI().createStreamTokenForSubscribing('*', capabilities, streamId, additionalStreamIds, function(error, response) {\n            if (error) {\n                return callback(error);\n            }\n\n            if (response.status !== 'ok') {\n                return callback(null, response);\n            }\n\n            stream = addStreamInfo(stream, tokenName, response.streamToken);\n\n            callback(null, response);\n        });\n    }\n\n    function addStreamInfo(stream, name, value) {\n        var indexOfQueryParam = stream.uri.indexOf('?');\n        var prefix = indexOfQueryParam > -1 ? '&' : '?';\n        var indexOfHashAfterQueryParam = stream.uri.indexOf('#', indexOfQueryParam === -1 ? stream.uri.length : indexOfQueryParam);\n        var uriBeforeHashIfQueryParamPresent = indexOfHashAfterQueryParam === -1 ? stream.uri : stream.uri.substring(0, indexOfHashAfterQueryParam);\n        var uriHash = indexOfHashAfterQueryParam === -1 ? '' : stream.uri.substring(indexOfHashAfterQueryParam);\n\n        stream.uri = uriBeforeHashIfQueryParamPresent + prefix + name + '=' + value + uriHash;\n\n        return stream;\n    }\n\n    function getValidStreamIds(members) {\n        return _.reduce(members, function(streamIds, member) {\n            var stream = _.get(member.getObservableStreams().getValue(), '0');\n            var streamId = stream ? stream.getPCastStreamId() : '';\n\n            if (streamId) {\n                streamIds.push(streamId);\n            }\n\n            return streamIds;\n        }, []);\n    }\n\n    function mapNewPublisherStreamToMemberStreams(publisherStream, room) {\n        var that = this;\n        var activeRoomService = findActiveRoom.call(this, room.getRoomId(), room.getObservableAlias().getValue());\n        var defaultStreams = publisherStream ? [publisherStream] : [];\n\n        if (!activeRoomService) {\n            return defaultStreams;\n        }\n\n        var self = activeRoomService.getSelf();\n\n        if (!self) {\n            return defaultStreams;\n        }\n\n        var selfStreams = _.map(self.getObservableStreams().getValue(), function(selfStream) {\n            return selfStream.toJson();\n        });\n        var publishers = this._roomServicePublishers[room.getRoomId()] || [];\n        var publisherIds = _.map(publishers, function(publisher) {\n            return publisher.getStreamId();\n        });\n\n        if (!selfStreams || selfStreams.length === 0) {\n            return defaultStreams;\n        }\n\n        if (publisherStream) {\n            selfStreams = _.filter(selfStreams, function(stream) {\n                var hasSameUri = stream.uri === publisherStream.uri;\n                var pcastStreamId = Stream.parsePCastStreamIdFromStreamUri(stream.uri);\n                var isPCastStream = !!pcastStreamId;\n                var hasSamePCastStreamId = isPCastStream && pcastStreamId === Stream.parsePCastStreamIdFromStreamUri(publisherStream.uri);\n                var isTheSameWithoutQueryParams = publisherStream.uri.split('?')[0] === stream.uri.split('?')[0];\n                var hasSameType = stream.type === publisherStream.type;\n\n                return (!hasSameUri && !hasSamePCastStreamId && !isTheSameWithoutQueryParams) || !hasSameType;\n            });\n\n            selfStreams.push(publisherStream);\n        }\n\n        return _.filter(selfStreams, function(stream) {\n            return !Stream.parsePCastStreamIdFromStreamUri(stream.uri)\n                || _.includes(publisherIds, Stream.parsePCastStreamIdFromStreamUri(stream.uri) || stream.uri)\n                || _.includes(that._externalPublishers, stream.uri.split('?')[0]);\n        });\n    }\n\n    function updateSelfStreamsAndRole(streams, role, roomService, callback) {\n        var activeRoom = roomService ? roomService.getObservableActiveRoom().getValue() : null;\n\n        if (streams && roomService) {\n            roomService.getSelf().setStreams(streams);\n        }\n\n        if (role && roomService) {\n            roomService.getSelf().getObservableRole().setValue(streams.length === 0 ? memberEnums.roles.audience.name : role);\n        }\n\n        if (activeRoom && roomService.getSelf()) {\n            return updateSelfWithRetry.call(this, roomService.getSelf(), callback);\n        }\n    }\n\n    function updateSelfStreamsAndRoleAndEnterRoomIfNecessary(streams, role, roomService, room, options, callback) {\n        var activeRoomService = findActiveRoom.call(this, room.getRoomId(), room.getObservableAlias().getValue());\n        var activeRoom = roomService ? roomService.getObservableActiveRoom().getValue() : null;\n        var shouldJoinRoom = !activeRoom && !activeRoomService;\n        var that = this;\n\n        if (that._disposed) {\n            return that._logger.warn('Unable to update self after express room service disposal.');\n        }\n\n        if (streams && activeRoomService) {\n            that._logger.debug('Preparing member streams for update in room [%s].', room.getRoomId());\n\n            activeRoomService.getSelf().setStreams(streams);\n        }\n\n        if (role && activeRoomService && activeRoomService.getSelf().getObservableRole().getValue() !== role) {\n            that._logger.debug('Preparing member role for update in room [%s].', room.getRoomId());\n\n            activeRoomService.getSelf().getObservableRole().setValue(role);\n        }\n\n        if (activeRoom && activeRoomService.getSelf()) {\n            return updateSelfWithRetry.call(this, activeRoomService.getSelf(), callback);\n        }\n\n        if (shouldJoinRoom) {\n            that._logger.info('Joining room with member [%s].', room.getRoomId());\n\n            var joinRoomAsPresenterOptions = _.assign({\n                role: role,\n                alias: _.get(options, ['room', 'alias']),\n                roomId: _.get(options, ['room', 'roomId'])\n            }, options);\n\n            joinRoomWithOptions.call(that, joinRoomAsPresenterOptions, function(error, response) {\n                if (error) {\n                    return callback(error);\n                }\n\n                if (response.status !== 'ok' && response.status !== 'already-in-room') {\n                    return callback(null, response);\n                }\n\n                callback(error, response);\n            });\n        }\n    }\n\n    function updateSelfWithRetry(self, callback) {\n        var updateSelfErrors = 0;\n        var that = this;\n        var maxUpdateSelfRetries = 5;\n\n        try {\n            self.commitChanges(function handleUpdateSelf(error, response) {\n                if (error || !response) {\n                    updateSelfErrors++;\n                }\n\n                var roomService = self.getRoomService();\n                var room = roomService ? roomService.getObservableActiveRoom().getValue() : null;\n\n                if (response && response.status === 'ok' || (!room && response.status === 'not-found')) {\n                    updateSelfErrors = 0;\n                    that._isHandlingTrackChange = false;\n\n                    return !callback || callback(null, response);\n                }\n\n                if (response && response.status !== 'ok') {\n                    updateSelfErrors++;\n                }\n\n                if (updateSelfErrors >= maxUpdateSelfRetries) {\n                    that._logger.warn('Unable to update self after [%s] attempts.', maxUpdateSelfRetries);\n\n                    if (_.isNumber(response.lastUpdate)) {\n                        that._logger.warn('Updating self last update from [%s] to [%s] to prevent permanent failure state. Our awareness of self does not match up with the server anymore.',\n                            self.getObservableLastUpdate().getValue(), response.lastUpdate);\n\n                        self.getObservableLastUpdate().setValue(response.lastUpdate);\n                    }\n\n                    that._isHandlingTrackChange = false;\n\n                    return callback(new Error('Unable to update self'));\n                }\n\n                if (updateSelfErrors > 0 && updateSelfErrors < maxUpdateSelfRetries) {\n                    that._logger.info('Unable to update self after [%s] attempts. Retrying.', updateSelfErrors);\n\n                    return self.commitChanges(handleUpdateSelf);\n                }\n            });\n        } catch (error) {\n            callback(error);\n        }\n    }\n\n    function monitorSubsciberOrPublisher(callback, error, response) {\n        if (error) {\n            return callback(error);\n        }\n\n        if (response.retry) {\n            return response.retry();\n        }\n\n        callback(error, response);\n    }\n\n    function getDefaultRoomDescription(type) {\n        switch(type) {\n        case roomEnums.types.channel.name:\n            return 'Room Channel';\n        case roomEnums.types.moderatedChat.name:\n            return 'Moderated Chat';\n        case roomEnums.types.multiPartyChat.name:\n            return 'Multi Party Chat';\n        case roomEnums.types.townHall.name:\n            return 'Town Hall';\n        case roomEnums.types.directChat.name:\n            return 'Direct Chat';\n        default:\n            throw new Error('Unsupported Room Type');\n        }\n    }\n\n    // TODO(dy) Remove backward compatibility when all publisher clients adapt to providing capabilities.\n    function buildCapabilitiesFromPublisherWildcardTokens(uri) {\n        var streamInfo = Stream.getInfoFromStreamUri(uri);\n        var capabilities = [];\n\n        if (streamInfo.streamTokenForLiveStream) {\n            capabilities.push('streaming');\n        }\n\n        return capabilities;\n    }\n\n    function getStreamTokenForFeature(uri, feature) {\n        var streamInfo = Stream.getInfoFromStreamUri(uri);\n\n        switch(feature) {\n        case 'rtmp':\n        case 'hls':\n        case 'dash':\n            return streamInfo.streamTokenForLiveStream;\n        case 'real-time':\n            return streamInfo.streamToken;\n        default:\n            return;\n        }\n    }\n\n    // TODO(dy) Remove backward compatibility when all publisher clients adapt to providing capabilities.\n    function parseStreamTokenFromStreamUri(uri, capabilities) {\n        var streamInfo = Stream.getInfoFromStreamUri(uri);\n        var isStreaming = streamInfo.streamTokenForLiveStream && _.includes(capabilities, 'streaming');\n        var isRtmp = streamInfo.streamTokenForLiveStream && _.includes(capabilities, 'rtmp');\n\n        // Token for both not generated.\n        if (_.includes(capabilities, 'drm-open-access') && _.includes(capabilities, 'drm-hollywood')) {\n            return;\n        }\n\n        if (isStreaming && streamInfo.streamTokenForLiveStreamWithDrmOpenAccess && (_.includes(capabilities, 'drm-open-access') || FeatureDetector.isAndroid())) {\n            return streamInfo.streamTokenForLiveStreamWithDrmOpenAccess;\n        }\n\n        if (isStreaming && streamInfo.streamTokenForLiveStreamWithDrmHollywood && _.includes(capabilities, 'drm-hollywood')) {\n            return streamInfo.streamTokenForLiveStreamWithDrmHollywood;\n        }\n\n        if (isStreaming || isRtmp) {\n            return streamInfo.streamTokenForLiveStream;\n        }\n\n        if (streamInfo.streamTokenForBroadcastStream && _.includes(capabilities, 'broadcast')) {\n            return streamInfo.streamTokenForBroadcastStream;\n        }\n\n        if (!_.includes(capabilities, 'streaming') && !_.includes(capabilities, 'broadcast') && !_.includes(capabilities, 'rtmp')) {\n            return streamInfo.streamToken;\n        }\n    }\n\n    function mapStreamToMemberStream(publisher, type, streamInfo, capabilities, viewerStreamToken, viewerStreamTokenForBroadcastStream, viewerStreamTokenForLiveStream, drmStreamTokens) {\n        var mediaStream = publisher.getStream();\n        var audioTracks = mediaStream ? mediaStream.getAudioTracks() : null;\n        var videoTracks = mediaStream ? mediaStream.getVideoTracks() : null;\n        var audioTrackEnabled = audioTracks.length > 0 && audioTracks[0].enabled;\n        var videoTrackEnabled = videoTracks.length > 0 && videoTracks[0].enabled;\n\n        if (capabilities.includes('audio-only')) {\n            videoTrackEnabled = false;\n        }\n\n        if (capabilities.includes('video-only')) {\n            audioTrackEnabled = false;\n        }\n\n        var publishedStream = {\n            uri: Stream.getPCastPrefix() + publisher.getStreamId(),\n            type: type,\n            audioState: audioTrackEnabled ? trackEnums.states.trackEnabled.name : trackEnums.states.trackDisabled.name,\n            videoState: videoTrackEnabled ? trackEnums.states.trackEnabled.name : trackEnums.states.trackDisabled.name\n        };\n\n        var infoToAppend = _.assign({}, streamInfo, {\n            streamToken: viewerStreamToken,\n            streamTokenForBroadcastStream: viewerStreamTokenForBroadcastStream,\n            streamTokenForLiveStream: viewerStreamTokenForLiveStream\n        });\n\n        if (!viewerStreamToken) {\n            delete infoToAppend.streamToken;\n        }\n\n        if (!viewerStreamTokenForBroadcastStream) {\n            delete infoToAppend.streamTokenForBroadcastStream;\n        }\n\n        if (!viewerStreamTokenForLiveStream) {\n            delete infoToAppend.streamTokenForLiveStream;\n        }\n\n        if (drmStreamTokens) {\n            assert.isArray(drmStreamTokens, 'drmStreamTokens');\n\n            infoToAppend.streamTokenForLiveStreamWithDrmOpenAccess = drmStreamTokens[0];\n            infoToAppend.streamTokenForLiveStreamWithDrmHollywood = drmStreamTokens[1];\n        }\n\n        var queryParamString = _.reduce(infoToAppend, function(queryParamString, currentValue, currentKey) {\n            var currentPrefix = queryParamString ? '&' : '?';\n\n            return queryParamString + currentPrefix + currentKey + '=' + currentValue;\n        }, '');\n\n        if (queryParamString.length > 0) {\n            publishedStream.uri = publishedStream.uri + queryParamString;\n        }\n\n        publishedStream = addStreamInfo(publishedStream, 'capabilities', capabilities.join(','));\n\n        return publishedStream;\n    }\n\n    function listenForTrackStateChange(publisher, room, callbackWithPublisher) {\n        var that = this;\n        var stream = publisher.getStream();\n\n        if (!stream) {\n            return;\n        }\n\n        var tracks = stream.getTracks();\n\n        _.forEach(tracks, function(track) {\n            var handleStateChange = function handleStateChange() {\n                that._isHandlingTrackChange = true;\n\n                var state = track.enabled ? trackEnums.states.trackEnabled.name : trackEnums.states.trackDisabled.name;\n                var activeRoomService = findActiveRoom.call(that, room.getRoomId());\n\n                if (!activeRoomService || !activeRoomService.getSelf()) {\n                    return;\n                }\n\n                var selfStreams = activeRoomService.getSelf().getObservableStreams().getValue();\n                var memberStream = _.find(selfStreams, function(selfStream) {\n                    return selfStream.getPCastStreamId() === publisher.getStreamId();\n                });\n                var self = getSelfAssociatedWithStream.call(that, memberStream);\n\n                if (!memberStream) {\n                    return that._logger.warn('[%s] [%s] Unable to update member state change after track state change [%s]. Member stream no longer exists on member model.', stream.id, track.id, track.enabled);\n                }\n\n                that._logger.info('[%s] [%s] Track state changed to [%s], updating room member stream state [%s]', stream.id, track.id, track.enabled, state);\n\n                if (track.kind === 'video') {\n                    memberStream.getObservableVideoState().setValue(state);\n                } else {\n                    memberStream.getObservableAudioState().setValue(state);\n                }\n\n                if (self) {\n                    updateSelfWithRetry.call(that, self, callbackWithPublisher);\n                }\n            };\n\n            var handleStateChangeIfPossible = function handleStateChangeIfPossible() {\n                if (that._handleStateChangeTimeOut) {\n                    clearTimeout(that._handleStateChangeTimeOut);\n                    that._handleStateChangeTimeOut = null;\n                }\n\n                if (!that._isHandlingTrackChange) {\n                    handleStateChange();\n\n                    return;\n                }\n\n                that._handleStateChangeTimeOut = setTimeout(function() {\n                    handleStateChangeIfPossible();\n                });\n            };\n\n            track.updateState = function(enabled) {\n                this.enabled = enabled;\n                handleStateChangeIfPossible();\n            };\n        });\n    }\n\n    function getSelfAssociatedWithStream(memberStream) {\n        var roomService = _.find(this._activeRoomServices, function(roomService) {\n            var self = roomService.getSelf();\n            var selfStreams = self ? self.getObservableStreams().getValue() : [];\n\n            return _.find(selfStreams, function(selfStream) {\n                return memberStream === selfStream;\n            });\n        });\n\n        return roomService ? roomService.getSelf() : null;\n    }\n\n    return RoomExpress;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var mostRecentStrategy = 'most-recent';\n    var highAvailabilityStrategy = 'high-availability';\n    var defaultBannedFailureCount = 100;\n    var defaultBanMemberOnCapacityFailureCount = 5;\n\n    function MemberSelector(selectionStrategy, logger, options) {\n        if (selectionStrategy) {\n            assert.isStringNotEmpty(selectionStrategy, 'selectionStrategy');\n        }\n\n        assert.isObject(logger, 'logger');\n\n        this._selectionStrategy = selectionStrategy || mostRecentStrategy;\n        this._logger = logger;\n        this._failureCountForBanningAMember = _.get(options, ['failureCountForBanningAMember'], defaultBannedFailureCount);\n        this._banMemberOnCapacityFailureCount = _.get(options, ['banMemberOnCapacityFailureCount'], defaultBanMemberOnCapacityFailureCount);\n\n        this.reset();\n    }\n\n    MemberSelector.prototype.getNext = function getNext(members) {\n        this._logger.info('Select member from [%s]', members);\n\n        var newSelectedMember = getNextMember.call(this, members);\n\n        if (!newSelectedMember) {\n            this._logger.info('Unable to select new member from [%s]', members);\n        } else {\n            this._logger.info('Selecting new member [%s]/[%s]', newSelectedMember.getSessionId(), newSelectedMember.getObservableScreenName().getValue());\n        }\n\n        this._lastSelectedMember = newSelectedMember;\n\n        return newSelectedMember;\n    };\n\n    MemberSelector.prototype.getStrategy = function() {\n        return this._selectionStrategy;\n    };\n\n    MemberSelector.prototype.markFailed = function(options) {\n        if (!this._lastSelectedMember) {\n            this._logger.warn('Marking failed member but there was no recent selected member');\n\n            return;\n        }\n\n        var memberKey = getMemberKey(this._lastSelectedMember);\n\n        if (_.get(options, ['failedDueToCapacity'], false)) {\n            var capacityFailureCount = _.get(this._capacityFailureCounts, [memberKey], 0);\n\n            capacityFailureCount++;\n\n            _.set(this._capacityFailureCounts, [memberKey], capacityFailureCount);\n\n            if (capacityFailureCount >= this._banMemberOnCapacityFailureCount) {\n                this._logger.info('Disabling member [%s] that has exceeded threshold due to [%s] capacity failures', memberKey, capacityFailureCount);\n\n                return this.markDead();\n            }\n        }\n\n        var failureCount = _.get(this._failureCounts, [memberKey], 0);\n        failureCount++;\n\n        this._logger.info('Failure count for member [%s] is now [%s]', memberKey, failureCount);\n\n        _.set(this._failureCounts, [memberKey], failureCount);\n\n        if (failureCount >= this._failureCountForBanningAMember) {\n            this._logger.info('Disabling member [%s] that has exceeded threshold due to [%s] failures', memberKey, failureCount);\n\n            return this.markDead();\n        }\n\n        this._lastSelectedMember = null;\n    };\n\n    MemberSelector.prototype.markDead = function() {\n        if (!this._lastSelectedMember) {\n            this._logger.warn('Marking dead member but there was no recent selected member');\n\n            return;\n        }\n\n        var memberKey = getMemberKey(this._lastSelectedMember);\n\n        this._logger.info('Member [%s] is now permanently removed', memberKey);\n\n        _.set(this._deadMembers, [memberKey], true);\n        this._lastSelectedMember = null;\n    };\n\n    MemberSelector.prototype.getNumberOfMembersWithFailures = function() {\n        return _.keys(this._failureCounts).length;\n    };\n\n    MemberSelector.prototype.reset = function() {\n        this._lastSelectedMember = null;\n        this._failureCounts = {};\n        this._capacityFailureCounts = {};\n        this._deadMembers = {};\n    };\n\n    MemberSelector.prototype.dispose = function dispose() {\n        this.reset();\n    };\n\n    MemberSelector.getSimilarMembers = function(screenName, optionalSessionId, members) {\n        var otherMembers = _.filter(members, function(member) {\n            return member.getObservableScreenName().getValue() !== screenName && (!optionalSessionId || member.getSessionId() !== optionalSessionId);\n        });\n        var primaryMembers = _.filter(otherMembers, isPrimary);\n        var alternateMembers = _.filter(otherMembers, isAlternate);\n\n        if (isPrimaryName(screenName)) {\n            return primaryMembers || alternateMembers || otherMembers;\n        }\n\n        if (isAlternateName(screenName)) {\n            return alternateMembers || primaryMembers || otherMembers;\n        }\n\n        return otherMembers || primaryMembers || alternateMembers;\n    };\n\n    function getMemberKey(member) {\n        if (!member) {\n            return '';\n        }\n\n        return member.getSessionId() + member.getObservableScreenName().getValue();\n    }\n\n    function getNextMember(members) {\n        var that = this;\n\n        switch (this._selectionStrategy) {\n        case mostRecentStrategy:\n            var activeMembers = _.reduce(members, function(activeMembers, member) {\n                var memberKey = getMemberKey(member);\n                var isDead = _.get(that._deadMembers, [memberKey], false);\n\n                if (!isDead) {\n                    activeMembers.push(member);\n                }\n\n                return activeMembers;\n            }, []);\n\n            return getMostRecentMember(activeMembers);\n        case highAvailabilityStrategy:\n            if (this._lastSelectedMember && _.includes(members, this._lastSelectedMember)) {\n                return this._lastSelectedMember;\n            }\n\n            var selectedMember = undefined;\n            var minFailureCount = Number.MAX_VALUE;\n\n            _.forEach(members, function(member) {\n                var memberKey = getMemberKey(member);\n                var isDead = _.get(that._deadMembers, [memberKey], false);\n\n                if (isDead) {\n                    return;\n                }\n\n                var failureCount = _.get(that._failureCounts, [member], 0);\n\n                if (failureCount < minFailureCount) {\n                    minFailureCount = failureCount;\n                    selectedMember = member;\n                } else if (failureCount === minFailureCount) {\n                    if (!selectedMember) {\n                        selectedMember = member;\n                    } else if (isPrimary(member)) {\n                        if (!isPrimary(selectedMember)) {\n                            selectedMember = member;\n                        }\n                    } else if (isAlternate(member)) {\n                        if (!isPrimary(selectedMember) && !isAlternate(selectedMember)) {\n                            selectedMember = member;\n                        }\n                    }\n                }\n            });\n\n            return selectedMember;\n        default:\n            throw new Error('Invalid Selection Strategy');\n        }\n    }\n\n    function getMostRecentMember(members) {\n        return _.reduce(members, function(mostRecentMember, member) {\n            if (!mostRecentMember) {\n                return member;\n            }\n\n            return mostRecentMember.getLastUpdate() > member.getLastUpdate() ? mostRecentMember : member;\n        });\n    }\n\n    function isPrimary(member) {\n        var screenName = member.getObservableScreenName().getValue();\n\n        return isPrimaryName(screenName);\n    }\n\n    function isAlternate(member) {\n        var screenName = member.getObservableScreenName().getValue();\n\n        return isAlternateName(screenName);\n    }\n\n    function isPrimaryName(name) {\n        var primary = /primary/i;\n\n        return primary.test(name);\n    }\n\n    function isAlternateName(name) {\n        var alternate = /alternate/i;\n\n        return alternate.test(name);\n    }\n\n    return MemberSelector;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    function Channel(room) {\n        assert.isObject(room, 'room');\n\n        this._room = room;\n    }\n\n    Channel.prototype.getChannelId = function getChannelId() {\n        return this._room.getRoomId.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableAlias = function getObservableAlias() {\n        return this._room.getObservableAlias.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableName = function getObservableName() {\n        return this._room.getObservableName.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableDescription = function getObservableDescription() {\n        return this._room.getObservableDescription.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableType = function getObservableType() {\n        return this._room.getObservableType.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableMembers = function getObservableMembers() {\n        return this._room.getObservableMembers.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservableBridgeId = function getObservableBridgeId() {\n        return this._room.getObservableBridgeId.apply(this._room, arguments);\n    };\n\n    Channel.prototype.getObservablePin = function getObservablePin() {\n        return this._room.getObservablePin.apply(this._room, arguments);\n    };\n\n    Channel.prototype.toString = function toString() {\n        return this._room.toString.apply(this._room, arguments);\n    };\n\n    Channel.prototype.toJson = function toJson() {\n        return {\n            channelId: this._room.getRoomId(),\n            alias: this._room.getObservableAlias().getValue(),\n            name: this._room.getObservableName().getValue(),\n            description: this._room.getObservableDescription().getValue(),\n            type: this._room.getObservableType().getValue(),\n            pin: this._room.getObservablePin().getValue(),\n            bridgeId: this._room.getObservableBridgeId().getValue()\n        };\n    };\n\n    Channel.prototype.commitChanges = function commitChanges() {\n        return this._room.commitChanges.apply(this._room, arguments);\n    };\n\n    Channel.prototype.reload = function reload() {\n        return this._room.reload.apply(this._room, arguments);\n    };\n\n    Channel.prototype._update = function update() {\n        return this._room._update.apply(this._room, arguments);\n    };\n\n    Channel.prototype._addMembers = function addMembers() {\n        return this._room._addMembers.apply(this._room, arguments);\n    };\n\n    Channel.prototype._removeMembers = function removeMembers() {\n        return this._room._removeMembers.apply(this._room, arguments);\n    };\n\n    Channel.prototype._updateMembers = function updateMembers() {\n        return this._room._updateMembers.apply(this._room, arguments);\n    };\n\n    return Channel;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine('phenix-web-sdk', [\n    'phenix-rtc',\n    'phenix-web-logging',\n    './sdk/PCast',\n    './sdk/room/RoomService',\n    './sdk/audio/AudioSpeakerDetector',\n    './sdk/bandwidth/BandwidthMonitor',\n    './sdk/userMedia/UserMediaResolver',\n    './sdk/express/PCastExpress',\n    './sdk/express/RoomExpress',\n    './sdk/express/ChannelExpress',\n    './sdk/AdminApiProxyClient'\n], function(rtc, logging, PCast, RoomService, AudioSpeakerDetector, BandwidthMonitor, UserMediaResolver, PCastExpress, RoomExpress, ChannelExpress, AdminApiProxyClient) {\n    'use strict';\n\n    rtc.global.PhenixPCast = PCast;\n\n    return {\n        express: {\n            PCastExpress: PCastExpress,\n            RoomExpress: RoomExpress,\n            ChannelExpress: ChannelExpress\n        },\n        lowLevel: {\n            PCast: PCast,\n            RoomService: RoomService\n        },\n        media: {\n            AudioSpeakerDetector: AudioSpeakerDetector,\n            UserMediaResolver: UserMediaResolver\n        },\n        net: {AdminApiProxyClient: AdminApiProxyClient},\n        utils: {\n            BandwidthMonitor: BandwidthMonitor,\n            logging: logging,\n            rtc: rtc\n        },\n\n        // TODO(dy) remove deprecated. Use above\n        AudioSpeakerDetector: AudioSpeakerDetector,\n        BandwidthMonitor: BandwidthMonitor,\n        logging: logging,\n        PCast: PCast,\n        RoomService: RoomService,\n        RTC: rtc,\n        UserMediaResolver: UserMediaResolver\n    };\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    '../environment',\n    './TelemetryAppender'\n], function(_, assert, environment, TelemetryAppender) {\n    function TelemetryAppenderFactory() {\n        this._telemetryAppenders = {};\n    }\n\n    TelemetryAppenderFactory.prototype.getAppender = function getAppender(pcastBaseUri) {\n        var env = environment.getEnvironmentFromUrl(pcastBaseUri || '');\n        var telemetryServerUrl = environment.getTelemetryServerUri(pcastBaseUri);\n\n        if (!this._telemetryAppenders[env]) {\n            this._telemetryAppenders[env] = createNewAppender.call(this, telemetryServerUrl);\n        }\n\n        return this._telemetryAppenders[env];\n    };\n\n    function createNewAppender(uri) {\n        var appender = new TelemetryAppender(uri);\n\n        if (!uri) {\n            appender.setEnabled(false);\n        }\n\n        return appender;\n    }\n\n    return new TelemetryAppenderFactory();\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-rtc',\n    'phenix-web-logging',\n    'phenix-web-proto',\n    '../protocol/telemetryProto.json'\n], function(_, assert, rtc, logging, proto, telemetryProto) {\n    var loggingUrl = '/logs';\n\n    function TelemetryAppender(uri) {\n        assert.isString(uri, 'uri');\n\n        this._domain = typeof location === 'object' ? location.hostname : rtc.browser + '-' + rtc.browserVersion + '-unknown';\n        this._minLevel = logging.level.TRACE;\n        this._isEnabled = true;\n        this._browser = (rtc.browser || 'Browser') + '/' + (rtc.browserVersion || '?');\n        this._mostRecentRuntime = 0;\n        this._batchHttpProtocol = new proto.BatchHttpProto(uri + loggingUrl, [telemetryProto], 'telemetry.StoreLogRecords', {\n            maxAttempts: 3,\n            maxBufferedRecords: 1000,\n            maxBatchSize: 512\n        });\n\n        this._batchHttpProtocol.on('capacity', _.bind(onCapacity, this));\n    }\n\n    TelemetryAppender.prototype.setThreshold = function setThreshold(level) {\n        assert.isNumber(level, 'level');\n\n        this._minLevel = level;\n    };\n\n    TelemetryAppender.prototype.getThreshold = function getThreshold() {\n        return this._minLevel;\n    };\n\n    TelemetryAppender.prototype.isEnabled = function isEnabled() {\n        return this._isEnabled;\n    };\n\n    TelemetryAppender.prototype.setEnabled = function setEnabled(enabled) {\n        assert.isBoolean(enabled, 'enabled');\n\n        this._isEnabled = enabled;\n    };\n\n    TelemetryAppender.prototype.log = function log(since, level, category, messages, sessionId, userId, environment, version, context) {\n        if (context.level < this._minLevel || !this._isEnabled) {\n            return;\n        }\n\n        assert.isArray(messages, 'messages');\n\n        this._mostRecentRuntime = since;\n        this._mostRecentSessionId = sessionId;\n        this._mostRecentUserId = userId;\n        this._mostRecentVersion = version;\n        this._mostRecentEnvironment = environment;\n\n        addMessagesToRecords.call(this, level, category, messages);\n    };\n\n    function addMessagesToRecords(level, category, messages) {\n        this._batchHttpProtocol.addRecord({\n            level: level,\n            timestamp: _.isoString(),\n            category: category,\n            message: messages.join(' '),\n            source: this._browser,\n            fullQualifiedName: this._domain,\n            sessionId: this._mostRecentSessionId,\n            userId: this._mostRecentUserId,\n            environment: this._mostRecentEnvironment,\n            version: this._mostRecentVersion,\n            runtime: this._mostRecentRuntime\n        });\n    }\n\n    function onCapacity(deleteRecords) {\n        this._batchHttpProtocol.addRecordToBeginning({\n            level: 'Warn',\n            timestamp: _.isoString(),\n            category: 'websdk/telemetryLogger',\n            message: 'Deleted ' + deleteRecords + ' records',\n            source: this._browser,\n            fullQualifiedName: this._domain,\n            sessionId: this._mostRecentSessionId,\n            userId: this._mostRecentUserId,\n            environment: this._mostRecentEnvironment,\n            version: this._mostRecentVersion,\n            runtime: this._mostRecentRuntime\n        });\n    }\n\n    return TelemetryAppender;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-proto',\n    'phenix-rtc',\n    './protocol/pcastProto.json',\n    './protocol/chatProto.json'\n], function(_, assert, observable, proto, phenixRTC, pcastProto, chatProto) {\n    'use strict';\n\n    var apiVersion = 5;\n\n    function PCastProtocol(uri, deviceId, version, logger) {\n        assert.isStringNotEmpty(uri, 'uri');\n        assert.isString(deviceId, 'deviceId');\n        assert.isStringNotEmpty(version, 'version');\n        assert.isObject(logger, 'logger');\n\n        this._deviceId = deviceId;\n        this._version = version;\n        this._logger = logger;\n        this._mqWebSocket = new proto.MQWebSocket(uri, this._logger, [pcastProto, chatProto], apiVersion);\n        this._observableSessionId = new observable.Observable(null).extend({rateLimit: 0});\n    }\n\n    PCastProtocol.prototype.onEvent = function(eventName, handler) {\n        return this._mqWebSocket.onEvent(eventName, handler);\n    };\n\n    PCastProtocol.prototype.disconnect = function() {\n        this._observableSessionId.setValue(null);\n\n        return this._mqWebSocket.disconnect();\n    };\n\n    PCastProtocol.prototype.authenticate = function(authToken, callback) {\n        assert.isStringNotEmpty(authToken, 'authToken');\n        assert.isFunction(callback, 'callback');\n\n        var authenticate = {\n            apiVersion: this._mqWebSocket.getApiVersion(),\n            clientVersion: this._version,\n            deviceId: this._deviceId,\n            platform: phenixRTC.browser,\n            platformVersion: phenixRTC.browserVersion.toString(),\n            authenticationToken: authToken\n        };\n\n        if (this.getSessionId()) {\n            authenticate.sessionId = this.getSessionId();\n        }\n\n        var that = this;\n\n        return this._mqWebSocket.sendRequest('pcast.Authenticate', authenticate, function(error, response) {\n            if (response) {\n                var previousSessionId = that._observableSessionId.getValue();\n\n                if (previousSessionId && previousSessionId !== response.sessionId) {\n                    that._mqWebSocket.disposeOfPendingRequests();\n                }\n\n                that._observableSessionId.setValue(response.sessionId);\n            }\n\n            return callback(error, response);\n        });\n    };\n\n    PCastProtocol.prototype.getSessionId = function() {\n        return this._observableSessionId.getValue();\n    };\n\n    PCastProtocol.prototype.getObservableSessionId = function() {\n        return this._observableSessionId;\n    };\n\n    PCastProtocol.prototype.bye = function(reason, callback) {\n        assert.isStringNotEmpty(reason, 'reason');\n        assert.isFunction(callback, 'callback');\n\n        var bye = {\n            sessionId: this.getSessionId(),\n            reason: reason\n        };\n\n        return this._mqWebSocket.sendRequest('pcast.Bye', bye, callback);\n    };\n\n    PCastProtocol.prototype.setupStream = function(streamType, streamToken, options, rtt, callback) {\n        assert.isStringNotEmpty(streamType, 'streamType');\n        assert.isStringNotEmpty(streamToken, 'streamToken');\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        var browser = phenixRTC.browser || 'UnknownBrowser';\n        var browserWithVersion = browser + '-' + (phenixRTC.browserVersion || 0);\n        var rttString = 'rtt[http]=' + rtt;\n        var setupStream = {\n            streamToken: streamToken,\n            createStream: {\n                sessionId: this.getSessionId(),\n                options: ['data-quality-notifications', rttString],\n                connectUri: options.connectUri,\n                connectOptions: options.connectOptions || [],\n                tags: options.tags || [],\n                userAgent: _.get(phenixRTC, ['global', 'navigator', 'userAgent'], browserWithVersion)\n            }\n        };\n\n        if (options.originStreamId) {\n            setupStream.createStream.originStreamId = options.originStreamId;\n        }\n\n        if (options.negotiate) {\n            setupStream.createStream.createOfferDescription = {\n                streamId: '',\n                options: [streamType, browser, browserWithVersion],\n                apiVersion: this._mqWebSocket.getApiVersion()\n            };\n\n            if (typeof screen !== 'undefined') {\n                setupStream.createStream.createOfferDescription.options.push('screen=' + screen.width + 'x' + screen.height);\n            }\n        }\n\n        if (options.receiveAudio === false) {\n            setupStream.createStream.options.push('no-audio');\n        }\n\n        if (options.receiveVideo === false) {\n            setupStream.createStream.options.push('no-video');\n        }\n\n        return this._mqWebSocket.sendRequest('pcast.SetupStream', setupStream, callback);\n    };\n\n    PCastProtocol.prototype.setAnswerDescription = function(streamId, sdp, callback) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n        assert.isStringNotEmpty(sdp, 'sdp');\n        assert.isFunction(callback, 'callback');\n\n        var setRemoteDescription = {\n            streamId: streamId,\n            sessionDescription: {\n                type: 'Answer',\n                sdp: sdp\n            },\n            apiVersion: this._mqWebSocket.getApiVersion()\n        };\n\n        return this._mqWebSocket.sendRequest('pcast.SetRemoteDescription', setRemoteDescription, callback);\n    };\n\n    PCastProtocol.prototype.addIceCandidates = function(streamId, candidates, options, callback) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n        assert.isArray(candidates, 'candidates');\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        var sanitizedCandidates = _.map(candidates, function(candidate, index) {\n            assert.isStringNotEmpty(candidate.candidate, 'candidate[' + index + '].candidate');\n            assert.isNumber(candidate.sdpMLineIndex, 'candidate[' + index + '].sdpMLineIndex');\n            assert.isStringNotEmpty(candidate.sdpMid, 'candidate[' + index + '].sdpMid');\n\n            return {\n                candidate: candidate.candidate,\n                sdpMLineIndex: candidate.sdpMLineIndex,\n                sdpMid: candidate.sdpMid\n            };\n        });\n\n        var addIceCandidates = {\n            streamId: streamId,\n            candidates: sanitizedCandidates,\n            options: options,\n            apiVersion: this._mqWebSocket.getApiVersion()\n        };\n\n        return this._mqWebSocket.sendRequest('pcast.AddIceCandidates', addIceCandidates, callback);\n    };\n\n    PCastProtocol.prototype.updateStreamState = function(streamId, signalingState, iceGatheringState, iceConnectionState, callback) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n        assert.isStringNotEmpty(signalingState, 'signalingState');\n        assert.isStringNotEmpty(iceGatheringState, 'iceGatheringState');\n        assert.isStringNotEmpty(iceConnectionState, 'iceConnectionState');\n        assert.isFunction(callback, 'callback');\n\n        var updateStreamState = {\n            streamId: streamId,\n            signalingState: signalingState,\n            iceGatheringState: iceGatheringState,\n            iceConnectionState: iceConnectionState,\n            apiVersion: this._mqWebSocket.getApiVersion()\n        };\n\n        return this._mqWebSocket.sendRequest('pcast.UpdateStreamState', updateStreamState, callback);\n    };\n\n    PCastProtocol.prototype.destroyStream = function(streamId, reason, callback) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n        assert.isString(reason, 'reason');\n        assert.isFunction(callback, 'callback');\n\n        var destroyStream = {\n            streamId: streamId,\n            reason: reason\n        };\n\n        return this._mqWebSocket.sendRequest('pcast.DestroyStream', destroyStream, callback);\n    };\n\n    PCastProtocol.prototype.getRoomInfo = function(roomId, alias, callback) {\n        if (roomId) {\n            assert.isString(roomId, 'roomId');\n        } else {\n            assert.isString(alias, 'alias');\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        var getRoomInfo = {\n            roomId: roomId,\n            alias: alias,\n            sessionId: this.getSessionId()\n        };\n\n        return this._mqWebSocket.sendRequest('chat.GetRoomInfo', getRoomInfo, callback);\n    };\n\n    PCastProtocol.prototype.createRoom = function(room, callback) {\n        assert.isObject(room, 'room');\n        assert.isStringNotEmpty(room.name, 'room.name');\n        assert.isStringNotEmpty(room.type, 'room.type');\n        assert.isStringNotEmpty(room.description, 'room.description');\n        assert.isFunction(callback, 'callback');\n\n        var createRoom = {\n            sessionId: this.getSessionId(),\n            room: room\n        };\n\n        return this._mqWebSocket.sendRequest('chat.CreateRoom', createRoom, callback);\n    };\n\n    PCastProtocol.prototype.enterRoom = function(roomId, alias, member, options, timestamp, callback) {\n        if (roomId) {\n            assert.isString(roomId, 'roomId');\n        } else {\n            assert.isString(alias, 'alias');\n        }\n\n        assert.isObject(member, 'member');\n        assert.isNumber(timestamp, 'timestamp');\n        assert.isArray(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        var joinRoom = {\n            roomId: roomId,\n            alias: alias,\n            sessionId: this.getSessionId(),\n            member: member,\n            options: options,\n            timestamp: timestamp\n        };\n\n        return this._mqWebSocket.sendRequest('chat.JoinRoom', joinRoom, callback);\n    };\n\n    PCastProtocol.prototype.leaveRoom = function(roomId, timestamp, callback) {\n        assert.isString(roomId, 'roomId');\n        assert.isNumber(timestamp, 'timestamp');\n        assert.isFunction(callback, 'callback');\n\n        var leaveRoom = {\n            roomId: roomId,\n            sessionId: this.getSessionId(),\n            timestamp: timestamp\n        };\n\n        return this._mqWebSocket.sendRequest('chat.LeaveRoom', leaveRoom, callback);\n    };\n\n    PCastProtocol.prototype.updateMember = function(roomId, member, timestamp, callback) {\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isObject(member, 'member');\n        assert.isNumber(timestamp, 'timestamp');\n        assert.isFunction(callback, 'callback');\n\n        member.updateStreams = Object.prototype.hasOwnProperty.call(member, 'streams');\n\n        var updateMember = {\n            sessionId: this.getSessionId(),\n            roomId: roomId,\n            member: member,\n            timestamp: timestamp\n        };\n\n        return this._mqWebSocket.sendRequest('chat.UpdateMember', updateMember, callback);\n    };\n\n    PCastProtocol.prototype.updateRoom = function(room, timestamp, callback) {\n        assert.isObject(room, 'room');\n        assert.isNumber(timestamp, 'timestamp');\n        assert.isFunction(callback, 'callback');\n\n        var updateRoom = {\n            sessionId: this.getSessionId(),\n            room: room,\n            timestamp: timestamp\n        };\n\n        return this._mqWebSocket.sendRequest('chat.UpdateRoom', updateRoom, callback);\n    };\n\n    PCastProtocol.prototype.sendMessageToRoom = function(roomId, chatMessage, callback) {\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isObject(chatMessage, 'chatMessage');\n\n        var sendMessage = {\n            roomId: roomId,\n            chatMessage: chatMessage\n        };\n\n        return this._mqWebSocket.sendRequest('chat.SendMessageToRoom', sendMessage, callback);\n    };\n\n    PCastProtocol.prototype.subscribeToRoomConversation = function(sessionId, roomId, batchSize, callback) {\n        assert.isStringNotEmpty(sessionId, 'sessionId');\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isNumber(batchSize, 'batchSize');\n\n        var fetchRoomConversation = {\n            sessionId: sessionId,\n            roomId: roomId,\n            limit: batchSize,\n            options: ['Subscribe']\n        };\n\n        return this._mqWebSocket.sendRequest('chat.FetchRoomConversation', fetchRoomConversation, callback);\n    };\n\n    PCastProtocol.prototype.getMessages = function(sessionId, roomId, batchSize, afterMessageId, beforeMessageId, callback) {\n        assert.isStringNotEmpty(sessionId, 'sessionId');\n        assert.isStringNotEmpty(roomId, 'roomId');\n\n        if (!beforeMessageId || !afterMessageId) {\n            assert.isNumber(batchSize, 'batchSize');\n        }\n\n        var fetchRoomConversation = {\n            sessionId: sessionId,\n            roomId: roomId,\n            limit: batchSize || 0,\n            options: []\n        };\n\n        if (beforeMessageId) {\n            assert.isStringNotEmpty(beforeMessageId, 'beforeMessageId');\n\n            fetchRoomConversation.beforeMessageId = beforeMessageId;\n        }\n\n        if (afterMessageId) {\n            assert.isStringNotEmpty(afterMessageId, 'afterMessageId');\n\n            fetchRoomConversation.afterMessageId = afterMessageId;\n        }\n\n        return this._mqWebSocket.sendRequest('chat.FetchRoomConversation', fetchRoomConversation, callback);\n    };\n\n    PCastProtocol.prototype.toString = function() {\n        return 'PCastProtocol[' + this._mqWebSocket.toString() + ']';\n    };\n\n    return PCastProtocol;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var pcastProto = {\n        \"package\": \"pcast\",\n        \"options\": {\"optimize_for\": \"LITE_RUNTIME\"},\n        \"messages\": [\n            {\n                \"name\": \"Authenticate\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 9,\n                        \"options\": {\"default\": 0}\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"clientVersion\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"device\",\n                        \"id\": 12\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"deviceId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"manufacturer\",\n                        \"id\": 13\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"platform\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"platformVersion\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"authenticationToken\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"connectionId\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"connectionRouteKey\",\n                        \"id\": 10\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"remoteAddress\",\n                        \"id\": 11\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 7\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 8\n                    }\n                ]\n            },\n            {\n                \"name\": \"AuthenticateResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"redirect\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"roles\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"Bye\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"ByeResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"SessionDescription\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Type\",\n                        \"name\": \"type\",\n                        \"id\": 1,\n                        \"options\": {\"default\": \"Offer\"}\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sdp\",\n                        \"id\": 2\n                    }\n                ],\n                \"enums\": [\n                    {\n                        \"name\": \"Type\",\n                        \"values\": [\n                            {\n                                \"name\": \"Offer\",\n                                \"id\": 0\n                            },\n                            {\n                                \"name\": \"Answer\",\n                                \"id\": 1\n                            }\n                        ]\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"originStreamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"originStreamIds\",\n                        \"id\": 10\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"connectUri\",\n                        \"id\": 8\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"connectOptions\",\n                        \"id\": 9\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"userAgent\",\n                        \"id\": 11\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"SetRemoteDescription\",\n                        \"name\": \"setRemoteDescription\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"CreateOfferDescription\",\n                        \"name\": \"createOfferDescription\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"CreateAnswerDescription\",\n                        \"name\": \"createAnswerDescription\",\n                        \"id\": 7\n                    }\n                ]\n            },\n            {\n                \"name\": \"IceServer\",\n                \"fields\": [\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"urls\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"username\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"credential\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"RtcConfiguration\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"BundlePolicy\",\n                        \"name\": \"bundlePolicy\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"iceCandidatePoolSize\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"IceServer\",\n                        \"name\": \"iceServers\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"IceTransportPolicy\",\n                        \"name\": \"iceTransportPolicy\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"peerIdentity\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"RtcpMuxPolicy\",\n                        \"name\": \"rtcpMuxPolicy\",\n                        \"id\": 7\n                    }\n                ],\n                \"enums\": [\n                    {\n                        \"name\": \"BundlePolicy\",\n                        \"values\": [\n                            {\n                                \"name\": \"BundlePolicyBalanced\",\n                                \"id\": 1\n                            },\n                            {\n                                \"name\": \"BundlePolicyMaxCompat\",\n                                \"id\": 2\n                            },\n                            {\n                                \"name\": \"BundlePolicyMaxBundle\",\n                                \"id\": 3\n                            }\n                        ]\n                    },\n                    {\n                        \"name\": \"IceTransportPolicy\",\n                        \"values\": [\n                            {\n                                \"name\": \"IceTransportPolicyAll\",\n                                \"id\": 1\n                            },\n                            {\n                                \"name\": \"IceTransportPolicyPublic\",\n                                \"id\": 2\n                            },\n                            {\n                                \"name\": \"IceTransportPolicyRelay\",\n                                \"id\": 3\n                            }\n                        ]\n                    },\n                    {\n                        \"name\": \"RtcpMuxPolicy\",\n                        \"values\": [\n                            {\n                                \"name\": \"RtcpMuxPolicyNegotiate\",\n                                \"id\": 1\n                            },\n                            {\n                                \"name\": \"RtcpMuxPolicyRequire\",\n                                \"id\": 2\n                            }\n                        ]\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"instanceRouteKey\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"streamUris\",\n                        \"id\": 8\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"RtcConfiguration\",\n                        \"name\": \"rtcConfiguration\",\n                        \"id\": 9\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"SetRemoteDescriptionResponse\",\n                        \"name\": \"setRemoteDescriptionResponse\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"CreateOfferDescriptionResponse\",\n                        \"name\": \"createOfferDescriptionResponse\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"CreateAnswerDescriptionResponse\",\n                        \"name\": \"createAnswerDescriptionResponse\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 7\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint64\",\n                        \"name\": \"offset\",\n                        \"id\": 10,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetLocalDescription\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"SessionDescription\",\n                        \"name\": \"sessionDescription\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetLocalDescriptionResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetRemoteDescription\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"SessionDescription\",\n                        \"name\": \"sessionDescription\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetRemoteDescriptionResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"SessionDescription\",\n                        \"name\": \"sessionDescription\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateOfferDescription\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateOfferDescriptionResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"SessionDescription\",\n                        \"name\": \"sessionDescription\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateAnswerDescription\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateAnswerDescriptionResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"SessionDescription\",\n                        \"name\": \"sessionDescription\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"IceCandidate\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"candidate\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"sdpMLineIndex\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sdpMid\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"AddIceCandidates\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"IceCandidate\",\n                        \"name\": \"candidates\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 4,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"AddIceCandidatesResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateStreamState\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"signalingState\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"iceGatheringState\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"iceConnectionState\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 5,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateStreamStateResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"DestroyStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"DestroyStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"ConnectionDisconnected\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"connectionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"reasonCode\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"description\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"ConnectionDisconnectedResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamStarted\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SourceStreamStarted\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"capabilities\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamEnded\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"continuationId\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"routeKey\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"SourceStreamEnded\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"capabilities\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 5\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamEndedResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"continuationId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"routeKey\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamIdle\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamArchived\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"startTime\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"uri\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SessionEnded\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"float\",\n                        \"name\": \"duration\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"ResourceIdle\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"routeKey\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"ResourceIdleResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamPlaylist\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"PlaylistType\",\n                        \"name\": \"playlistType\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"uri\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"bool\",\n                        \"name\": \"isVariant\",\n                        \"id\": 5,\n                        \"options\": {\"default\": true}\n                    }\n                ],\n                \"enums\": [\n                    {\n                        \"name\": \"PlaylistType\",\n                        \"values\": [\n                            {\n                                \"name\": \"Live\",\n                                \"id\": 0\n                            },\n                            {\n                                \"name\": \"OnDemand\",\n                                \"id\": 1\n                            }\n                        ]\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamRtmp\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"uri\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"height\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"bitrate\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendEventToClient\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"connectionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"type\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"bytes\",\n                        \"name\": \"payload\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendEventToClientResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendRequestToClient\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"connectionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"type\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"bytes\",\n                        \"name\": \"payload\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendRequestToClientResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"type\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"bytes\",\n                        \"name\": \"payload\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetupStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamToken\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"CreateStream\",\n                        \"name\": \"createStream\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetupStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"CreateStreamResponse\",\n                        \"name\": \"createStreamResponse\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetupPlaylistStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamToken\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"tags\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"PlaylistStreamManifest\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"manifest\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"bool\",\n                        \"name\": \"isProtectedContent\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"drmToken\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetupPlaylistStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"PlaylistStreamManifest\",\n                        \"name\": \"manifests\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint64\",\n                        \"name\": \"offset\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 0}\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamDataQuality\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"DataQualityStatus\",\n                        \"name\": \"status\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"DataQualityReason\",\n                        \"name\": \"reason\",\n                        \"id\": 5\n                    }\n                ],\n                \"enums\": [\n                    {\n                        \"name\": \"DataQualityStatus\",\n                        \"values\": [\n                            {\n                                \"name\": \"NoData\",\n                                \"id\": 0\n                            },\n                            {\n                                \"name\": \"AudioOnly\",\n                                \"id\": 1\n                            },\n                            {\n                                \"name\": \"All\",\n                                \"id\": 2\n                            }\n                        ]\n                    },\n                    {\n                        \"name\": \"DataQualityReason\",\n                        \"values\": [\n                            {\n                                \"name\": \"None\",\n                                \"id\": 0\n                            },\n                            {\n                                \"name\": \"UploadLimited\",\n                                \"id\": 1\n                            },\n                            {\n                                \"name\": \"DownloadLimited\",\n                                \"id\": 2\n                            },\n                            {\n                                \"name\": \"PublisherLimited\",\n                                \"id\": 3\n                            },\n                            {\n                                \"name\": \"NetworkLimited\",\n                                \"id\": 4\n                            }\n                        ]\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamDataQualityResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"CallbackEvent\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"apiVersion\",\n                        \"id\": 1,\n                        \"options\": {\"default\": 0}\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"entity\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"what\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"data\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 5\n                    }\n                ]\n            },\n            {\n                \"name\": \"Uri\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"protocol\",\n                        \"id\": 1,\n                        \"options\": {\"default\": \"http\"}\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"host\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"port\",\n                        \"id\": 3,\n                        \"options\": {\"default\": 80}\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"method\",\n                        \"id\": 4,\n                        \"options\": {\"default\": \"POST\"}\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"path\",\n                        \"id\": 5,\n                        \"options\": {\"default\": \"/\"}\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetApplicationCallback\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Uri\",\n                        \"name\": \"callback\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"SetApplicationCallbackResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"endpoint\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueAuthenticationToken\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"capabilities\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueAuthenticationTokenResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"authenticationToken\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueStreamToken\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"originStreamId\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"alternateOriginStreamIds\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"capabilities\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"bool\",\n                        \"name\": \"permissive\",\n                        \"id\": 7,\n                        \"options\": {\"default\": false}\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueStreamTokenResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamToken\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueDrmToken\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"originStreamId\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"capabilities\",\n                        \"id\": 5\n                    }\n                ]\n            },\n            {\n                \"name\": \"IssueDrmTokenResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"drmToken\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"TerminateStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 3,\n                        \"oneof\": \"streamOrToken\"\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamToken\",\n                        \"id\": 5,\n                        \"oneof\": \"streamOrToken\"\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 4\n                    }\n                ],\n                \"oneofs\": {\n                    \"streamOrToken\": [\n                        3,\n                        5\n                    ]\n                }\n            },\n            {\n                \"name\": \"TerminateStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"DeleteStream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 3,\n                        \"oneof\": \"streamOrToken\"\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"streamToken\",\n                        \"id\": 5,\n                        \"oneof\": \"streamOrToken\"\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"reason\",\n                        \"id\": 4\n                    }\n                ],\n                \"oneofs\": {\n                    \"streamOrToken\": [\n                        3,\n                        5\n                    ]\n                }\n            },\n            {\n                \"name\": \"DeleteStreamResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"Stream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"ListStreams\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"start\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"length\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 5\n                    }\n                ]\n            },\n            {\n                \"name\": \"ListStreamsResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"start\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint32\",\n                        \"name\": \"length\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Stream\",\n                        \"name\": \"streams\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"GetPlaylistUris\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"streamId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"GetPlaylistUrisResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Playlist\",\n                        \"name\": \"playlists\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"StreamMetadata\",\n                        \"name\": \"streamInfo\",\n                        \"id\": 3\n                    }\n                ],\n                \"messages\": [\n                    {\n                        \"name\": \"PlaylistMetadata\",\n                        \"fields\": [\n                            {\n                                \"rule\": \"optional\",\n                                \"type\": \"uint32\",\n                                \"name\": \"bitrate\",\n                                \"id\": 1\n                            },\n                            {\n                                \"rule\": \"optional\",\n                                \"type\": \"uint32\",\n                                \"name\": \"height\",\n                                \"id\": 2\n                            },\n                            {\n                                \"rule\": \"optional\",\n                                \"type\": \"float\",\n                                \"name\": \"framesPerSecond\",\n                                \"id\": 3\n                            }\n                        ]\n                    },\n                    {\n                        \"name\": \"StreamMetadata\",\n                        \"fields\": [\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"string\",\n                                \"name\": \"startTime\",\n                                \"id\": 1\n                            },\n                            {\n                                \"rule\": \"optional\",\n                                \"type\": \"string\",\n                                \"name\": \"endTime\",\n                                \"id\": 2\n                            }\n                        ]\n                    },\n                    {\n                        \"name\": \"Playlist\",\n                        \"fields\": [\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"string\",\n                                \"name\": \"name\",\n                                \"id\": 1\n                            },\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"PlaylistType\",\n                                \"name\": \"type\",\n                                \"id\": 2\n                            },\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"string\",\n                                \"name\": \"uri\",\n                                \"id\": 3\n                            },\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"bool\",\n                                \"name\": \"isVariant\",\n                                \"id\": 4\n                            },\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"bool\",\n                                \"name\": \"isProtected\",\n                                \"id\": 5\n                            },\n                            {\n                                \"rule\": \"required\",\n                                \"type\": \"PlaylistMetadata\",\n                                \"name\": \"info\",\n                                \"id\": 6\n                            }\n                        ]\n                    }\n                ],\n                \"enums\": [\n                    {\n                        \"name\": \"PlaylistType\",\n                        \"values\": [\n                            {\n                                \"name\": \"Hls\",\n                                \"id\": 0\n                            },\n                            {\n                                \"name\": \"Dash\",\n                                \"id\": 1\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n\n    return pcastProto;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var chatProto = {\n        \"package\": \"chat\",\n        \"options\": {\"optimize_for\": \"LITE_RUNTIME\"},\n        \"messages\": [\n            {\n                \"name\": \"Room\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"alias\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"name\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"description\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"RoomType\",\n                        \"name\": \"type\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"bridgeId\",\n                        \"id\": 7\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"pin\",\n                        \"id\": 8\n                    }\n                ]\n            },\n            {\n                \"name\": \"Stream\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"StreamType\",\n                        \"name\": \"type\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"uri\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"TrackState\",\n                        \"name\": \"audioState\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"TrackState\",\n                        \"name\": \"videoState\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"Member\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"screenName\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"MemberRole\",\n                        \"name\": \"role\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Stream\",\n                        \"name\": \"streams\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"MemberState\",\n                        \"name\": \"state\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"lastUpdate\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"MemberUpdate\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"screenName\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"MemberRole\",\n                        \"name\": \"role\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"bool\",\n                        \"name\": \"updateStreams\",\n                        \"id\": 7,\n                        \"options\": {\"default\": false}\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Stream\",\n                        \"name\": \"streams\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"MemberState\",\n                        \"name\": \"state\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"lastUpdate\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"ChatUser\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"screenName\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"MemberRole\",\n                        \"name\": \"role\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"lastUpdate\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"ChatMessage\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"messageId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"ChatUser\",\n                        \"name\": \"from\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"message\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"CreateRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"JoinRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"alias\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Member\",\n                        \"name\": \"member\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"JoinRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Member\",\n                        \"name\": \"members\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"Member\",\n                        \"name\": \"self\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateMember\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"MemberUpdate\",\n                        \"name\": \"member\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"UpdateMemberResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"uint64\",\n                        \"name\": \"lastUpdate\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"LeaveRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"LeaveRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"DestroyRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"DestroyRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"GetRoomInfo\",\n                \"fields\": [\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"alias\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"applicationId\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"secret\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"GetRoomInfoResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Member\",\n                        \"name\": \"members\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomEvent\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"RoomEventType\",\n                        \"name\": \"eventType\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"Member\",\n                        \"name\": \"members\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"Room\",\n                        \"name\": \"room\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"string\",\n                        \"name\": \"options\",\n                        \"id\": 6\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint64\",\n                        \"name\": \"timestamp\",\n                        \"id\": 7\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendMessageToRoom\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"ChatMessage\",\n                        \"name\": \"chatMessage\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"SendMessageToRoomResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    }\n                ]\n            },\n            {\n                \"name\": \"FetchRoomConversation\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"afterMessageId\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"optional\",\n                        \"type\": \"string\",\n                        \"name\": \"beforeMessageId\",\n                        \"id\": 4\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"uint32\",\n                        \"name\": \"limit\",\n                        \"id\": 5\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"RoomConversationOption\",\n                        \"name\": \"options\",\n                        \"id\": 6\n                    }\n                ]\n            },\n            {\n                \"name\": \"FetchRoomConversationResponse\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"status\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"ChatMessage\",\n                        \"name\": \"chatMessages\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomConversationEvent\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"sessionId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 2\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"RoomConversationEventType\",\n                        \"name\": \"eventType\",\n                        \"id\": 3\n                    },\n                    {\n                        \"rule\": \"repeated\",\n                        \"type\": \"ChatMessage\",\n                        \"name\": \"chatMessages\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomBridgeIdle\",\n                \"fields\": [\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"roomId\",\n                        \"id\": 1\n                    },\n                    {\n                        \"rule\": \"required\",\n                        \"type\": \"string\",\n                        \"name\": \"bridgeId\",\n                        \"id\": 2\n                    }\n                ]\n            }\n        ],\n        \"enums\": [\n            {\n                \"name\": \"RoomType\",\n                \"values\": [\n                    {\n                        \"name\": \"DirectChat\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"MultiPartyChat\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"ModeratedChat\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"TownHall\",\n                        \"id\": 3\n                    },\n                    {\n                        \"name\": \"Channel\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"MemberRole\",\n                \"values\": [\n                    {\n                        \"name\": \"Participant\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"Moderator\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"Presenter\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"Audience\",\n                        \"id\": 3\n                    }\n                ]\n            },\n            {\n                \"name\": \"MemberState\",\n                \"values\": [\n                    {\n                        \"name\": \"Active\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"Passive\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"HandRaised\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"Inactive\",\n                        \"id\": 3\n                    },\n                    {\n                        \"name\": \"Offline\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomEventType\",\n                \"values\": [\n                    {\n                        \"name\": \"MemberJoined\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"MemberLeft\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"MemberUpdated\",\n                        \"id\": 2\n                    },\n                    {\n                        \"name\": \"RoomUpdated\",\n                        \"id\": 3\n                    },\n                    {\n                        \"name\": \"RoomEnded\",\n                        \"id\": 4\n                    }\n                ]\n            },\n            {\n                \"name\": \"TrackState\",\n                \"values\": [\n                    {\n                        \"name\": \"TrackEnabled\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"TrackDisabled\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"TrackEnded\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"StreamType\",\n                \"values\": [\n                    {\n                        \"name\": \"User\",\n                        \"id\": 0\n                    },\n                    {\n                        \"name\": \"Presentation\",\n                        \"id\": 1\n                    },\n                    {\n                        \"name\": \"Audio\",\n                        \"id\": 2\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomConversationOption\",\n                \"values\": [\n                    {\n                        \"name\": \"Subscribe\",\n                        \"id\": 0\n                    }\n                ]\n            },\n            {\n                \"name\": \"RoomConversationEventType\",\n                \"values\": [\n                    {\n                        \"name\": \"Message\",\n                        \"id\": 0\n                    }\n                ]\n            }\n        ]\n    };\n\n    return chatProto;\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__47__;","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* global chrome */\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-rtc'\n], function(_, assert, observable, phenixRTC) {\n    'use strict';\n\n    var defaultChromePCastScreenSharingExtensionId = 'icngjadgidcmifnehjcielbmiapkhjpn';\n    var minimumSupportFirefoxVersionForUnWhiteListedScreenShare = 52;\n\n    function ScreenShareExtensionManager(options, logger) {\n        options = options || {};\n\n        assert.isObject(options, 'options');\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n        this._screenSharingExtensionId = options.screenSharingExtensionId || getDefaultExtensionId();\n        this._eagerlyCheckScreenSharingCapabilities = options.eagerlyCheckScreenSharingCapabilities || false;\n        this._screenSharingAvailable = false;\n        this._isInitializedObservable = new observable.Observable(false);\n\n        if (this._eagerlyCheckScreenSharingCapabilities) {\n            checkForScreenSharingCapability.call(this, _.bind(handleCheckForScreenSharing, this));\n        } else {\n            handleCheckForScreenSharing.call(this, false);\n        }\n    }\n\n    ScreenShareExtensionManager.prototype.checkForScreenSharingCapability = function(callback) {\n        return checkForScreenSharingCapability.call(this, function(isEnabled) {\n            handleCheckForScreenSharing.call(this, isEnabled);\n\n            callback(isEnabled);\n        });\n    };\n\n    ScreenShareExtensionManager.prototype.isScreenSharingEnabled = function(callback) {\n        var that = this;\n\n        return waitForInitialized.call(this, function() {\n            if (that._eagerlyCheckScreenSharingCapabilities || that._screenSharingAvailable) {\n                return callback(that._screenSharingAvailable);\n            }\n\n            checkForScreenSharingCapability.call(that, function(isEnabled) {\n                that._screenSharingAvailable = isEnabled;\n\n                callback(isEnabled);\n            });\n        });\n    };\n\n    ScreenShareExtensionManager.prototype.getScreenSharingConstraints = function(options, callback) {\n        return waitForInitialized.call(this, _.bind(getScreenSharingConstraints, this, options, callback));\n    };\n\n    ScreenShareExtensionManager.prototype.toString = function() {\n        return 'ScreenShareExtensionManager[' + phenixRTC.browser + ']';\n    };\n\n    function handleCheckForScreenSharing(isEnabled) {\n        this._isInitializedObservable.setValue(true);\n\n        this._screenSharingAvailable = isEnabled;\n    }\n\n    function checkForScreenSharingCapability(callback) {\n        var that = this;\n\n        if (phenixRTC.browser === 'Chrome' && that._screenSharingExtensionId) {\n            var runtimeEnvironment = getRuntime.call(this);\n\n            if (!runtimeEnvironment) {\n                return callback(false);\n            }\n\n            try {\n                runtimeEnvironment.sendMessage(that._screenSharingExtensionId, {type: 'version'}, function(response) {\n                    if (runtimeEnvironment.lastError || !response || response.status !== 'ok') {\n                        that._logger.info('Screen sharing NOT available');\n                        callback(false);\n\n                        return;\n                    }\n\n                    that._logger.info('Screen sharing enabled using version [%s]', response.version);\n                    callback(true);\n                });\n            } catch (e) {\n                if (e.message) {\n                    that._logger.warn(e.message, e);\n                }\n\n                callback(false);\n            }\n        } else if (phenixRTC.browser === 'Firefox' && phenixRTC.browserVersion >= minimumSupportFirefoxVersionForUnWhiteListedScreenShare) {\n            callback(true);\n        } else if (phenixRTC.browser === 'Firefox' && _.isObject(phenixRTC.global.PCastScreenSharing)) {\n            callback(true);\n        } else {\n            callback(false);\n        }\n    }\n\n    function waitForInitialized(callback) {\n        if (this._isInitializedObservable.getValue()) {\n            return callback();\n        }\n\n        var initializedSubscription = this._isInitializedObservable.subscribe(function() {\n            initializedSubscription.dispose();\n\n            return callback();\n        });\n    }\n\n    function getScreenSharingConstraints(options, callback) {\n        switch (phenixRTC.browser) {\n        case 'Chrome':\n            return requestMediaSourceIdWithRuntime.call(this, function(error, response) {\n                if (error || (response && response.status !== 'ok')) {\n                    return callback(error, response);\n                }\n\n                // Default to allow the user to request audio if using an older extension or not providing the options\n                // If it fails to request the audio the user will receive an error\n                if (!response.data && !response.options) {\n                    response.options = {canRequestAudioTrack: true};\n                }\n\n                callback(null, {\n                    status: 'ok',\n                    constraints: mapChromeConstraints(options, response.streamId, response.options)\n                });\n            });\n        case 'Firefox':\n            callback(null, {\n                status: 'ok',\n                constraints: mapNewerConstraints(options)\n            });\n\n            break;\n        default:\n            callback(new Error('not-supported'), {status: 'not-supported'});\n\n            break;\n        }\n    }\n\n    function requestMediaSourceIdWithRuntime(callback) {\n        var that = this;\n        var runtimeEnvironment = getRuntime.call(this);\n\n        if (!runtimeEnvironment) {\n            return callback(new Error('not-available'));\n        }\n\n        try {\n            runtimeEnvironment.sendMessage(that._screenSharingExtensionId, {\n                type: 'get-desktop-media',\n                sources: ['screen', 'window', 'tab', 'audio']\n            }, function(response) {\n                var shouldCheckIfScreenShareStillInstalled = runtimeEnvironment.lastError || !response;\n\n                if (shouldCheckIfScreenShareStillInstalled) {\n                    return checkForScreenSharingCapability.call(that, function(isEnabled) {\n                        handleCheckForScreenSharing.call(that, isEnabled);\n\n                        return callback(new Error('extension-failure'));\n                    });\n                }\n\n                if (response.status !== 'ok') {\n                    callback(new Error(response.status), response);\n\n                    return;\n                }\n\n                callback(null, response);\n            });\n        } catch (e) {\n            if (e.message) {\n                that._logger.warn(e.message);\n            }\n\n            callback(e, {status: 'failed'});\n        }\n    }\n\n    function mapChromeConstraints(options, id, captureOptions) {\n        var constraints = {};\n\n        if (_.isObject(options) && _.isObject(options.screen)) {\n            constraints.video = options.screen;\n        }\n\n        if (_.isObject(options) && _.isObject(options.screenAudio) && captureOptions.canRequestAudioTrack) {\n            constraints.audio = options.screenAudio;\n        }\n\n        if (options.screen) {\n            _.set(constraints, ['video', 'mandatory'], {\n                chromeMediaSource: 'desktop',\n                chromeMediaSourceId: id\n            });\n        }\n\n        if (options.screenAudio && captureOptions.canRequestAudioTrack) {\n            _.set(constraints, ['audio', 'mandatory'], {\n                chromeMediaSource: 'system',\n                chromeMediaSourceId: id\n            });\n        }\n\n        return constraints;\n    }\n\n    function mapNewerConstraints(options, id) {\n        var constraints = {video: {}};\n\n        if (_.isObject(options) && _.isObject(options.screen)) {\n            constraints.video = options.screen;\n        }\n\n        if (id) {\n            constraints.video.mediaSourceId = id;\n        }\n\n        constraints.video.mediaSource = constraints.video.mediaSource || 'window';\n\n        return constraints;\n    }\n\n    function getRuntime() {\n        var that = this;\n\n        switch (phenixRTC.browser) {\n        case 'Chrome':\n            if (typeof chrome === 'undefined' || !chrome.runtime || !chrome.runtime.sendMessage) {\n                that._logger.info('Screen sharing NOT available. Runtime not supported');\n\n                return null;\n            }\n\n            return chrome.runtime;\n        case 'Firefox':\n        default:\n            return null;\n        }\n    }\n\n    function getDefaultExtensionId() {\n        switch (phenixRTC.browser) {\n        case 'Chrome':\n            return defaultChromePCastScreenSharingExtensionId;\n        case 'Firefox':\n        default:\n            return '';\n        }\n    }\n\n    return ScreenShareExtensionManager;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-rtc'\n], function(_, assert, rtc) {\n    'use strict';\n\n    var listenForMediaStreamTrackChangesTimeout = 2000;\n\n    function UserMediaProvider(logger, screenShareExtensionManager, onScreenShare) {\n        assert.isObject(logger, 'logger');\n        assert.isObject(screenShareExtensionManager, 'screenShareExtensionManager');\n\n        if (onScreenShare) {\n            assert.isFunction(onScreenShare, 'onScreenShare');\n        }\n\n        this._logger = logger;\n        this._screenShareExtensionManager = screenShareExtensionManager;\n        this._onScreenShare = onScreenShare;\n    }\n\n    UserMediaProvider.prototype.getUserMedia = function(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        getUserMedia.call(this, options, callback);\n    };\n\n    function getUserMedia(options, callback) {\n        var that = this;\n\n        var onUserMediaSuccess = function onUserMediaSuccess(status, stream) {\n            if (that._gumStreams) {\n                that._gumStreams.push(stream);\n            }\n\n            callback(that, status, stream);\n        };\n\n        var onUserMediaFailure = function onUserMediaFailure(status, stream, error) {\n            if (options.screenAudio) {\n                that._logger.warn('Screen capture with audio is only supported on Windows or Chrome OS.');\n            }\n\n            callback(that, status, stream, error);\n        };\n\n        var hasScreen = options.screen || options.screenAudio;\n        var hasVideoOrAudio = options.video || options.audio;\n\n        if (!(hasScreen && hasVideoOrAudio)) {\n            return getUserMediaStream.call(that, options, onUserMediaSuccess, onUserMediaFailure);\n        }\n\n        return getUserMediaStream.call(that, {screen: options.screen}, function success(status, screenStream) {\n            return getUserMediaStream.call(that, {\n                audio: options.audio,\n                video: options.video\n            }, function screenSuccess(status, stream) {\n                addTracksToWebRTCStream(stream, screenStream.getTracks());\n\n                onUserMediaSuccess(status, stream);\n            }, function failure(status, stream, error) {\n                stopWebRTCStream(screenStream);\n\n                onUserMediaFailure(status, stream, error);\n            });\n        }, onUserMediaFailure);\n    }\n\n    function getUserMediaStream(options, successCallback, failureCallback) {\n        var that = this;\n\n        var onUserMediaCancelled = function onUserMediaCancelled() {\n            failureCallback('cancelled', null);\n        };\n\n        var onUserMediaFailure = function onUserMediaFailure(e) {\n            failureCallback(getUserMediaErrorStatus(e), undefined, e);\n        };\n\n        var onUserMediaSuccess = function onUserMediaSuccess(stream) {\n            wrapNativeMediaStream.call(that, stream);\n\n            successCallback('ok', stream);\n        };\n\n        return getUserMediaConstraints.call(this, options, function(error, response) {\n            if (_.get(response, ['status']) !== 'ok') {\n                return onUserMediaFailure(error);\n            }\n\n            if (response.status === 'cancelled') {\n                return onUserMediaCancelled();\n            }\n\n            var constraints = response.constraints;\n\n            if (that._onScreenShare && (options.screen || options.screenAudio) && rtc.browser === 'Chrome') {\n                constraints = that._onScreenShare(constraints);\n\n                if (!constraints) {\n                    throw new Error('onScreenShare must return an object of user media constraints');\n                }\n            }\n\n            try {\n                rtc.getUserMedia(constraints, onUserMediaSuccess, onUserMediaFailure);\n            } catch (e) {\n                onUserMediaFailure(e);\n            }\n        });\n    }\n\n    function getUserMediaConstraints(options, callback) {\n        var that = this;\n\n        if (options.screen) {\n            return that._screenShareExtensionManager.isScreenSharingEnabled(function(isEnabled) {\n                if (isEnabled) {\n                    return that._screenShareExtensionManager.getScreenSharingConstraints(options, callback);\n                }\n\n                return callback(new Error('screen-sharing-not-available'));\n            });\n        }\n\n        var constraints = {\n            audio: options.audio || false,\n            video: options.video || false\n        };\n\n        callback(null, {\n            status: 'ok',\n            constraints: constraints\n        });\n    }\n\n    var getUserMediaErrorStatus = function getUserMediaErrorStatus(e) {\n        var status;\n\n        if (e.code === 'unavailable') {\n            status = 'conflict';\n        } else if (e.message === 'permission-denied') {\n            status = 'permission-denied';\n        } else if (e.name === 'PermissionDeniedError') { // Chrome\n            status = 'permission-denied';\n        } else if (e.name === 'InternalError' && e.message === 'Starting video failed') { // FF (old getUserMedia API)\n            status = 'conflict';\n        } else if (e.name === 'SourceUnavailableError') { // FF\n            status = 'conflict';\n        } else if (e.name === 'SecurityError' && e.message === 'The operation is insecure.') { // FF\n            status = 'permission-denied';\n        } else {\n            status = 'failed';\n        }\n\n        return status;\n    };\n\n    function wrapNativeMediaStream(stream) {\n        var lastTrackEnabledStates = {};\n        var lastTrackReadyStates = {};\n        var that = this;\n\n        setTimeout(function listenForTrackChanges() {\n            if (isStreamStopped(stream)) {\n                return;\n            }\n\n            _.forEach(stream.getTracks(), function(track) {\n                if (rtc.global.Event && _.hasIndexOrKey(lastTrackEnabledStates, track.id) && lastTrackEnabledStates[track.id] !== track.enabled) {\n                    var trackEnabledChangeEvent = new rtc.global.Event('trackenabledchange');\n\n                    trackEnabledChangeEvent.data = track;\n\n                    track.dispatchEvent(trackEnabledChangeEvent);\n\n                    that._logger.info('[%s] Detected track [%s] enabled change to [%s]', stream.id, track.id, track.enabled);\n                }\n\n                if (rtc.global.Event && _.hasIndexOrKey(lastTrackReadyStates, track.id) && lastTrackReadyStates[track.id] !== track.readyState) {\n                    var readyStateChangeEvent = new rtc.global.Event('readystatechange');\n\n                    readyStateChangeEvent.data = track;\n\n                    track.dispatchEvent(readyStateChangeEvent);\n\n                    that._logger.info('[%s] Detected track [%s] Ready State change to [%s]', stream.id, track.id, track.readyState);\n                }\n\n                lastTrackEnabledStates[track.id] = track.enabled;\n                lastTrackReadyStates[track.id] = track.readyState;\n            });\n\n            setTimeout(listenForTrackChanges, listenForMediaStreamTrackChangesTimeout);\n        }, listenForMediaStreamTrackChangesTimeout);\n    }\n\n    function addTracksToWebRTCStream(stream, tracks) {\n        if (!stream || !_.isFunction(stream.addTrack)) {\n            return;\n        }\n\n        _.forEach(tracks, function(track) {\n            stream.addTrack(track);\n        });\n    }\n\n    function isStreamStopped(stream) {\n        return _.reduce(stream.getTracks(), function(isStopped, track) {\n            return isStopped && isTrackStopped(track);\n        }, true);\n    }\n\n    function isTrackStopped(track) {\n        assert.isNotUndefined(track, 'track');\n\n        return track.readyState === 'ended';\n    }\n\n    function stopWebRTCStream(stream) {\n        if (stream && _.isFunction(stream.stop)) {\n            stream.stop();\n        }\n\n        if (stream && _.isFunction(stream.getTracks)) {\n            var tracks = stream.getTracks();\n\n            for (var i = 0; i < tracks.length; i++) {\n                var track = tracks[i];\n\n                track.stop();\n            }\n        }\n    }\n\n    return UserMediaProvider;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    '../environment',\n    './MetricsTransmitter'\n], function(_, assert, environment, MetricsTransmitter) {\n    function MetricsTransmitterFactory() {\n        this._metricsTransmitters = {};\n    }\n\n    MetricsTransmitterFactory.prototype.createMetricsTransmitter = function createMetricsTransmitter(pcastBaseUri) {\n        var env = environment.getEnvironmentFromUrl(pcastBaseUri || '');\n\n        var telemetryServerUrl = environment.getTelemetryServerUri(pcastBaseUri);\n\n        if (!this._metricsTransmitters[env]) {\n            this._metricsTransmitters[env] = createNewTransmitter.call(this, telemetryServerUrl, env);\n        }\n\n        return this._metricsTransmitters[env];\n    };\n\n    function createNewTransmitter(uri, env) {\n        var transmitter = new MetricsTransmitter(uri, env);\n\n        if (!uri) {\n            transmitter.setEnabled(false);\n        }\n\n        return transmitter;\n    }\n\n    return new MetricsTransmitterFactory();\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-proto',\n    'phenix-rtc',\n    '../protocol/telemetryProto.json'\n], function(_, assert, proto, rtc, telemetryProto) {\n    var metricsUrl = '/metrics';\n\n    function MetricsTransmitter(uri, environment) {\n        assert.isString(uri, 'uri');\n\n        this._domain = typeof location === 'object' ? location.hostname : rtc.browser + '-' + rtc.browserVersion + '-unknown';\n        this._isEnabled = true;\n        this._browser = (rtc.browser || 'Browser') + '/' + (rtc.browserVersion || '?');\n        this._batchHttpProtocol = new proto.BatchHttpProto(uri + metricsUrl, [telemetryProto], 'telemetry.SubmitMetricRecords', {\n            maxAttempts: 3,\n            maxBufferedRecords: 1000,\n            maxBatchSize: 512\n        });\n\n        this._mostRecentEnvironment = environment;\n\n        this._batchHttpProtocol.on('capacity', _.bind(onCapacity, this));\n    }\n\n    MetricsTransmitter.prototype.isEnabled = function isEnabled() {\n        return this._isEnabled;\n    };\n\n    MetricsTransmitter.prototype.setEnabled = function setEnabled(enabled) {\n        assert.isBoolean(enabled, 'enabled');\n\n        this._isEnabled = enabled;\n    };\n\n    MetricsTransmitter.prototype.submitMetric = function submit(metric, since, sessionId, streamId, version, value) {\n        if (!this._isEnabled) {\n            return;\n        }\n\n        assert.isStringNotEmpty(metric, 'metric');\n        assert.isObject(value, 'value');\n\n        this._mostRecentRuntime = since;\n        this._mostRecentSessionId = sessionId;\n        this._mostRecentStreamId = streamId;\n        this._mostRecentVersion = version;\n\n        addMetricToRecords.call(this, metric, value);\n    };\n\n    function addMetricToRecords(metric, value) {\n        var record = _.assign({}, value, {\n            metric: metric,\n            timestamp: _.isoString(),\n            sessionId: this._mostRecentSessionId,\n            streamId: this._mostRecentStreamId,\n            source: this._browser,\n            fullQualifiedName: this._domain,\n            environment: this._mostRecentEnvironment,\n            version: this._mostRecentVersion,\n            runtime: this._mostRecentRuntime\n        });\n\n        this._batchHttpProtocol.addRecord(record);\n    }\n\n    function onCapacity(deleteRecords) {\n        this._batchHttpProtocol.addRecordToBeginning({\n            metric: 'MetricDropped',\n            value: {uint64: deleteRecords},\n            timestamp: _.isoString(),\n            sessionId: this._mostRecentSessionId,\n            streamId: this._mostRecentStreamId,\n            source: this._browser,\n            fullQualifiedName: this._domain,\n            environment: this._mostRecentEnvironment,\n            version: this._mostRecentVersion,\n            runtime: this._mostRecentRuntime\n        });\n    }\n\n    return MetricsTransmitter;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-disposable',\n    'phenix-rtc'\n], function(_, assert, disposable, phenixRTC) {\n    'use strict';\n\n    var start = phenixRTC.global['__phenixPageLoadTime'] || phenixRTC.global['__pageLoadTime'] || _.now();\n    var sdkVersion = '2022-04-13T15:08:08Z' || '?';\n\n    function StreamTelemetry(sessionId, logger, metricsTransmitter) {\n        assert.isStringNotEmpty(sessionId, 'sessionId');\n\n        this._version = sdkVersion;\n        this._sessionId = sessionId;\n        this._properties = {};\n        this._logger = logger;\n        this._metricsTransmitter = metricsTransmitter;\n        this._start = _.now();\n        this._disposables = new disposable.DisposableList();\n        this._dimensionsTrackedVideos = [];\n        this._rebufferingTrackedVideos = [];\n        this._playTrackedVideos = [];\n        this._timeOfFirstFrame = null;\n\n        logMetric.call(this, 'Stream initializing');\n    }\n\n    StreamTelemetry.prototype.setProperty = function(name, value) {\n        assert.isStringNotEmpty(name, 'name');\n        assert.isStringNotEmpty(value, 'value');\n\n        this._properties[name] = value;\n    };\n\n    StreamTelemetry.prototype.recordMetric = function(metric, value, previousValue, additionalProperties) {\n        assert.isStringNotEmpty(metric, 'metric');\n\n        var record = _.assign({}, {\n            metric: metric,\n            elapsed: this.elapsed(),\n            value: value,\n            previousValue: previousValue\n        }, additionalProperties || {});\n\n        recordMetricRecord.call(this, record, since());\n    };\n\n    StreamTelemetry.prototype.setStreamId = function(streamId) {\n        assert.isStringNotEmpty(streamId, 'streamId');\n\n        if (this._streamId) {\n            throw new Error('Stream ID can only be set once.');\n        }\n\n        this._streamId = streamId;\n\n        var now = _.now();\n\n        recordMetricRecord.call(this, {\n            metric: 'Initialized',\n            elapsed: this.elapsed() - now + this._start // Adjust for delay to get the stream ID\n        }, since() - (now - this._start) / 1000); // Adjust for delay to get the stream ID);\n    };\n\n    StreamTelemetry.prototype.setStartOffset = function(startOffset) {\n        assert.isNumber(startOffset, 'startOffset');\n\n        if (this._startOffset) {\n            throw new Error('Start offset can only be set once.');\n        }\n\n        this._startOffset = startOffset;\n\n        this.recordMetric('Offset', {uint64: startOffset});\n    };\n\n    StreamTelemetry.prototype.getStartOffset = function() {\n        return this._startOffset;\n    };\n\n    StreamTelemetry.prototype.elapsed = function() {\n        var now = _.now();\n\n        return now - this._start;\n    };\n\n    StreamTelemetry.prototype.stop = function() {\n        this._disposables.dispose();\n\n        this.recordMetric('Stopped');\n\n        logMetric.call(this, 'Stream stopped');\n    };\n\n    StreamTelemetry.prototype.recordTimeToFirstFrame = function(video) {\n        var that = this;\n        var startRecordingFirstFrame = _.now();\n\n        // Only record first time to first frame regardless of number of times called\n        var listenForFirstFrame = function() {\n            if (that._timeOfFirstFrame) {\n                return;\n            }\n\n            that._timeOfFirstFrame = _.now() - startRecordingFirstFrame;\n\n            that.recordMetric('TimeToFirstFrame', {uint64: that._timeOfFirstFrame});\n            logMetric.call(that, 'First frame [%s]', that._timeOfFirstFrame);\n\n            timeToFirstFrameListenerDisposable.dispose();\n        };\n\n        _.addEventListener(video, 'loadeddata', listenForFirstFrame);\n        _.addEventListener(video, 'loadedmetadata', listenForFirstFrame);\n\n        var timeToFirstFrameListenerDisposable = new disposable.Disposable(function() {\n            _.removeEventListener(video, 'loadeddata', listenForFirstFrame);\n            _.removeEventListener(video, 'loadedmetadata', listenForFirstFrame);\n        });\n\n        // Ensure TTFF is not recorded if stop is called before first frame\n        this._disposables.add(timeToFirstFrameListenerDisposable);\n\n        return timeToFirstFrameListenerDisposable;\n    };\n\n    // TODO(dy) Add logging for bit rate changes using PC.getStats\n    StreamTelemetry.prototype.recordVideoResolutionChanges = function(renderer, video) {\n        var that = this;\n        var lastResolution = {\n            width: video.videoWidth,\n            height: video.videoHeight\n        };\n        var hasListenedToVideo = _.find(this._dimensionsTrackedVideos, function(trackedVideo) {\n            return trackedVideo === video;\n        });\n\n        if (hasListenedToVideo) {\n            return new disposable.Disposable(_.noop);\n        }\n\n        this._dimensionsTrackedVideos.push(video);\n\n        var dimensionChangeDisposable = renderer.addVideoDisplayDimensionsChangedCallback(function(renderer, dimensions) {\n            if (lastResolution.width === dimensions.width && lastResolution.height === dimensions.height) {\n                return;\n            }\n\n            that.recordMetric('ResolutionChanged', {string: dimensions.width + 'x' + dimensions.height}, {string: lastResolution.width + 'x' + lastResolution.height});\n\n            lastResolution = {\n                width: dimensions.width,\n                height: dimensions.height\n            };\n\n            logMetric.call(that, 'Resolution changed: width [%s] height [%s]', dimensions.width, dimensions.height);\n        });\n\n        this._disposables.add(dimensionChangeDisposable);\n\n        return dimensionChangeDisposable;\n    };\n\n    StreamTelemetry.prototype.recordRebuffering = function(video) {\n        var that = this;\n        var videoStalled;\n        var lastProgress;\n        var hasListenedToVideo = _.find(this._rebufferingTrackedVideos, function(trackedVideo) {\n            return trackedVideo === video;\n        });\n\n        if (hasListenedToVideo) {\n            return new disposable.Disposable(_.noop);\n        }\n\n        this._rebufferingTrackedVideos.push(video);\n\n        var listenForStall = function() {\n            if (videoStalled) {\n                return;\n            }\n\n            that.recordMetric('Stalled');\n\n            videoStalled = _.now();\n\n            logMetric.call(that, '[buffering] Stream has stalled');\n        };\n\n        var listenForContinuation = function(event) {\n            var bufferLength = video.buffered.length;\n            var hasNotProgressedSinceLastProgressEvent = event.type === 'playing'\n                                                        || bufferLength > 0 ? (event.type === 'progress'\n                                                        || event.type === 'timeupdate')\n                                                        && video.buffered.end(bufferLength - 1) === lastProgress : true;\n\n            if (!videoStalled || (!bufferLength && phenixRTC.browser !== 'Edge') || hasNotProgressedSinceLastProgressEvent) {\n                return;\n            }\n\n            if (event.type === 'progress') {\n                lastProgress = video.buffered.end(bufferLength - 1);\n            }\n\n            var timeSinceStop = _.now() - videoStalled;\n\n            that.recordMetric('Buffering', {uint64: timeSinceStop});\n\n            logMetric.call(that, '[buffering] Stream has recovered from stall after [%s] milliseconds', timeSinceStop);\n\n            videoStalled = null;\n        };\n\n        _.addEventListener(video, 'stalled', listenForStall);\n        _.addEventListener(video, 'pause', listenForStall);\n        _.addEventListener(video, 'suspend', listenForStall);\n        _.addEventListener(video, 'play', listenForContinuation);\n        _.addEventListener(video, 'playing', listenForContinuation);\n        _.addEventListener(video, 'progress', listenForContinuation);\n        _.addEventListener(video, 'timeupdate', listenForContinuation);\n\n        var rebufferingDisposable = new disposable.Disposable(function() {\n            _.removeEventListener(video, 'stalled', listenForStall);\n            _.removeEventListener(video, 'pause', listenForStall);\n            _.removeEventListener(video, 'suspend', listenForStall);\n            _.removeEventListener(video, 'play', listenForContinuation);\n            _.removeEventListener(video, 'playing', listenForContinuation);\n            _.removeEventListener(video, 'progress', listenForContinuation);\n            _.removeEventListener(video, 'timeupdate', listenForContinuation);\n        });\n\n        this._disposables.add(rebufferingDisposable);\n\n        return rebufferingDisposable;\n    };\n\n    StreamTelemetry.prototype.recordVideoPlayingAndPausing = function(video) {\n        var that = this;\n        var hasListenedToVideo = _.find(this._playTrackedVideos, function(trackedVideo) {\n            return trackedVideo === video;\n        });\n\n        if (hasListenedToVideo) {\n            return new disposable.Disposable(_.noop);\n        }\n\n        this._playTrackedVideos.push(video);\n\n        var listenForPlayChange = function() {\n            if (video.paused) {\n                that.recordMetric('Playing', {boolean: false});\n            } else {\n                that.recordMetric('Playing', {boolean: true});\n            }\n        };\n\n        _.addEventListener(video, 'pause', listenForPlayChange);\n        _.addEventListener(video, 'playing', listenForPlayChange);\n\n        var playingDisposable = new disposable.Disposable(function() {\n            _.removeEventListener(video, 'pause', listenForPlayChange);\n            _.removeEventListener(video, 'playing', listenForPlayChange);\n        });\n\n        this._disposables.add(playingDisposable);\n\n        return playingDisposable;\n    };\n\n    function logMetric() {\n        var args = Array.prototype.slice.call(arguments);\n\n        if (args.length === 0) {\n            throw new Error('Invalid logging arguments.');\n        }\n\n        var streamTelemetryPrepend = '[%s] [StreamTelemetry] [%s] ';\n        var message = streamTelemetryPrepend + args[0];\n        var loggingArguments = args.slice(1);\n        var telemetryArguments = [message, this._streamId, _.now() - this._start].concat(loggingArguments);\n\n        this._logger.debug.apply(this._logger, telemetryArguments);\n    }\n\n    function since() {\n        var now = _.now();\n\n        return (now - start) / 1000;\n    }\n\n    function recordMetricRecord(record, since) {\n        assert.isStringNotEmpty(record.metric, 'record.metric');\n\n        var annotatedRecord = _.assign({}, this._properties, record);\n\n        this._metricsTransmitter.submitMetric(record.metric, since, this._sessionId, this._streamId, this._version, annotatedRecord);\n    }\n\n    return StreamTelemetry;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-disposable',\n    'phenix-web-application-activity-detector',\n    './NetworkMonitor',\n    'phenix-rtc'\n], function(_, assert, disposable, applicationActivityDetector, NetworkMonitor, phenixRTC) {\n    'use strict';\n\n    var start = phenixRTC.global['__phenixPageLoadTime'] || phenixRTC.global['__pageLoadTime'] || _.now();\n    var sdkVersion = '2022-04-13T15:08:08Z' || '?';\n\n    function SessionTelemetry(logger, metricsTransmitter) {\n        this._version = sdkVersion;\n        this._sessionId = null;\n        this._properties = {\n            resource: 'session',\n            kind: 'event'\n        };\n        this._logger = logger;\n        this._metricsTransmitter = metricsTransmitter;\n        this._networkMonitor = new NetworkMonitor(this._logger);\n        this._start = _.now();\n        this._disposables = new disposable.DisposableList();\n        this._records = [];\n\n        this._disposables.add(applicationActivityDetector.onBackground(_.bind(recordForegroundChange, this, false)));\n        this._disposables.add(applicationActivityDetector.onForeground(_.bind(recordForegroundChange, this, true)));\n\n        if (!this._networkMonitor.isSupported()) {\n            return;\n        }\n\n        this._disposables.add(this._networkMonitor.onNetworkChange(_.bind(logNetworkStatsChange, this)));\n        this._disposables.add(this._networkMonitor);\n\n        recordNetworkTypeState.call(this);\n        recordNetworkDownlinkThroughputCapacity.call(this);\n        recordNetworkRTT.call(this);\n    }\n\n    SessionTelemetry.prototype.setSessionId = function(sessionId) {\n        if (!sessionId && this._sessionId) {\n            recordMetricRecord.call(this, {\n                metric: 'Stopped',\n                elapsed: this.elapsed()\n            }, since());\n        }\n\n        this._sessionId = sessionId;\n\n        if (sessionId) {\n            recordMetricRecord.call(this, {\n                metric: 'Initialized',\n                elapsed: this.elapsed()\n            }, since());\n            recordAllMetrics.call(this);\n            recordForegroundState.call(this);\n\n            if (this._networkMonitor.isSupported()) {\n                recordNetworkTypeState.call(this);\n                recordNetworkDownlinkThroughputCapacity.call(this);\n                recordNetworkRTT.call(this);\n            }\n        }\n    };\n\n    SessionTelemetry.prototype.setProperty = function(name, value) {\n        assert.isStringNotEmpty(name, 'name');\n        assert.isStringNotEmpty(value, 'value');\n\n        this._properties[name] = value;\n    };\n\n    SessionTelemetry.prototype.recordMetric = function(metric, value, previousValue, additionalProperties) {\n        assert.isStringNotEmpty(metric, 'metric');\n\n        var record = _.assign({}, {\n            metric: metric,\n            elapsed: this.elapsed(),\n            value: value,\n            previousValue: previousValue\n        }, additionalProperties || {});\n\n        recordMetricRecord.call(this, record, since());\n    };\n\n    SessionTelemetry.prototype.elapsed = function() {\n        var now = _.now();\n\n        return now - this._start;\n    };\n\n    SessionTelemetry.prototype.dispose = function() {\n        this._disposables.dispose();\n\n        this.recordMetric('Stopped');\n\n        logMetric.call(this, 'Session telemetry stopped');\n    };\n\n    function recordForegroundState() {\n        var isForeground = applicationActivityDetector.isForeground();\n        var timeSinceLastChange = applicationActivityDetector.getTimeSinceLastChange();\n        var metric = isForeground ? 'ApplicationForeground' : 'ApplicationBackground';\n\n        this.recordMetric(metric, {uint64: timeSinceLastChange});\n\n        logMetric.call(this, 'Session has started in the [%s] after [%s] ms', isForeground ? 'foreground' : 'background', timeSinceLastChange);\n    }\n\n    function recordForegroundChange(isForeground, timeSinceLastChange) {\n        var metric = isForeground ? 'ApplicationForeground' : 'ApplicationBackground';\n\n        this.recordMetric(metric, {uint64: timeSinceLastChange});\n\n        logMetric.call(this, 'Application has gone into the [%s] after [%s] ms', isForeground ? 'foreground' : 'background', timeSinceLastChange);\n    }\n\n    function recordNetworkTypeState() {\n        var type = this._networkMonitor.getEffectiveType();\n\n        this.recordMetric('NetworkType', {string: type}, null, {resource: phenixRTC.browser});\n\n        logMetric.call(this, '[%s] has started with Network effective type of [%s]', this._sessionId ? 'Session' : 'Application', type);\n    }\n\n    function recordNetworkTypeChange(newType, previousType) {\n        var newNetworkType = newType || this._networkMonitor.getEffectiveType();\n        var previousNetworkType = previousType;\n\n        this.recordMetric('NetworkType', {string: newNetworkType}, {string: previousNetworkType}, {resource: phenixRTC.browser});\n\n        logMetric.call(this, 'Network effective type has changed to [%s] from [%s]', newNetworkType, previousNetworkType || 'New');\n    }\n\n    function recordNetworkRTT(newValue, oldValue) {\n        var newRTT = newValue || this._networkMonitor.getRoundTripTime();\n        var oldRTT = oldValue || -1;\n\n        this.recordMetric('RoundTripTime', {uint32: newRTT}, {uint32: oldRTT}, {resource: phenixRTC.browser});\n\n        if (_.isNullOrUndefined(oldValue)) {\n            return logMetric.call(this, 'Network RTT [%s]', newRTT);\n        }\n\n        logMetric.call(this, 'Network RTT changed to [%s] from [%s]', newRTT, oldRTT);\n    }\n\n    function recordNetworkDownlinkThroughputCapacity(newValue, oldValue) {\n        var newCapacity = newValue || this._networkMonitor.getDownlinkThroughputCapacity();\n        var oldCapacity = oldValue || -1;\n\n        this.recordMetric('DownlinkThroughputCapacity', {float: newCapacity}, {float: oldCapacity}, {resource: phenixRTC.browser});\n\n        if (_.isNullOrUndefined(oldValue)) {\n            return logMetric.call(this, 'Network downlink throughput capacity [%s]', newCapacity);\n        }\n\n        logMetric.call(this, 'Network downlink throughput capacity changed to [%s] from [%s]', newCapacity, oldCapacity);\n    }\n\n    function logNetworkStatsChange(newStats, oldStats) {\n        if (oldStats.downlinkThroughputCapacity !== newStats.downlinkThroughputCapacity) {\n            recordNetworkDownlinkThroughputCapacity.call(this, newStats.downlinkThroughputCapacity, oldStats.downlinkThroughputCapacity);\n        }\n\n        if (oldStats.rtt !== newStats.rtt) {\n            recordNetworkRTT.call(this, newStats.rtt, oldStats.rtt);\n        }\n\n        if (oldStats.effectiveType !== newStats.effectiveType) {\n            recordNetworkTypeChange.call(this, newStats.effectiveType, oldStats.effectiveType);\n        }\n    }\n\n    function logMetric() {\n        var args = Array.prototype.slice.call(arguments);\n\n        if (args.length === 0) {\n            throw new Error('Invalid logging arguments.');\n        }\n\n        var sessionTelemetryPrepend = '[%s] [SessionTelemetry] [%s] ';\n        var message = sessionTelemetryPrepend + args[0];\n        var loggingArguments = args.slice(1);\n        var telemetryArguments = [message, this._sessionId, _.now() - this._start].concat(loggingArguments);\n\n        this._logger.info.apply(this._logger, telemetryArguments);\n    }\n\n    function since() {\n        var now = _.now();\n\n        return (now - start) / 1000;\n    }\n\n    function recordMetricRecord(record, since) {\n        assert.isStringNotEmpty(record.metric, 'record.metric');\n\n        if (!this._sessionId) {\n            return this._records.push({\n                record: record,\n                since: since\n            });\n        }\n\n        var annotatedRecord = _.assign({}, this._properties, record);\n\n        this._metricsTransmitter.submitMetric(record.metric, since, this._sessionId, null, this._version, annotatedRecord);\n    }\n\n    function recordAllMetrics() {\n        if (!this._sessionId) {\n            return;\n        }\n\n        var that = this;\n        var numberOfRecordsToPush = this._records.length;\n\n        while (numberOfRecordsToPush > 0) {\n            var records = this._records.splice(numberOfRecordsToPush - 1, 1);\n\n            if (records.length === 1) {\n                recordMetricRecord.call(that, records[0].record, records[0].since);\n            }\n\n            numberOfRecordsToPush--;\n        }\n    }\n\n    return SessionTelemetry;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-web-disposable',\n    'phenix-rtc'\n], function(_, assert, event, disposable, rtc) {\n    function NetworkMonitor(logger) {\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n        this._namedEvents = new event.NamedEvents();\n        this._disposables = new disposable.DisposableList();\n\n        this._disposables.add(this._namedEvents);\n\n        if (!this.isSupported()) {\n            return this._logger.info('Network monitor is not supported.');\n        }\n\n        this._lastNetworkStats = getStats.call(this);\n\n        detectNetworkTypeChange.call(this);\n    }\n\n    NetworkMonitor.prototype.isSupported = function() {\n        return rtc.global.navigator && rtc.global.navigator.connection;\n    };\n\n    NetworkMonitor.prototype.getDownlinkThroughputCapacity = function() {\n        if (!this.isSupported()) {\n            return -1;\n        }\n\n        return rtc.global.navigator.connection.downlink || rtc.global.navigator.connection.downlinkMax;\n    };\n\n    NetworkMonitor.prototype.getEffectiveType = function() {\n        if (!this.isSupported()) {\n            return 'Unknown';\n        }\n\n        return rtc.global.navigator.connection.effectiveType || rtc.global.navigator.connection.type;\n    };\n\n    NetworkMonitor.prototype.getRoundTripTime = function() {\n        if (!this.isSupported()) {\n            return -1;\n        }\n\n        return rtc.global.navigator.connection.rtt || rtc.global.navigator.connection.type;\n    };\n\n    NetworkMonitor.prototype.onNetworkChange = function(callback) {\n        if (!this.isSupported()) {\n            return;\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        return this._namedEvents.listen('NetworkChange', callback);\n    };\n\n    NetworkMonitor.prototype.dispose = function() {\n        this._disposables.dispose();\n    };\n\n    function getStats() {\n        return {\n            downlinkThroughputCapacity: this.getDownlinkThroughputCapacity(),\n            effectiveType: this.getEffectiveType(),\n            rtt: this.getRoundTripTime()\n        };\n    }\n\n    function detectNetworkTypeChange() {\n        var that = this;\n\n        navigator.connection.addEventListener('change', function() {\n            that._namedEvents.fireAsync('NetworkChange', [getStats.call(that), that._lastNetworkStats]);\n\n            that._lastNetworkStats = getStats.call(that);\n        });\n    }\n\n    return NetworkMonitor;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    './stream.json'\n], function(_, assert, streamEnums) {\n    'use strict';\n\n    function StreamWrapper(type, stream, logger) {\n        assert.isStringNotEmpty(type, 'type');\n        assert.isObject(stream, 'stream');\n        assert.isObject(logger, 'logger');\n\n        this._type = type;\n        this._stream = stream;\n        this._logger = logger;\n        this._onPlayerEnd = null;\n\n        var that = this;\n\n        this._stream.on(streamEnums.streamEvents.playerEnded.name, function(reason) {\n            that._logger.info('[%s] [%s] player ended.', that._stream.getStreamId(), that._type);\n\n            that._playerEnded = true;\n\n            if (that._onPlayerEnd) {\n                return that._onPlayerEnd();\n            }\n\n            that.streamEndedCallback(StreamWrapper.getStreamEndedStatus(reason), reason);\n        });\n    }\n\n    StreamWrapper.prototype.toString = function() {\n        return 'Stream[' + (this._stream ? this._stream.getStreamId() : '') + ']';\n    };\n\n    StreamWrapper.prototype.on = function(name, callback) {\n        return this._stream.on(name, callback);\n    };\n\n    // TODO(DY) Remove once 'on' is implemented on all Phenix Stream objects\n    StreamWrapper.prototype.streamErrorCallback = function(errorSource, error) {\n        if (!_.isFunction(this._stream.streamErrorCallback)) {\n            this._logger.error('[%s] [%s] stream error event [%s]', this._stream.getStreamId(), this._type, error);\n        } else {\n            this._logger.debug('[%s] [%s] stream error event [%s]', this._stream.getStreamId(), this._type, error);\n            this._stream.streamErrorCallback(this._stream, errorSource, error);\n        }\n    };\n\n    StreamWrapper.prototype.streamEndedCallback = function(status, reason, waitForPlayerEnd) {\n        var renderer = this._stream.getRenderer();\n\n        if (this._isStreamEnded) {\n            return;\n        }\n\n        if (waitForPlayerEnd && !this._onPlayerEnd && this._stream.isActive() && renderer && !this._playerEnded) {\n            this._onPlayerEnd = _.bind(this.streamEndedCallback, this, status, reason);\n\n            this._logger.info('[%s] [%s] stream ended. Waiting for end of player.', this._stream.getStreamId(), this._type);\n\n            if (renderer) {\n                renderer.stop(reason, waitForPlayerEnd);\n            }\n\n            return;\n        }\n\n        this._isStreamEnded = true;\n\n        if (_.isFunction(this._stream.streamEndedCallback)) {\n            this._stream.streamEndedCallback(this._stream, status, reason);\n        }\n\n        this._stream.stop(reason);\n\n        if (renderer) {\n            renderer.stop(reason, waitForPlayerEnd);\n        }\n    };\n\n    StreamWrapper.prototype.dataQualityChangedCallback = function(status, reason) {\n        var renderer = this._stream.getRenderer();\n\n        if (!renderer) {\n            return;\n        }\n\n        if (_.isFunction(renderer.dataQualityChangedCallback)) {\n            renderer.dataQualityChangedCallback(renderer, status, reason);\n        }\n    };\n\n    StreamWrapper.prototype.getPhenixMediaStream = function() {\n        return this._stream;\n    };\n\n    StreamWrapper.getStreamEndedStatus = function getStreamEndedStatus(value) {\n        switch (value) {\n        case '':\n        case 'none':\n        case 'ended':\n            return 'ended';\n        case 'server-error':\n        case 'session-error':\n        case 'not-ready':\n        case 'error':\n        case 'died':\n            return 'failed';\n        case 'censored':\n            return 'censored';\n        case 'maintenance':\n            return 'maintenance';\n        case 'capacity':\n            return 'capacity';\n        case 'app-background':\n            return 'app-background';\n        case 'egress-failed':\n            return 'egress-failed';\n        case 'egress-setup-failed':\n            return 'egress-setup-failed';\n        case 'overload':\n            return 'overload';\n        default:\n            return 'custom';\n        }\n    };\n\n    return StreamWrapper;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-web-http',\n    'phenix-web-disposable',\n    'phenix-rtc',\n    '../DimensionsChangedMonitor',\n    './stream.json'\n], function(_, assert, event, http, disposable, rtc, DimensionsChangedMonitor, streamEnums) {\n    'use strict';\n\n    var widevineServiceCertificate = null;\n    var defaultBandwidthEstimateForPlayback = 2000000; // 2Mbps will select 720p by default\n\n    function ShakaRenderer(streamId, uri, streamTelemetry, options, shaka, logger) {\n        this._logger = logger;\n        this._streamId = streamId;\n        this._manifestUri = encodeURI(uri).replace(/[#]/g, '%23');\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._renderer = null;\n        this._element = null;\n        this._dimensionsChangedMonitor = new DimensionsChangedMonitor(logger);\n        this._lastProgress = {\n            time: 0,\n            buffered: null,\n            averageLength: 0,\n            count: 0\n        };\n        this._namedEvents = new event.NamedEvents();\n        this._disposables = new disposable.DisposableList();\n        this._shaka = shaka;\n\n        this._onStalled = _.bind(stalled, this);\n        this._onProgress = _.bind(onProgress, this);\n        this._onEnded = _.bind(ended, this);\n    }\n\n    ShakaRenderer.prototype.on = function(name, callback) {\n        return this._namedEvents.listen(name, callback);\n    };\n\n    ShakaRenderer.prototype.start = function(elementToAttachTo) {\n        var that = this;\n\n        that._player = new this._shaka.Player(elementToAttachTo);\n\n        this._disposables.add(this._streamTelemetry.recordTimeToFirstFrame(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordRebuffering(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordVideoResolutionChanges(this, elementToAttachTo));\n\n        var playerConfig = {\n            abr: {defaultBandwidthEstimate: defaultBandwidthEstimateForPlayback},\n            manifest: {retryParameters: {timeout: 10000}},\n            streaming: {\n                rebufferingGoal: 2,\n                bufferingGoal: 10,\n                bufferBehind: 30,\n                retryParameters: {\n                    timeout: 10000,\n                    maxAttempts: 10,\n                    backoffFactor: 1.1\n                }\n            }\n        };\n\n        if (this._options.isDrmProtectedContent) {\n            checkBrowserSupportForWidevineDRM.call(that);\n            unwrapLicenseResponse.call(that, that._player);\n            addDrmSpecificsToPlayerConfig.call(that, playerConfig, that._options, function(err, updatedPlayerConfig) {\n                if (!err) {\n                    loadPlayer(updatedPlayerConfig);\n                } else {\n                    that._logger.error('Failed to add DRM configuration to shaka player', err);\n\n                    throw err;\n                }\n            });\n        } else {\n            loadPlayer(playerConfig);\n        }\n\n        function loadPlayer(config) {\n            that._player.configure(config);\n\n            if (that._options.receiveAudio === false) {\n                elementToAttachTo.muted = true;\n            }\n\n            _.addEventListener(that._player, 'error', function(e) {\n                that._namedEvents.fire(streamEnums.rendererEvents.error.name, ['player', e]);\n            });\n\n            _.addEventListener(elementToAttachTo, 'stalled', that._onStalled, false);\n            _.addEventListener(elementToAttachTo, 'pause', that._onStalled, false);\n            _.addEventListener(elementToAttachTo, 'suspend', that._onStalled, false);\n            _.addEventListener(elementToAttachTo, 'progress', that._onProgress, false);\n            _.addEventListener(elementToAttachTo, 'ended', that._onEnded, false);\n\n            that._player.load(that._manifestUri).then(function() {\n                that._logger.info('[%s] DASH live stream has been loaded', that._streamId);\n\n                if (_.isFunction(elementToAttachTo.play)) {\n                    elementToAttachTo.play();\n                }\n            }).catch(function(e) {\n                that._logger.error('[%s] Error while loading DASH live stream [%s]', that._streamId, e.code, e);\n\n                that._namedEvents.fire(streamEnums.rendererEvents.error.name, ['shaka', e]);\n            });\n\n            if (!that._options.capabilities.includes('audio-only')) {\n                that._dimensionsChangedMonitor.start(this, elementToAttachTo);\n            }\n\n            that._element = elementToAttachTo;\n        }\n\n        return elementToAttachTo;\n    };\n\n    ShakaRenderer.prototype.stop = function(reason, waitForLastChunk) {\n        var that = this;\n\n        if (that._waitingForFinalization) {\n            return;\n        }\n\n        if (waitForLastChunk) {\n            return that._waitForLastChunk = true;\n        }\n\n        this._dimensionsChangedMonitor.stop();\n\n        this._disposables.dispose();\n\n        if (this._player) {\n            var finalizeStreamEnded = function finalizeStreamEnded() {\n                var reason = '';\n\n                if (that._element) {\n                    _.removeEventListener(that._element, 'stalled', that._onStalled, false);\n                    _.removeEventListener(that._element, 'pause', that._onStalled, false);\n                    _.removeEventListener(that._element, 'suspend', that._onStalled, false);\n                    _.removeEventListener(that._element, 'progress', that._onProgress, false);\n                    _.removeEventListener(that._element, 'ended', that._onEnded, false);\n\n                    if (rtc.browser === 'Edge') {\n                        that._element.src = '';\n                    }\n                }\n\n                that._namedEvents.fire(streamEnums.rendererEvents.ended.name, [reason]);\n\n                that._player = null;\n                that._element = null;\n            };\n\n            var destroyIgnored = that._player.destroy()\n                .then(function() {\n                    that._logger.info('[%s] Shaka live stream player has been destroyed', that._streamId);\n                }).then(function() {\n                    finalizeStreamEnded();\n                }).catch(function(e) {\n                    that._logger.error('[%s] Error while destroying shaka live stream player [%s]', that._streamId, e.code, e);\n\n                    finalizeStreamEnded();\n\n                    that._namedEvents.fire(streamEnums.rendererEvents.error.name, ['shaka', e]);\n                });\n\n            that._waitingForFinalization = true;\n        }\n    };\n\n    ShakaRenderer.prototype.getStats = function() {\n        if (!this._player) {\n            return {\n                width: 0,\n                height: 0,\n                currentTime: 0,\n                lag: 0,\n                networkState: streamEnums.networkStates.networkNoSource.id\n            };\n        }\n\n        var stat = _.assign(this._player.getStats(), {\n            currentTime: 0,\n            lag: 0\n        });\n        var currentTime = _.get(this._element, ['currentTime'], 0);\n        var trueCurrentTime = (_.now() - this._options.originStartTime) / 1000;\n        var lag = Math.max(0.0, trueCurrentTime - currentTime);\n\n        if (this._element) {\n            stat.currentTime = currentTime;\n            stat.lag = lag;\n        }\n\n        if (stat.estimatedBandwidth > 0) {\n            stat.networkState = streamEnums.networkStates.networkLoading.id;\n        } else if (stat.playTime > 0) {\n            stat.networkState = streamEnums.networkStates.networkIdle.id;\n        } else if (stat.video) {\n            stat.networkState = streamEnums.networkStates.networkEmpty.id;\n        } else {\n            stat.networkState = streamEnums.networkStates.networkNoSource.id;\n        }\n\n        return stat;\n    };\n\n    ShakaRenderer.prototype.setDataQualityChangedCallback = function(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.dataQualityChangedCallback = callback;\n    };\n\n    ShakaRenderer.prototype.getPlayer = function() {\n        return this._player;\n    };\n\n    ShakaRenderer.prototype.addVideoDisplayDimensionsChangedCallback = function(callback, options) {\n        return this._dimensionsChangedMonitor.addVideoDisplayDimensionsChangedCallback(callback, options);\n    };\n\n    function onProgress() {\n        this._lastProgress.time = _.now();\n\n        if (this._element.buffered.length === 0) {\n            return this._logger.debug('[%s] Shaka live stream player progress event fired without any buffered content', this._streamId);\n        }\n\n        var bufferedEnd = this._element.buffered.end(this._element.buffered.length - 1);\n\n        if (this._lastProgress.buffered === bufferedEnd) {\n            return;\n        }\n\n        // Start and end times are unreliable for overall length of stream.\n        if (this._lastProgress.buffered !== null) {\n            var oldTimeElapsed = this._lastProgress.averageLength * this._lastProgress.count;\n            var newTimeElapsed = oldTimeElapsed + (bufferedEnd - this._lastProgress.buffered);\n\n            this._lastProgress.count += 1;\n            this._lastProgress.averageLength = newTimeElapsed / this._lastProgress.count;\n        }\n\n        this._lastProgress.buffered = bufferedEnd;\n    }\n\n    function stalled() {\n        var that = this;\n\n        that._logger.info('[%s] Loading Shaka live stream player stream stalled.', that._streamId);\n\n        if (that._lastProgress.time === 0) {\n            return;\n        }\n\n        setTimeout(function() {\n            if (_.now() - that._lastProgress.time > getTimeoutOrMinimum.call(that) && that._waitForLastChunk) {\n                that.stop('ended');\n            }\n        }, getTimeoutOrMinimum.call(that));\n    }\n\n    function getTimeoutOrMinimum() {\n        return this._lastProgress.averageLength * 1.5 < 2000 ? 2000 : this._lastProgress.averageLength * 1.5;\n    }\n\n    function ended() {\n        this._logger.info('[%s] Shaka live stream player ended.', this._streamId);\n    }\n\n    function checkBrowserSupportForWidevineDRM() {\n        var error;\n\n        if (!_.isFunction(Uint8Array)) {\n            error = 'Uint8Array support required for DRM';\n            this._logger.error(error);\n\n            throw new Error(error);\n        }\n\n        if (!_.isFunction(rtc.global.atob)) {\n            error = 'rtc.global.atob support required for DRM';\n            this._logger.error(error);\n\n            throw new Error(error);\n        }\n    }\n\n    function unwrapLicenseResponse(player) {\n        var that = this;\n\n        player.getNetworkingEngine().registerResponseFilter(function(type, response) {\n            // Only manipulate license responses:\n            if (type.toString() === that._shaka.net.NetworkingEngine.RequestType.LICENSE.toString()) {\n                var binaryResponseAsTypedArray = new Uint8Array(response.data);\n                var responseAsString = String.fromCharCode.apply(null, binaryResponseAsTypedArray);\n                var parsedResponse = JSON.parse(responseAsString);\n                var base64License = parsedResponse.license;\n                var decodedLicense = rtc.global.atob(base64License);\n\n                response.data = new Uint8Array(decodedLicense.length);\n\n                for (var i = 0; i < decodedLicense.length; ++i) {\n                    response.data[i] = decodedLicense.charCodeAt(i);\n                }\n\n                if (parsedResponse.trackRestrictions) {\n                    player.configure({restrictions: parsedResponse.trackRestrictions});\n                }\n            }\n        });\n    }\n\n    function addDrmSpecificsToPlayerConfig(playerConfig, options, callback) {\n        if (!playerConfig.drm) {\n            playerConfig.drm = {};\n        }\n\n        if (!playerConfig.drm.advanced) {\n            playerConfig.drm.advanced = {};\n        }\n\n        if (!playerConfig.manifest) {\n            playerConfig.manifest = {};\n        }\n\n        if (!playerConfig.manifest.dash) {\n            playerConfig.manifest.dash = {};\n        }\n\n        // Add browser specific DRM calls here\n        // Currently we support Widevine only\n        addWidevineConfigToPlayerConfig.call(this, playerConfig, options, callback);\n    }\n\n    // ToDo pull into singleton so widevineServiceCertificate stays per browser session\n    function addWidevineConfigToPlayerConfig(playerConfig, options, callback) {\n        playerConfig['manifest']['dash']['customScheme'] = function(element) {\n            if (element.getAttribute('schemeIdUri') === 'com.phenixrts.widevine' || element.getAttribute('schemeIdUri') === 'com.phenixp2p.widevine') {\n                return [{\n                    keySystem: 'com.widevine.alpha',\n                    licenseServerUri: decodeURIComponent(element.getAttribute('widevineLicenseServerUrl'))\n                }];\n            }\n        };\n\n        function addToPlayerconfig(error, serverCertificateResponse) {\n            if (error) {\n                callback(error);\n\n                return;\n            }\n\n            widevineServiceCertificate = serverCertificateResponse.data; // Cache so that we can reuse\n\n            playerConfig.drm.advanced['com.widevine.alpha'] = {\n                'serverCertificate': convertBinaryStringToUint8Array(serverCertificateResponse.data),\n                'persistentStateRequired': true,\n                'distinctiveIdentifierRequired': false\n            };\n\n            callback(null, playerConfig);\n        }\n\n        if (widevineServiceCertificate) {\n            addToPlayerconfig(null, widevineServiceCertificate);\n        } else {\n            http.get(options.widevineServiceCertificateUrl, {mimeType: 'text/plain; charset=x-user-defined'}, addToPlayerconfig);\n        }\n    }\n\n    function convertBinaryStringToUint8Array(bStr) {\n        var len = bStr.length;\n        var u8Array = new Uint8Array(len); // eslint-disable-line no-undef\n\n        for (var i = 0; i < len; i++) {\n            u8Array[i] = bStr.charCodeAt(i);\n        }\n\n        return u8Array;\n    }\n\n    return ShakaRenderer;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-logging',\n    'phenix-web-event',\n    'phenix-web-http',\n    'phenix-web-disposable',\n    'phenix-rtc',\n    '../DimensionsChangedMonitor',\n    './stream.json'\n], function(_, assert, logging, event, http, disposable, rtc, DimensionsChangedMonitor, streamEnums) {\n    'use strict';\n\n    var bandwidthAt720 = 3000000;\n    var timeoutForStallWithoutProgressToRestart = 6000;\n    var minTimeBeforeNextReload = 15000;\n    var originStreamReadyDuration = 6000;\n\n    function PhenixPlayerRenderer(streamId, uri, streamTelemetry, options, webPlayer, logger) {\n        this._logger = logger;\n        this._streamId = streamId;\n        this._manifestUri = encodeURI(uri).replace(/[#]/g, '%23');\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._webPlayer = webPlayer;\n        this._renderer = null;\n        this._element = null;\n        this._dimensionsChangedMonitor = new DimensionsChangedMonitor(logger);\n        this._lastProgress = {\n            time: 0,\n            buffered: null,\n            averageLength: 0,\n            count: 0,\n            lastCurrentTime: 0,\n            lastCurrentTimeOccurenceTimestamp: 0\n        };\n        this._namedEvents = new event.NamedEvents();\n        this._disposables = new disposable.DisposableList();\n\n        this._onStalled = _.bind(stalled, this);\n        this._onProgress = _.bind(onProgress, this);\n        this._onEnded = _.bind(ended, this);\n    }\n\n    PhenixPlayerRenderer.isSupported = function() {\n        return this._webPlayer && this._webPlayer.isSupported;\n    };\n\n    PhenixPlayerRenderer.prototype.on = function(name, callback) {\n        return this._namedEvents.listen(name, callback);\n    };\n\n    PhenixPlayerRenderer.prototype.start = function(elementToAttachTo) {\n        var that = this;\n        var loggerAtInfoThreshold = createInfoThresholdLogger(this._logger);\n\n        this._throttledLogger = loggerAtInfoThreshold;\n        this._element = elementToAttachTo;\n\n        this._disposables.add(this._streamTelemetry.recordTimeToFirstFrame(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordRebuffering(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordVideoResolutionChanges(this, elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordVideoPlayingAndPausing(elementToAttachTo));\n\n        setupPlayer.call(that);\n\n        if (that._options.receiveAudio === false) {\n            elementToAttachTo.muted = true;\n        }\n\n        _.addEventListener(elementToAttachTo, 'stalled', that._onStalled, false);\n        _.addEventListener(elementToAttachTo, 'pause', that._onStalled, false);\n        _.addEventListener(elementToAttachTo, 'suspend', that._onStalled, false);\n        _.addEventListener(elementToAttachTo, 'progress', that._onProgress, false);\n        _.addEventListener(elementToAttachTo, 'ended', that._onEnded, false);\n\n        if (!this._options.capabilities.includes('audio-only')) {\n            this._dimensionsChangedMonitor.start(this, elementToAttachTo);\n        }\n\n        return elementToAttachTo;\n    };\n\n    PhenixPlayerRenderer.prototype.stop = function(reason, waitForLastChunk) {\n        var that = this;\n\n        if (that._waitingForFinalization) {\n            return;\n        }\n\n        if (waitForLastChunk) {\n            return that._waitForLastChunk = true;\n        }\n\n        this._dimensionsChangedMonitor.stop();\n\n        this._disposables.dispose();\n\n        if (this._player) {\n            var finalizeStreamEnded = function finalizeStreamEnded() {\n                var reason = '';\n\n                if (that._element) {\n                    _.removeEventListener(that._element, 'stalled', that._onStalled, false);\n                    _.removeEventListener(that._element, 'pause', that._onStalled, false);\n                    _.removeEventListener(that._element, 'suspend', that._onStalled, false);\n                    _.removeEventListener(that._element, 'progress', that._onProgress, false);\n                    _.removeEventListener(that._element, 'ended', that._onEnded, false);\n\n                    if (rtc.browser === 'Edge') {\n                        that._element.src = '';\n                    }\n                }\n\n                that._namedEvents.fire(streamEnums.rendererEvents.ended.name, [reason]);\n\n                that._player = null;\n                that._element = null;\n            };\n\n            that._waitingForFinalization = true;\n\n            try {\n                that._player.dispose();\n\n                that._logger.info('[%s] Phenix stream has been destroyed', that._streamId);\n\n                finalizeStreamEnded();\n            } catch (e) {\n                that._logger.error('[%s] Error while destroying Phenix stream player [%s]', that._streamId, e.code, e);\n\n                finalizeStreamEnded();\n\n                that._namedEvents.fire(streamEnums.rendererEvents.error.name, ['phenix-player', e]);\n            }\n        }\n    };\n\n    PhenixPlayerRenderer.prototype.getStats = function() {\n        if (!this._player) {\n            return {\n                width: 0,\n                height: 0,\n                currentTime: 0.0,\n                lag: 0.0,\n                networkState: streamEnums.networkStates.networkNoSource.id\n            };\n        }\n\n        var stat = this._player.getStats();\n        var currentTime = stat.currentTime || this._element.currentTime;\n        var trueCurrentTime = (_.now() - this._options.originStartTime) / 1000;\n\n        if (stat.isNative && stat.deliveryType === 'Hls') {\n            stat.currentTime = trueCurrentTime - stat.lag;\n        }\n\n        if (!stat.isNative) {\n            stat.lag = Math.max(0.0, trueCurrentTime - currentTime);\n        }\n\n        if (stat.estimatedBandwidth > 0) {\n            stat.networkState = streamEnums.networkStates.networkLoading.id;\n        } else if (stat.playTime > 0) {\n            stat.networkState = streamEnums.networkStates.networkIdle.id;\n        } else if (stat.video) {\n            stat.networkState = streamEnums.networkStates.networkEmpty.id;\n        } else {\n            stat.networkState = streamEnums.networkStates.networkNoSource.id;\n        }\n\n        return stat;\n    };\n\n    PhenixPlayerRenderer.prototype.setDataQualityChangedCallback = function(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.dataQualityChangedCallback = callback;\n    };\n\n    PhenixPlayerRenderer.prototype.getPlayer = function() {\n        return this._player;\n    };\n\n    PhenixPlayerRenderer.prototype.addVideoDisplayDimensionsChangedCallback = function(callback, options) {\n        return this._dimensionsChangedMonitor.addVideoDisplayDimensionsChangedCallback(callback, options);\n    };\n\n    function setupPlayer() {\n        var that = this;\n        var playerOptions = _.assign({bandwidthToStartAt: bandwidthAt720}, that._options);\n\n        if (_.includes(this._manifestUri, '.mpd')) {\n            if (that._options.isDrmProtectedContent) {\n                playerOptions.drm = {\n                    'com.widevine.alpha': {\n                        serverCertificateUrl: that._options.widevineServiceCertificateUrl,\n                        mediaKeySystemConfiguration: {persistentState: 'required'}\n                    },\n                    'com.microsoft.playready': {licenseServerUrl: that._options.playreadyLicenseUrl}\n                };\n            }\n        }\n\n        var webPlayer = new this._webPlayer.WebPlayer(this._throttledLogger, this._element, playerOptions);\n        var timeSinceOriginStreamStart = _.now() - this._options.originStartTime;\n\n        if (timeSinceOriginStreamStart < originStreamReadyDuration && this._options.isDrmProtectedContent && _.includes(this._manifestUri, '.m3u8')) {\n            setTimeout(_.bind(webPlayer.start, webPlayer, that._manifestUri), originStreamReadyDuration);\n        } else {\n            webPlayer.start(that._manifestUri);\n        }\n\n        that._player = webPlayer;\n\n        _.addEventListener(that._player, 'error', _.bind(handleError, that));\n    }\n\n    function handleError(e) {\n        if (canReload.call(this) && e && (e.code === 3 || e.severity === this._webPlayer.errors.severity.RECOVERABLE)) {\n            this._logger.warn('Reloading unhealthy stream after error event [%s]', e);\n\n            return reloadIfAble.call(this);\n        }\n\n        this._namedEvents.fire(streamEnums.rendererEvents.error.name, ['phenix-player', e]);\n    }\n\n    function reload() {\n        this._player.dispose();\n\n        this._player = null;\n\n        this.start(this._element);\n    }\n\n    function reloadIfAble() {\n        if (!canReload.call(this)) {\n            return;\n        }\n\n        this._logger.warn('Reloading unhealthy stream that was active for at least [%s] seconds', minTimeBeforeNextReload / 1000);\n\n        this._lastReloadTime = _.now();\n\n        reload.call(this);\n    }\n\n    function canReload() {\n        var hasElapsedMinTimeSinceLastReload = !this._lastReloadTime || _.now() - this._lastReloadTime > minTimeBeforeNextReload;\n\n        return this._element && !this._waitForLastChunk && this._player && this._element.buffered.length !== 0 && hasElapsedMinTimeSinceLastReload;\n    }\n\n    function onProgress() {\n        this._lastProgress.time = _.now();\n\n        if (this._element.buffered.length === 0) {\n            return this._logger.debug('[%s] Phenix stream player progress event fired without any buffered content', this._streamId);\n        }\n\n        var bufferedEnd = this._element.buffered.end(this._element.buffered.length - 1);\n\n        if (this._lastProgress.buffered === bufferedEnd) {\n            return;\n        }\n\n        // Start and end times are unreliable for overall length of stream.\n        if (this._lastProgress.buffered !== null) {\n            var oldTimeElapsed = this._lastProgress.averageLength * this._lastProgress.count;\n            var newTimeElapsed = oldTimeElapsed + (bufferedEnd - this._lastProgress.buffered);\n            var isStalled = this._lastProgress.lastCurrentTime === this._element.currentTime;\n\n            this._lastProgress.count += 1;\n            this._lastProgress.averageLength = newTimeElapsed / this._lastProgress.count;\n\n            if (!isStalled) {\n                this._lastProgress.lastCurrentTimeOccurenceTimestamp = _.now();\n            }\n\n            var hasExceededStallTimeout = this._lastProgress.lastCurrentTimeOccurenceTimestamp && _.now() - this._lastProgress.lastCurrentTimeOccurenceTimestamp > timeoutForStallWithoutProgressToRestart;\n\n            if (isStalled && hasExceededStallTimeout && this._element && !this._element.paused && canReload.call(this)) {\n                this._logger.warn('Reloading stream after current time has not changed for [%s] seconds due to unregistered stall.', timeoutForStallWithoutProgressToRestart / 1000);\n\n                reloadIfAble.call(this);\n            }\n        }\n\n        this._lastProgress.buffered = bufferedEnd;\n        this._lastProgress.lastCurrentTime = this._element.currentTime;\n    }\n\n    function stalled(event) {\n        var that = this;\n\n        that._logger.info('[%s] Loading Phenix Live stream player stalled caused by [%s] event.', that._streamId, event.type);\n\n        if (that._lastProgress.time === 0 || that._element.paused) {\n            return;\n        }\n\n        var currentVideoTime = that._element.currentTime;\n\n        setTimeout(function() {\n            if (_.now() - that._lastProgress.time > getTimeoutOrMinimum.call(that) && that._waitForLastChunk) {\n                that.stop('ended');\n            }\n        }, getTimeoutOrMinimum.call(that));\n\n        setTimeout(function() {\n            if (that._element && that._element.currentTime === currentVideoTime && !that._element.paused && canReload.call(that)) {\n                that._logger.warn('Reloading stream after being stalled for [%s] seconds', timeoutForStallWithoutProgressToRestart / 1000);\n\n                reloadIfAble.call(that);\n            }\n        }, timeoutForStallWithoutProgressToRestart);\n    }\n\n    function getTimeoutOrMinimum() {\n        return this._lastProgress.averageLength * 1.5 < 2000 ? 2000 : this._lastProgress.averageLength * 1.5;\n    }\n\n    function ended() {\n        this._logger.info('[%s] Phenix stream player ended.', this._streamId);\n    }\n\n    function createInfoThresholdLogger(logger) {\n        var appenders = logger.getAppenders();\n        var throttledLogger = new logging.Logger();\n\n        _.forEach(appenders, function(appender) {\n            if (appender instanceof logging.ConsoleAppender) {\n                appender = new logging.ConsoleAppender();\n\n                appender.setThreshold(logging.level.INFO);\n            }\n\n            throttledLogger.addAppender(appender);\n        });\n\n        throttledLogger.setUserId(logger.getUserId());\n        throttledLogger.setEnvironment(logger.getEnvironment());\n        throttledLogger.setApplicationVersion(logger.getApplicationVersion());\n        throttledLogger.setObservableSessionId(logger.getObservableSessionId());\n\n        return throttledLogger;\n    }\n\n    return PhenixPlayerRenderer;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-logging',\n    'phenix-web-event',\n    'phenix-web-http',\n    'phenix-web-disposable',\n    'phenix-rtc',\n    '../DimensionsChangedMonitor',\n    './stream.json'\n], function(_, assert, logging, event, http, disposable, rtc, DimensionsChangedMonitor, streamEnums) {\n    'use strict';\n\n    var timeoutForStallWithoutProgressToRestart = 6000;\n    var minTimeBeforeNextReload = 15000;\n    var mostRecentSwfFile = 'rtmp-flash-renderer-2019.2.18.swf';\n    var defaultSwfFileSrcs = {\n        local: 'https://local.phenixrts.com/public/rtmp/' + mostRecentSwfFile,\n        staging: 'https://stg.phenixrts.com/public/rtmp/' + mostRecentSwfFile,\n        production: 'https://phenixrts.com/public/rtmp/' + mostRecentSwfFile\n    };\n\n    function FlashRenderer(streamId, streamsInfo, streamTelemetry, options, logger) {\n        assert.isObject(options, 'options');\n\n        if (options.env) {\n            assert.isStringNotEmpty(options.env, 'options.env');\n        }\n\n        var defaultSwfFileSrc = defaultSwfFileSrcs[options.env || 'production'];\n\n        this._logger = logger;\n        this._streamId = streamId;\n        this._streamsInfo = _.map(streamsInfo, function(info) {\n            info.uri = encodeURI(info.uri).replace(/[#]/g, '%23');\n\n            return info;\n        });\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._renderer = null;\n        this._phenixVideo = null;\n        this._playerElement = null;\n        this._namedEvents = new event.NamedEvents();\n        this._dimensionsChangedMonitor = new DimensionsChangedMonitor(logger);\n        this._disposables = new disposable.DisposableList();\n\n        this._onStalled = _.bind(stalled, this);\n        this._onEnded = _.bind(ended, this);\n        this._onError = _.bind(handleError, this);\n        this._swfSrc = options.swfSrc || defaultSwfFileSrc;\n    }\n\n    FlashRenderer.isSupported = function() {\n        return detectFlashPlugin();\n    };\n\n    FlashRenderer.prototype.on = function(name, callback) {\n        return this._namedEvents.listen(name, callback);\n    };\n\n    FlashRenderer.prototype.start = function(elementToAttachTo) {\n        var that = this;\n        var options = {\n            streamId: this._streamId,\n            swfSrc: this._swfSrc\n        };\n\n        this._originElement = elementToAttachTo;\n        this._phenixVideo = new rtc.PhenixFlashVideo(elementToAttachTo, this._streamsInfo, options);\n\n        this._phenixVideo.hookUpEvents();\n\n        this._playerElement = this._phenixVideo.getElement();\n\n        this._disposables.add(this._streamTelemetry.recordTimeToFirstFrame(this._originElement));\n        this._disposables.add(this._streamTelemetry.recordRebuffering(this._originElement));\n        this._disposables.add(this._streamTelemetry.recordVideoResolutionChanges(this, this._originElement));\n        this._disposables.add(this._streamTelemetry.recordVideoPlayingAndPausing(this._originElement));\n\n        if (this._playerElement) {\n            this._playerElement.play();\n        }\n\n        _.addEventListener(this._originElement, 'stalled', that._onStalled, false);\n        _.addEventListener(this._originElement, 'pause', that._onStalled, false);\n        _.addEventListener(this._originElement, 'suspend', that._onStalled, false);\n        _.addEventListener(this._originElement, 'ended', that._onEnded, false);\n        _.addEventListener(this._originElement, 'error', that._onError, false);\n\n        return elementToAttachTo;\n    };\n\n    FlashRenderer.prototype.stop = function(reason) {\n        var that = this;\n\n        this._disposables.dispose();\n\n        if (this._phenixVideo) {\n            var finalizeStreamEnded = function finalizeStreamEnded() {\n                if (that._playerElement) {\n                    _.removeEventListener(that._originElement, 'stalled', that._onStalled, false);\n                    _.removeEventListener(that._originElement, 'pause', that._onStalled, false);\n                    _.removeEventListener(that._originElement, 'suspend', that._onStalled, false);\n                    _.removeEventListener(that._originElement, 'ended', that._onEnded, false);\n                    _.removeEventListener(that._originElement, 'error', that._onError, false);\n                }\n\n                that._playerElement = null;\n                that._originElement = null;\n\n                that._namedEvents.fire(streamEnums.rendererEvents.ended.name, [reason]);\n            };\n\n            try {\n                this._phenixVideo.destroy();\n                this._phenixVideo = null;\n\n                finalizeStreamEnded();\n\n                this._logger.info('[%s] Flash player has been destroyed', this._streamId);\n            } catch (e) {\n                that._logger.error('[%s] Error while destroying Flash player [%s]', that._streamId, e.code, e);\n\n                finalizeStreamEnded();\n\n                that._namedEvents.fire(streamEnums.rendererEvents.error.name, ['flash-player', e]);\n            }\n        }\n    };\n\n    FlashRenderer.prototype.getStats = function() {\n        if (!this._playerElement) {\n            return {\n                width: 0,\n                height: 0,\n                currentTime: 0.0,\n                lag: 0.0,\n                networkState: streamEnums.networkStates.networkNoSource.id\n            };\n        }\n\n        var stat = {};\n        var currentTime = this._playerElement.currentTime;\n        var trueCurrentTime = (_.now() - this._options.originStartTime) / 1000;\n\n        stat.lag = Math.max(0.0, trueCurrentTime - currentTime);\n\n        if (stat.estimatedBandwidth > 0) {\n            stat.networkState = streamEnums.networkStates.networkLoading.id;\n        } else if (stat.playTime > 0) {\n            stat.networkState = streamEnums.networkStates.networkIdle.id;\n        } else if (stat.video) {\n            stat.networkState = streamEnums.networkStates.networkEmpty.id;\n        } else {\n            stat.networkState = streamEnums.networkStates.networkNoSource.id;\n        }\n\n        return stat;\n    };\n\n    FlashRenderer.prototype.setDataQualityChangedCallback = function(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.dataQualityChangedCallback = callback;\n    };\n\n    FlashRenderer.prototype.getPlayer = function() {\n        return this._player;\n    };\n\n    FlashRenderer.prototype.addVideoDisplayDimensionsChangedCallback = function(callback, options) {\n        return this._dimensionsChangedMonitor.addVideoDisplayDimensionsChangedCallback(callback, options);\n    };\n\n    function handleError(e) {\n        this._namedEvents.fire(streamEnums.rendererEvents.error.name, ['flash-player', e]);\n    }\n\n    function reload() {\n        this._phenixVideo.destroy();\n\n        this.start(this._originElement);\n    }\n\n    function reloadIfAble() {\n        if (!canReload.call(this)) {\n            return;\n        }\n\n        this._logger.warn('Reloading unhealthy stream that was active for at least [%s] seconds', minTimeBeforeNextReload / 1000);\n\n        this._lastReloadTime = _.now();\n\n        reload.call(this);\n    }\n\n    function canReload() {\n        var hasElapsedMinTimeSinceLastReload = !this._lastReloadTime || _.now() - this._lastReloadTime > minTimeBeforeNextReload;\n\n        return this._playerElement && !this._waitForLastChunk && this._player && this._playerElement.buffered.length !== 0 && hasElapsedMinTimeSinceLastReload;\n    }\n\n    function stalled(event) {\n        var that = this;\n\n        that._logger.info('[%s] Loading flash player stalled caused by [%s] event.', that._streamId, event.type);\n\n        var currentVideoTime = that._playerElement.currentTime;\n\n        setTimeout(function() {\n            if (that._playerElement && that._playerElement.currentTime === currentVideoTime && !that._playerElement.paused && canReload.call(that)) {\n                that._logger.warn('Reloading stream after being stalled for [%s] seconds', timeoutForStallWithoutProgressToRestart / 1000);\n\n                reloadIfAble.call(that);\n            }\n        }, timeoutForStallWithoutProgressToRestart);\n    }\n\n    function ended() {\n        this._logger.info('[%s] Flash player ended.', this._streamId);\n    }\n\n    var hasFlashPlugin = null;\n\n    function detectFlashPlugin() {\n        var defaultVersion = [10, 0, 0];\n        var pluginName = 'Shockwave Flash';\n        var mimeType = 'application/x-shockwave-flash';\n        var activeX = 'ShockwaveFlash.ShockwaveFlash';\n        var version = [0, 0, 0];\n\n        if (_.isBoolean(hasFlashPlugin)) {\n            return hasFlashPlugin;\n        }\n\n        // Firefox, Webkit, Opera\n        if (_.get(rtc.global.navigator, ['plugins', pluginName])) {\n            var description = rtc.global.navigator.plugins[pluginName].description;\n\n            if (description && _.get(rtc.global.navigator, ['mimeTypes', mimeType, 'enabledPlugin'], false)) {\n                version = description.replace(pluginName, '').replace(/^\\s+/, '').replace(/\\sr/gi, '.').split('.');\n\n                for (var i = 0, total = version.length; i < total; i++) {\n                    version[i] = parseInt(version[i].match(/\\d+/), 10);\n                }\n            }\n            // Internet Explorer / ActiveX\n        } else if (rtc.global.ActiveXObject) {\n            try {\n                var ax = new rtc.global.ActiveXObject(activeX);\n\n                if (ax) {\n                    var versionString = ax.GetVariable(\"$version\") || '';\n                    var versionInfo = _.get(versionString.split(\" \"), [1], version).split(\",\");\n\n                    version = [parseInt(versionInfo[0], 10), parseInt(versionInfo[1], 10), parseInt(versionInfo[2], 10)];\n                }\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        hasFlashPlugin = (version[0] > defaultVersion[0] || (version[0] === defaultVersion[0] && version[1] > 0) || (version[0] === defaultVersion[0] && version[1] === 0 && version[2] >= 0));\n\n        return hasFlashPlugin;\n    }\n\n    return FlashRenderer;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-rtc',\n    'phenix-web-disposable',\n    'phenix-web-application-activity-detector',\n    './PeerConnection',\n    './PeerConnectionMonitor',\n    './BitRateMonitor',\n    './PhenixRealTimeRenderer',\n    './FeatureDetector',\n    './stream.json'\n], function(_, assert, event, rtc, disposable, applicationActivityDetector, PeerConnection, PeerConnectionMonitor, BitRateMonitor, PhenixRealTimeRenderer, FeatureDetector, streamEnums) {\n    'use strict';\n\n    var defaultIceConnectionTimeout = 12000;\n\n    function PhenixRealTimeStream(streamId, streamSrc, peerConnection, streamTelemetry, options, logger) {\n        this._streamId = streamId;\n        this._streamSrc = streamSrc;\n        this._peerConnection = peerConnection;\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._logger = logger;\n        this._renderers = [];\n        this._dimensionsChangedMonitor = null;\n        this._namedEvents = new event.NamedEvents();\n        this._childrenStreams = [];\n        this._limit = 0;\n        this._backgroundMonitorEventCallback = null;\n        this._disposables = new disposable.DisposableList();\n        this._connected = 0;\n        this._iceConnectionTimeout = _.get(options, ['iceConnectionTimeout'], defaultIceConnectionTimeout);\n\n        this._disposables.add(applicationActivityDetector.onForeground(_.bind(emitPendingBackgroundEvent, this)));\n\n        var bandwidthAttribute = /(b=AS:([0-9]*)[\\n\\r]*)/gi;\n        var bandwithAttribute = bandwidthAttribute.exec(peerConnection.remoteDescription);\n\n        if (bandwithAttribute && bandwithAttribute.length >= 3) {\n            this._limit = bandwithAttribute[2] * 1000;\n        }\n\n        _.addEventListener(peerConnection, 'iceconnectionstatechange', _.bind(onIceConnectionChange, this));\n    }\n\n    PhenixRealTimeStream.prototype.on = function(name, callback) {\n        this._namedEvents.listen(name, callback);\n    };\n\n    PhenixRealTimeStream.prototype.createRenderer = function() {\n        var that = this;\n        var sdp = _.get(this._peerConnection, ['remoteDescription', 'sdp']);\n        var options = Object.assign({}, this._options);\n\n        if (sdp && !this._options.capabilities.includes('audio-only') || !this._options.capabilities.includes('video-only')) {\n            if (!sdp.includes('m=audio')) {\n                options.capabilities.push('video-only');\n            }\n\n            if (!sdp.includes('m=video')) {\n                options.capabilities.push('audio-only');\n            }\n\n            var sdpTracks = sdp.split('m=');\n\n            sdpTracks.forEach(function(track) {\n                if (track.startsWith('audio') && track.includes('a=inactive')) {\n                    options.capabilities.push('video-only');\n                }\n\n                if (track.startsWith('video') && track.includes('a=inactive')) {\n                    options.capabilities.push('audio-only');\n                }\n            });\n        }\n\n        var renderer = new PhenixRealTimeRenderer(this._streamId, this._streamSrc, this._streamTelemetry, options, this._logger);\n\n        renderer.on(streamEnums.rendererEvents.error.name, function(type, error) {\n            that._namedEvents.fire(streamEnums.streamEvents.playerError.name, [type, error]);\n        });\n        renderer.on(streamEnums.rendererEvents.ended.name, function(reason) {\n            that._renderers = _.filter(that._renderers, function(storedRenderer) {\n                return storedRenderer !== renderer;\n            });\n\n            if (that._renderers.length === 0) {\n                that._streamTelemetry.stop();\n                that._namedEvents.fire(streamEnums.streamEvents.playerEnded.name, [reason]);\n            }\n        });\n\n        this._renderers.push(renderer);\n\n        return renderer;\n    };\n\n    PhenixRealTimeStream.prototype.select = function select(trackSelectCallback) {\n        assert.isFunction(trackSelectCallback, 'trackSelectCallback');\n        assert.isFunction(rtc.global.MediaStream, 'rtc.global.MediaStream');\n\n        var tracks = this._streamSrc.getTracks();\n        var streamToAttach = new rtc.global.MediaStream();\n\n        for (var i = 0; i < tracks.length; i++) {\n            if (trackSelectCallback(tracks[i], i)) {\n                streamToAttach.addTrack(tracks[i]);\n            }\n        }\n\n        if (streamToAttach.getTracks().length === 0) {\n            return this._logger.warn('No tracks selected');\n        }\n\n        var that = this;\n        var newMediaStream = new PhenixRealTimeStream(this._streamId, streamToAttach, this._peerConnection, this._streamTelemetry, this._options, this._logger);\n\n        newMediaStream.on(streamEnums.streamEvents.stopped.name, function(reason) {\n            if (isStreamStopped(that._streamSrc)) {\n                that._namedEvents.fire(streamEnums.streamEvents.stopped.name, [reason]);\n            }\n        });\n\n        this._childrenStreams.push(newMediaStream);\n\n        return newMediaStream;\n    };\n\n    PhenixRealTimeStream.prototype.setStreamEndedCallback = function setStreamEndedCallback(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this._streamEndedCallback = callback;\n    };\n\n    PhenixRealTimeStream.prototype.setStreamErrorCallback = function setStreamErrorCallback(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this._streamErrorCallback = callback;\n    };\n\n    PhenixRealTimeStream.prototype.streamEndedCallback = function streamEndedCallback(stream, status, reason) {\n        _.forEach(this._childrenStreams, function(childStream) {\n            childStream.streamEndedCallback(status, reason);\n        });\n\n        if (_.isFunction(this._streamEndedCallback)) {\n            this._streamEndedCallback(this, status, reason);\n        }\n    };\n\n    PhenixRealTimeStream.prototype.streamErrorCallback = function streamErrorCallback(stream, errorSource, error) {\n        _.forEach(this._childrenStreams, function(childStream) {\n            childStream.streamErrorCallback(errorSource, error);\n        });\n\n        if (_.isFunction(this._streamErrorCallback)) {\n            this._streamErrorCallback(stream, errorSource, error);\n        }\n    };\n\n    PhenixRealTimeStream.prototype.stop = function stop(reason) {\n        if (!this.isActive()) {\n            return;\n        }\n\n        this._disposables.dispose();\n\n        stopWebRTCStream(this._streamSrc);\n\n        this._logger.info('[%s] stop [real-time] media stream with reason [%s]', this._streamId, reason);\n\n        this._namedEvents.fire(streamEnums.streamEvents.stopped.name, [reason]);\n\n        this._isStopped = true;\n    };\n\n    PhenixRealTimeStream.prototype.monitor = function monitor(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        var that = this;\n        var monitor = new PeerConnectionMonitor(that._streamId, that._peerConnection, that._logger);\n\n        options.direction = 'inbound';\n\n        monitor.start(options, function activeCallback() {\n            return that.isActive();\n        }, function monitorCallback(error, monitorEvent) {\n            if (error) {\n                that._logger.warn('[%s] Media stream monitor triggered unrecoverable error [%s]', that._streamId, error);\n            }\n\n            if (FeatureDetector.isIOS() && !applicationActivityDetector.isForeground()) {\n                that._logger.info('[%s] Media stream monitor triggered event while app is in the background. Waiting until foreground to trigger event.', that._streamId);\n\n                return that._backgroundMonitorEventCallback = monitorCallback.bind(null, error, monitorEvent);\n            }\n\n            that._logger.warn('[%s] Media stream triggered monitor condition for [%s] [%s]', that._streamId, monitorEvent.type, monitorEvent.reasons);\n\n            return callback(that, 'client-side-failure', monitorEvent);\n        });\n\n        this._monitor = monitor;\n\n        return monitor;\n    };\n\n    PhenixRealTimeStream.prototype.getMonitor = function getMonitor() {\n        return this._monitor;\n    };\n\n    PhenixRealTimeStream.prototype.addBitRateThreshold = function addBitRateThreshold(threshold, callback) {\n        var that = this;\n        var bitRateMonitor = new BitRateMonitor('Media Stream', this._monitor, function getLimit() {\n            return that._limit;\n        });\n\n        return bitRateMonitor.addThreshold(threshold, callback);\n    };\n\n    PhenixRealTimeStream.prototype.getStream = function getStream() {\n        return this._streamSrc;\n    };\n\n    PhenixRealTimeStream.prototype.isActive = function isActive() {\n        return !this._isStopped;\n    };\n\n    PhenixRealTimeStream.prototype.getStreamId = function getStreamId() {\n        return this._streamId;\n    };\n\n    PhenixRealTimeStream.prototype.getStats = function getStats(callback) {\n        assert.isFunction(callback, 'callback');\n\n        if (!this._lastStats) {\n            this._lastStats = {};\n        }\n\n        var that = this;\n\n        return rtc.getStats(this._peerConnection, null, function(stats) {\n            callback(PeerConnection.convertPeerConnectionStats(stats, that._lastStats));\n        });\n    };\n\n    PhenixRealTimeStream.prototype.getRenderer = function getRenderer() {\n        return _.get(this._renderers, [0], null);\n    };\n\n    PhenixRealTimeStream.prototype.toString = function toString() {\n        return 'PhenixRealTimeStream[' + this._streamId + ']';\n    };\n\n    function emitPendingBackgroundEvent() {\n        if (!this._backgroundMonitorEventCallback) {\n            return;\n        }\n\n        var eventCallback = this._backgroundMonitorEventCallback;\n\n        this._backgroundMonitorEventCallback = null;\n\n        eventCallback();\n    }\n\n    function isStreamStopped(stream) {\n        return _.reduce(stream.getTracks(), function(isStopped, track) {\n            return isStopped && isTrackStopped(track);\n        }, true);\n    }\n\n    function isTrackStopped(track) {\n        assert.isObject(track, 'track');\n\n        return track.readyState === 'ended';\n    }\n\n    function stopWebRTCStream(stream) {\n        if (stream && _.isFunction(stream.stop, 'stream.stop')) {\n            stream.stop();\n        }\n\n        _.forEach(stream && stream.getTracks ? stream.getTracks() : [], function(track) {\n            track.stop();\n        });\n    }\n\n    function onIceConnectionChange() {\n        var that = this;\n        var connectionState = this._peerConnection.iceConnectionState;\n\n        switch (connectionState) {\n        case 'checking':\n        case 'connecting':\n            if (this._checkConnectionSuccessTimeoutId) {\n                return;\n            }\n\n            this._connectionStart = _.now();\n            this._checkConnectionSuccessTimeoutId = setTimeout(function() {\n                that._logger.warn('[%s] Stream has not connected within [%s] ms', that._streamId, that._iceConnectionTimeout);\n                that._namedEvents.fire(streamEnums.streamEvents.playerError.name, ['real-time', new Error('connection-timeout')]);\n            }, that._iceConnectionTimeout);\n\n            break;\n        case 'failed':\n            if (this._checkConnectionSuccessTimeoutId) {\n                clearTimeout(this._checkConnectionSuccessTimeoutId);\n\n                this._checkConnectionSuccessTimeoutId = null;\n            }\n\n            this._logger.info('[%s] Stream has failed', that._streamId);\n            this._namedEvents.fire(streamEnums.streamEvents.playerError.name, ['real-time', new Error('connection-failed')]);\n\n            break;\n        case 'closed':\n        case 'disconnected':\n            if (this._checkConnectionSuccessTimeoutId) {\n                that._logger.warn('[%s] Stream closed before it was connected', that._streamId);\n            }\n\n            break;\n        case 'connected':\n            if (this._checkConnectionSuccessTimeoutId) {\n                clearTimeout(this._checkConnectionSuccessTimeoutId);\n\n                this._checkConnectionSuccessTimeoutId = null;\n            }\n\n            this._connected++;\n            this._logger.info('[%s] Ice Connection completed after [%s] ms for [%s] time', this._streamId, _.now() - this._connectionStart, this._connected);\n            this._connectionStart = null;\n\n            break;\n        default:\n            this._logger.info('[%s] Unsupported Ice Connection state [%s]', this._streamId, connectionState);\n\n            break;\n        }\n    }\n\n    return PhenixRealTimeStream;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-event',\n    'phenix-web-http',\n    'phenix-web-disposable',\n    'phenix-rtc',\n    'phenix-web-application-activity-detector',\n    'phenix-web-detect-browser',\n    'phenix-web-global',\n    '../DimensionsChangedMonitor',\n    './stream.json',\n    './FeatureDetector'\n], function(_, assert, event, http, disposable, rtc, applicationActivityDetector, DetectBrowser, global, DimensionsChangedMonitor, streamEnums, FeatureDetector) {\n    'use strict';\n\n    var listenForPauseChangeAfterForegroundInterval = 1000;\n    // Restarts less than 100ms after foregrounding cause subsequent \"pause\" events on the video\n    var restartRendererDelay = 200;\n\n    function PhenixRealTimeRenderer(streamId, streamSrc, streamTelemetry, options, logger) {\n        this._logger = logger;\n        this._streamId = streamId;\n        this._streamSrc = streamSrc;\n        this._streamTelemetry = streamTelemetry;\n        this._options = options;\n        this._renderer = null;\n        this._element = null;\n        this._dimensionsChangedMonitor = new DimensionsChangedMonitor(logger);\n        this._namedEvents = new event.NamedEvents();\n        this._disposables = new disposable.DisposableList();\n        this._browser = (new DetectBrowser(_.get(global, ['navigator', 'userAgent'], ''))).detect();\n        this._wasPlaying = false;\n        this._lastBackgroundingTimestamp = 0;\n        this._lastStalledTimestamp = 0;\n\n        this._disposables.add(applicationActivityDetector.onBackground(_.bind(checkIfWasPlayingWhenGoingToBackground, this)));\n        this._disposables.add(applicationActivityDetector.onForeground(_.bind(resumeWhenEnteringForgeround, this)));\n\n        this._onStalling = _.bind(stalling, this);\n        this._onEnded = _.bind(ended, this);\n    }\n\n    PhenixRealTimeRenderer.prototype.on = function(name, callback) {\n        // TODO(sbi) Remove after users have upgraded to new API\n        if (name === 'userActionRequired') {\n            throw new Error('\"userActionRequired is no longer supported. See https://phenixrts.com/docs/web/#view-a-channel and https://phenixrts.com/docs/web/#channel-viewer');\n        }\n\n        return this._namedEvents.listen(name, callback);\n    };\n\n    PhenixRealTimeRenderer.prototype.start = function(elementToAttachTo) {\n        var that = this;\n        var hasAudioTrack = !!_.find(this._streamSrc.getTracks(), function(track) {\n            return track.kind === 'audio';\n        });\n\n        if (!this._options.canPlaybackAudio) {\n            if (this._options.disableAudioIfNoOutputFound && this._options.forcedAudioDisabled) {\n                this._logger.warn('[%s] Missing audio playback device. Audio has been disabled on stream. Try setting up an audio device and re-subscribe in order to receive audio.', this._streamId);\n            } else if (!this._options.disableAudioIfNoOutputFound && hasAudioTrack) {\n                this._logger.warn('[%s] Missing audio playback device. May experience audio and/or video failure. Try setting up an audio device OR pass the [disableAudioIfNoOutputFound] option when subscribing to disable audio playback when no devices are attached.', this._streamId);\n            }\n        }\n\n        this._element = rtc.attachMediaStream(elementToAttachTo, this._streamSrc, function(e) {\n            if (!e) {\n                that._logger.debug('[%s] Successfully started playing stream.', that._streamId);\n\n                return;\n            }\n\n            if (elementToAttachTo.muted || !hasAudioTrack) {\n                that._logger.warn('[%s] Failed to play muted stream.', that._streamId, e);\n\n                return that._namedEvents.fire(streamEnums.rendererEvents.failedToPlay.name, ['failed-to-play']);\n            }\n\n            if (that._options.disableAutoMuting) {\n                that._logger.warn('[%s] Failed to play unmuted stream.', that._streamId, e);\n\n                return that._namedEvents.fire(streamEnums.rendererEvents.failedToPlay.name, ['failed-to-play-unmuted']);\n            }\n\n            that._logger.debug('[%s] Failed to start playing stream. Auto muting the playback and trying again.', that._streamId);\n            elementToAttachTo.muted = true;\n\n            that._element = rtc.attachMediaStream(elementToAttachTo, that._streamSrc, function(e) {\n                if (e) {\n                    that._logger.warn('[%s] Failed to play even after auto muting.', that._streamId, e);\n\n                    // Restore muted state\n                    elementToAttachTo.muted = false;\n\n                    return that._namedEvents.fire(streamEnums.rendererEvents.failedToPlay.name, ['failed-to-play']);\n                }\n\n                that._logger.info('[%s] Successfully started playing stream after auto muting. User may manually unmute with user triggered action.', that._streamId);\n\n                that._namedEvents.fire(streamEnums.rendererEvents.autoMuted.name, ['retry-play-muted']);\n            });\n        });\n\n        this._disposables.add(this._streamTelemetry.recordTimeToFirstFrame(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordRebuffering(elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordVideoResolutionChanges(this, elementToAttachTo));\n        this._disposables.add(this._streamTelemetry.recordVideoPlayingAndPausing(elementToAttachTo));\n\n        if (this._options.receiveAudio === false) {\n            elementToAttachTo.muted = true;\n        }\n\n        _.addEventListener(elementToAttachTo, 'stalled', this._onStalling, false);\n        _.addEventListener(elementToAttachTo, 'pause', this._onStalling, false);\n        _.addEventListener(elementToAttachTo, 'suspend', this._onStalling, false);\n        _.addEventListener(elementToAttachTo, 'ended', this._onEnded, false);\n\n        if (!this._options.capabilities.includes('audio-only')) {\n            this._dimensionsChangedMonitor.start(this, elementToAttachTo);\n        }\n\n        return elementToAttachTo;\n    };\n\n    PhenixRealTimeRenderer.prototype.stop = function(reason) {\n        this._dimensionsChangedMonitor.stop();\n\n        this._disposables.dispose();\n\n        if (this._element) {\n            _.removeEventListener(this._element, 'stalled', this._onStalling, false);\n            _.removeEventListener(this._element, 'pause', this._onStalling, false);\n            _.removeEventListener(this._element, 'suspend', this._onStalling, false);\n            _.removeEventListener(this._element, 'ended', this._onEnded, false);\n\n            if (_.isFunction(this._element.pause)) {\n                this._element.pause();\n            }\n\n            if (this._browser.browser === 'Edge') {\n                this._element.src = '';\n            }\n\n            if (this._element.src) {\n                if (this._browser.browser === 'IE') {\n                    this._element.src = null;\n                } else {\n                    this._element.src = '';\n                }\n            }\n\n            if (this._element.srcObject) {\n                this._element.srcObject = null;\n            }\n\n            this._element = null;\n        }\n\n        this._logger.info('[%s] Phenix real-time renderer has been destroyed', this._streamId);\n\n        this._namedEvents.fire(streamEnums.rendererEvents.ended.name, [reason]);\n    };\n\n    PhenixRealTimeRenderer.prototype.getStats = function() {\n        if (!this._element) {\n            return {\n                width: 0,\n                height: 0,\n                currentTime: 0.0,\n                lag: 0.0,\n                networkState: streamEnums.networkStates.networkNoSource.id\n            };\n        }\n\n        var trueCurrentTime = (_.now() - this._options.originStartTime) / 1000;\n        var lag = this._options.networkLag / 1000; // Check RTC stats instead\n\n        return {\n            width: this._element.videoWidth || this._element.width,\n            height: this._element.videoHeight || this._element.height,\n            currentTime: trueCurrentTime,\n            lag: lag,\n            networkState: this._element.networkState\n        };\n    };\n\n    PhenixRealTimeRenderer.prototype.setDataQualityChangedCallback = function(callback) {\n        assert.isFunction(callback, 'callback');\n\n        this.dataQualityChangedCallback = callback;\n    };\n\n    PhenixRealTimeRenderer.prototype.addVideoDisplayDimensionsChangedCallback = function(callback, options) {\n        return this._dimensionsChangedMonitor.addVideoDisplayDimensionsChangedCallback(callback, options);\n    };\n\n    function stalling(event) {\n        var isLastBackgroundingRecent = (_.now() - this._lastBackgroundingTimestamp) < listenForPauseChangeAfterForegroundInterval;\n\n        if (event.type === 'pause' && isLastBackgroundingRecent) {\n            this._wasPlaying = true;\n        }\n\n        this._lastStalledTimestamp = _.now();\n\n        this._logger.info('[%s] Loading Phenix Real-Time stream player stalling caused by [%s] event.', this._streamId, event.type);\n    }\n\n    function ended() {\n        this._logger.info('[%s] Phenix Real-Time stream ended.', this._streamId);\n    }\n\n    function checkIfWasPlayingWhenGoingToBackground() {\n        if (!this._element) {\n            return;\n        }\n\n        var playing = false;\n        var isLastStallingRecent = _.now() - this._lastStalledTimestamp < listenForPauseChangeAfterForegroundInterval;\n\n        if (_.isBoolean(this._element.playing)) {\n            playing = this._element.playing;\n        } else if (_.isBoolean(this._element.paused)) {\n            playing = !this._element.paused;\n        }\n\n        if (!playing && isLastStallingRecent) {\n            playing = true;\n        }\n\n        this._wasPlaying = playing;\n        this._lastBackgroundingTimestamp = _.now();\n    }\n\n    function resumeWhenEnteringForgeround() {\n        if (!this._element) {\n            return;\n        }\n\n        var that = this;\n\n        this._lastBackgroundingTimestamp = 0;\n        this._lastStalledTimestamp = 0;\n\n        if (!this._wasPlaying) {\n            this._logger.info('[%s] Entering foreground with paused renderer [%s]', this._streamId, this._browser.browser);\n\n            return;\n        }\n\n        this._logger.info('[%s] Resume playing after entering foreground [%s]', this._streamId, this._browser.browser);\n\n        if (this._browser.browser === 'Safari' && FeatureDetector.isIOS()) {\n            // 2020-08-19 Observed on iOS Safari/13\n            var pausing = function pausing() {\n                that._logger.info('Renderer was paused after entering foreground');\n                that._namedEvents.fire(streamEnums.rendererEvents.failedToPlay.name, ['paused-by-background']);\n            };\n\n            _.addEventListener(that._element, 'pause', pausing);\n\n            var timeoutId = setTimeout(function() {\n                _.removeEventListener(that._element, 'pause', pausing);\n            }, listenForPauseChangeAfterForegroundInterval);\n\n            this._disposables.add(new disposable.Disposable(function() {\n                clearTimeout(timeoutId);\n            }));\n\n            // Dispatch to avoid: \"NotAllowedError: The request is not allowed by the user agent or the platform in the current context\"\n            setTimeout(function() {\n                // The first video.play() typically fails with a context error.\n                // Try once so the start logic can properly handle auto muting.\n                that._element.play().catch(function(e) {\n                    that._logger.info('[%s] Unable to resume playback after entering foreground', that._streamId, e);\n                    that._element.src = '';\n\n                    that._logger.info('[%s] (Re)starting renderer', that._streamId);\n                    that.start(that._element);\n                });\n            }, restartRendererDelay);\n        }\n    }\n\n    return PhenixRealTimeRenderer;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    './Room'\n], function(_, assert, observable, Room) {\n    'use strict';\n\n    function ImmutableRoom(roomService, id, alias, name, description, type, members, bridgeId, pin) {\n        this.init(roomService, id, alias, name, description, type, members, bridgeId, pin);\n    }\n\n    ImmutableRoom.prototype.init = function init(roomService, id, alias, name, description, type, members, bridgeId, pin) {\n        this._room = new Room(roomService, id, alias, name, description, type, members, bridgeId, pin);\n\n        makeArrayOrObjectObservablesImmutable(this._room, [roomService]);\n    };\n\n    ImmutableRoom.prototype.getRoomId = function getImmutableRoomId() {\n        return this._room.getRoomId();\n    };\n\n    ImmutableRoom.prototype.getObservableAlias = function getObservableAlias() {\n        return this._room.getObservableAlias();\n    };\n\n    ImmutableRoom.prototype.getObservableName = function getObservableName() {\n        return this._room.getObservableName();\n    };\n\n    ImmutableRoom.prototype.getObservableDescription = function getObservableDescription() {\n        return this._room.getObservableDescription();\n    };\n\n    ImmutableRoom.prototype.getObservableType = function getObservableType() {\n        return this._room.getObservableType();\n    };\n\n    ImmutableRoom.prototype.getObservableMembers = function getObservableMembers() {\n        return this._room.getObservableMembers();\n    };\n\n    ImmutableRoom.prototype.getObservableBridgeId = function getObservableBridgeId() {\n        return this._room.getObservableBridgeId();\n    };\n\n    ImmutableRoom.prototype.getObservablePin = function getObservablePin() {\n        return this._room.getObservablePin();\n    };\n\n    ImmutableRoom.prototype.toString = function toString() {\n        return this._room.toString();\n    };\n\n    ImmutableRoom.prototype.toJson = function toJson() {\n        return this._room.toJson();\n    };\n\n    ImmutableRoom.prototype.commitChanges = throwImmutableError;\n    ImmutableRoom.prototype.reload = throwImmutableError;\n    ImmutableRoom.prototype._update = throwImmutableError;\n    ImmutableRoom.prototype._addMembers = throwImmutableError;\n    ImmutableRoom.prototype._removeMembers = throwImmutableError;\n    ImmutableRoom.prototype._updateMembers = throwImmutableError;\n\n    function throwImmutableError() {\n        throw new Error('ImmutableRoom is Immutable');\n    }\n\n    function throwImmutableSubscribeError() {\n        throw new Error('Unable to subscribe to Immutable [ImmutableRoom]');\n    }\n\n    function makeArrayOrObjectObservablesImmutable(collection, exclude) {\n        if (_.isArray(collection)) {\n            _.forEach(collection, function(value) {\n                wrapObservableAndAnyObservableProperties(value, exclude);\n            });\n        } else if (_.isObject(collection)) {\n            _.forOwn(collection, function(value) {\n                if (_.includes(exclude, value)) {\n                    return;\n                }\n\n                wrapObservableAndAnyObservableProperties(value, exclude);\n            });\n        }\n    }\n\n    function wrapObservableAndAnyObservableProperties(value, exclude) {\n        wrapObservable(value, exclude);\n        makeArrayOrObjectObservablesImmutable(value, exclude);\n    }\n\n    function wrapObservable(value, exclude) {\n        if (value instanceof observable.Observable || value instanceof observable.ObservableArray) {\n            value.setValue = throwImmutableError;\n            value.subscribe = throwImmutableSubscribeError;\n\n            var observableValue = value.getValue();\n\n            makeArrayOrObjectObservablesImmutable(observableValue, exclude);\n        }\n    }\n\n    return ImmutableRoom;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    './ChatService'\n], function(_, assert, observable, disposable, ChatService) {\n    'use strict';\n\n    var defaultBatchSize = 0;\n    var maxCachedQueueSize = 100;\n\n    function RoomChatService(roomService) {\n        assert.isObject(roomService, 'roomService');\n        assert.isObject(roomService._pcast, 'roomService._pcast');\n\n        this._roomService = roomService;\n\n        this._chatMessages = new observable.ObservableArray([]);\n        this._lastChatMessage = new observable.Observable(null);\n        this._disposables = new disposable.DisposableList();\n        this._chatRoomId = null;\n\n        this.setPCast(roomService._pcast);\n    }\n\n    RoomChatService.prototype.setPCast = function setPCast(pcast) {\n        assert.isObject(pcast, 'pcast');\n        assert.isFunction(pcast.getLogger, 'pcast.getLogger');\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n\n        if (this._chatService) {\n            this._chatService.setPCast(pcast);\n        } else {\n            this._chatService = new ChatService(pcast);\n        }\n    };\n\n    RoomChatService.prototype.getBatchSize = function getBatchSize() {\n        return this._batchSize;\n    };\n\n    RoomChatService.prototype.start = function start(batchSize) {\n        this._batchSize = batchSize || defaultBatchSize;\n        this._chatService.start();\n\n        setupSubscriptions.call(this);\n        setupMessageSubscription.call(this);\n    };\n\n    RoomChatService.prototype.stop = function stop() {\n        this._chatService.stop();\n\n        disposeOfMessageSubscription.call(this);\n\n        if (this._disposables) {\n            this._disposables.dispose();\n        }\n    };\n\n    RoomChatService.prototype.getObservableChatMessages = function getObservableChatMessages() {\n        return this._chatMessages;\n    };\n\n    RoomChatService.prototype.getObservableLastChatMessage = function getObservableLastChatMessage() {\n        return this._lastChatMessage;\n    };\n\n    RoomChatService.prototype.getObservableChatEnabled = function getObservableChatEnabled() {\n        return this._chatService.getObservableChatEnabled();\n    };\n\n    RoomChatService.prototype.canSendMessage = function canSendMessage() {\n        return this._chatService.canSendMessage();\n    };\n\n    RoomChatService.prototype.sendMessageToRoom = function sendMessageToRoom(message, callback) {\n        var room = this._roomService.getObservableActiveRoom().getValue();\n\n        if (!room) {\n            return callback(new Error('Not in room'), null);\n        }\n\n        var roomId = room.getRoomId();\n        var self = this._roomService._self.getValue();\n\n        if (!self) {\n            return callback(new Error('No record for oneself'), null);\n        }\n\n        var screenName = self.getObservableScreenName().getValue();\n        var role = self.getObservableRole().getValue();\n        var lastUpdate = self.getLastUpdate();\n\n        this._chatService.sendMessageToRoom(roomId, screenName, role, lastUpdate, message, callback);\n    };\n\n    RoomChatService.prototype.getMessages = function getMessages(batchSize, afterMessageId, beforeMessageId, callback) {\n        var room = this._roomService.getObservableActiveRoom().getValue();\n        var roomId = room.getRoomId();\n\n        return this._chatService.getMessages(roomId, batchSize, afterMessageId, beforeMessageId, callback);\n    };\n\n    RoomChatService.prototype.toString = function toString() {\n        return 'RoomChatService';\n    };\n\n    function onRoomChange(room) {\n        if (room && this._chatRoomId === room.getRoomId()) {\n            return;\n        }\n\n        disposeOfMessageSubscription.call(this);\n\n        if (room) {\n            setupMessageSubscription.call(this);\n        }\n    }\n\n    function setupSubscriptions() {\n        var roomSubscription = this._roomService.getObservableActiveRoom().subscribe(_.bind(onRoomChange, this));\n\n        this._disposables.add(roomSubscription);\n    }\n\n    function setupMessageSubscription() {\n        disposeOfMessageSubscription.call(this);\n\n        this._roomChatSubscription = subscribeAndLoadMessages.call(this, this._batchSize);\n    }\n\n    function disposeOfMessageSubscription() {\n        if (this._roomChatSubscription && this._roomChatSubscription.dispose) {\n            this._roomChatSubscription.dispose();\n        }\n    }\n\n    function subscribeAndLoadMessages(batchSize) {\n        var room = this._roomService.getObservableActiveRoom().getValue();\n        var roomId = room.getRoomId();\n\n        this._chatRoomId = roomId;\n\n        var that = this;\n\n        this._chatMessages.setValue([]);\n\n        return this._chatService.subscribeAndLoadMessages(roomId, batchSize, function onReceiveMessages(error, response) {\n            if (error) {\n                throw error;\n            }\n\n            if (response.status !== 'ok') {\n                throw new Error('Unable to subscribe to room chat. Status [' + response.status + ']');\n            }\n\n            var messages = that._chatMessages.getValue();\n\n            _.forEach(response.chatMessages, function addMessage(message) {\n                var insertIdx = messages.length;\n\n                // Find its position in the history\n                while (insertIdx > 0 && message.messageId < _.get(messages, [insertIdx - 1, 'messageId'])) {\n                    insertIdx--;\n                }\n\n                if (insertIdx === 0 && messages.length > 0) {\n                    that._logger.info('[%] Ignoring message [%s]/[%s] prior to current chat history to prevent gaps.',\n                        roomId, message.messageId, message.timestamp);\n\n                    return;\n                }\n\n                if (insertIdx > 0 && _.get(messages, [insertIdx - 1, 'messageId']) === message.messageId) {\n                    that._logger.info('[%] Ignoring duplicate message [%s]/[%s]',\n                        roomId, message.messageId, message.timestamp);\n\n                    return;\n                }\n\n                messages.splice(insertIdx, 0, message);\n\n                that._lastChatMessage.setValue(message);\n            });\n\n            if (messages.length > maxCachedQueueSize) {\n                messages.splice(0, messages.length - maxCachedQueueSize);\n            }\n\n            that._chatMessages.setValue(messages);\n        });\n    }\n\n    return RoomChatService;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    '../authentication/AuthenticationService'\n], function(_, assert, observable, disposable, AuthenticationService) {\n    'use strict';\n\n    function ChatService(pcast) {\n        assert.isObject(pcast, 'pcast');\n        assert.isFunction(pcast.getLogger, 'pcast.getLogger');\n        assert.isFunction(pcast.getProtocol, 'pcast.getProtocol');\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n        this._protocol = pcast.getProtocol();\n        this._enabled = new observable.Observable(false);\n\n        assert.isObject(this._logger, 'this._logger');\n        assert.isObject(this._protocol, 'this._protocol');\n\n        this._authenticationService = new AuthenticationService(pcast);\n    }\n\n    ChatService.prototype.setPCast = function setPCast(pcast) {\n        assert.isObject(pcast, 'pcast');\n        assert.isFunction(pcast.getLogger, 'pcast.getLogger');\n        assert.isFunction(pcast.getProtocol, 'pcast.getProtocol');\n\n        this._pcast = pcast;\n        this._logger = pcast.getLogger();\n        this._protocol = pcast.getProtocol();\n\n        this._authenticationService.setPCast(pcast);\n    };\n\n    ChatService.prototype.start = function start() {\n        if (this._enabled.getValue()) {\n            return;\n        }\n\n        this._disposables = new disposable.DisposableList();\n        this._roomMessagesListeners = {};\n\n        this._enabled.setValue(true);\n        setupSubscriptions.call(this);\n\n        var disposeOfConversationHandler = this._protocol.onEvent('chat.RoomConversationEvent', _.bind(onRoomConversationEvent, this));\n\n        this._disposables.add(disposeOfConversationHandler);\n    };\n\n    ChatService.prototype.stop = function stop() {\n        if (!this._enabled.getValue()) {\n            return;\n        }\n\n        this._enabled.setValue(false);\n\n        if (this._disposables) {\n            this._disposables.dispose();\n        }\n    };\n\n    ChatService.prototype.getObservableChatEnabled = function getObservableChatEnabled() {\n        return this._enabled;\n    };\n\n    ChatService.prototype.canSendMessage = function canSendMessage() {\n        return this._authenticationService.checkAuthorized();\n    };\n\n    ChatService.prototype.sendMessageToRoom = function sendMessageToRoom(roomId, screenName, role, lastUpdate, message, callback) {\n        sendMessageRequest.call(this, roomId, screenName, role, lastUpdate, message, callback);\n    };\n\n    ChatService.prototype.subscribeAndLoadMessages = function subscribeAndLoadMessages(roomId, batchSize, onReceiveMessages) {\n        var disposeOfListener = setupChatListener.call(this, roomId, onReceiveMessages);\n\n        subscribeToRoomConversationRequest.call(this, roomId, batchSize);\n\n        return disposeOfListener;\n    };\n\n    ChatService.prototype.getMessages = function getMessages(roomId, batchSize, afterMessageId, beforeMessageId, onReceiveMessages) {\n        getMessagesRequest.call(this, roomId, batchSize, afterMessageId, beforeMessageId, onReceiveMessages);\n    };\n\n    ChatService.prototype.toString = function toString() {\n        return 'ChatService';\n    };\n\n    function setupSubscriptions() {\n        var pcastStatusSubscription = this._authenticationService.getObservableStatus().subscribe(_.bind(onStatusChange, this));\n\n        this._disposables.add(pcastStatusSubscription);\n    }\n\n    function setupChatListener(roomId, onReceiveMessages) {\n        var that = this;\n\n        this._roomMessagesListeners[roomId] = onReceiveMessages;\n\n        var disposeOfHandler = new disposable.Disposable(function() {\n            if (that._roomMessagesListeners[roomId] === onReceiveMessages) {\n                delete that._roomMessagesListeners[roomId];\n            }\n        });\n\n        this._disposables.add(disposeOfHandler);\n\n        return disposeOfHandler;\n    }\n\n    function onRoomConversationEvent(event) {\n        assert.isObject(event, 'event');\n        assert.isStringNotEmpty(event.roomId, 'event.roomId');\n        assert.isStringNotEmpty(event.eventType, 'event.eventType');\n        assert.isArray(event.chatMessages, 'event.chatMessages');\n\n        switch (event.eventType) {\n        case 'Message':\n            this._logger.debug('[%s] Room messages [%s]', event.roomId, event.chatMessages);\n\n            var listener = this._roomMessagesListeners[event.roomId];\n\n            convertTimeFromLongInChatMessages(event.chatMessages);\n\n            if (listener) {\n                listener(null, {\n                    status: 'ok',\n                    chatMessages: event.chatMessages\n                });\n            }\n\n            break;\n        default:\n            this._logger.warn('Unsupported room conversation event [%s]', event.eventType);\n        }\n    }\n\n    function onStatusChange(status) { // eslint-disable-line no-unused-vars\n        // Only reason to redo subscriptions is if sessionId changes, which infers status changed\n    }\n\n    function getMessagesRequest(roomId, batchSize, afterMessageId, beforeMessageId, callback) {\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isFunction(callback, 'callback');\n\n        if (!beforeMessageId || !afterMessageId) {\n            assert.isNumber(batchSize, 'batchSize');\n        }\n\n        if (beforeMessageId) {\n            assert.isStringNotEmpty(beforeMessageId, 'beforeMessageId');\n        }\n\n        if (afterMessageId) {\n            assert.isStringNotEmpty(afterMessageId, 'afterMessageId');\n        }\n\n        assertEnabled.call(this);\n        this._authenticationService.assertAuthorized();\n\n        var sessionId = this._authenticationService.getPCastSessionId();\n\n        this._logger.info('Get messages from room [%s] conversation with batch size of [%s], after [%s], and before [%s]', roomId, batchSize, afterMessageId, beforeMessageId);\n\n        var that = this;\n\n        this._protocol.getMessages(sessionId, roomId, batchSize, afterMessageId, beforeMessageId,\n            function(error, response) {\n                if (error) {\n                    that._logger.error('Get messages from room conversation failed with error [%s]', error);\n\n                    return callback(error, null);\n                }\n\n                var result = {status: response.status};\n\n                if (response.status !== 'ok') {\n                    that._logger.warn('Get messages from room conversation failed with status [%s]', response.status);\n\n                    return callback(null, result);\n                }\n\n                result.chatMessages = response.chatMessages;\n\n                convertTimeFromLongInChatMessages(result.chatMessages);\n\n                callback(null, result);\n            }\n        );\n    }\n\n    function subscribeToRoomConversationRequest(roomId, batchSize) {\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isNumber(batchSize, 'batchSize');\n\n        assertEnabled.call(this);\n        this._authenticationService.assertAuthorized();\n\n        var sessionId = this._authenticationService.getPCastSessionId();\n\n        this._logger.info('Subscribe to room [%s] conversation with batch size of [%s]', roomId, batchSize);\n\n        var that = this;\n\n        this._protocol.subscribeToRoomConversation(sessionId, roomId, batchSize, function(error, response) {\n            var onReceiveMessages = that._roomMessagesListeners[roomId];\n\n            if (!onReceiveMessages) {\n                return that._logger.warn('No subscription callback set for room [%s]', roomId);\n            }\n\n            if (error) {\n                that._logger.error('Subscribe to room conversation failed with error [%s]', error);\n\n                return onReceiveMessages(error, null);\n            }\n\n            var result = {status: response.status};\n\n            if (response.status !== 'ok') {\n                delete that._roomMessagesListeners[roomId];\n\n                that._logger.warn('Subscribe to room conversation failed with status [%s]', response.status);\n\n                return onReceiveMessages(null, result);\n            }\n\n            result.chatMessages = response.chatMessages;\n\n            convertTimeFromLongInChatMessages(result.chatMessages);\n\n            onReceiveMessages(null, result);\n        });\n    }\n\n    function sendMessageRequest(roomId, screenName, role, lastUpdate, message, callback) {\n        assert.isStringNotEmpty(roomId, 'roomId');\n        assert.isStringNotEmpty(screenName, 'screenName');\n        assert.isStringNotEmpty(role, 'role');\n        assert.isNumber(lastUpdate, 'lastUpdate');\n        assert.isStringNotEmpty(message, 'message');\n        assert.isFunction(callback, 'callback');\n\n        assertEnabled.call(this);\n        this._authenticationService.assertAuthorized();\n\n        var sessionId = this._authenticationService.getPCastSessionId();\n\n        var chatMessage = {\n            messageId: '',\n            timestamp: 0,\n            from: {\n                sessionId: sessionId,\n                screenName: screenName,\n                role: role,\n                lastUpdate: lastUpdate\n            },\n            message: message\n        };\n\n        this._logger.info('Send message to room [%s] from [%s]', roomId, screenName);\n\n        var that = this;\n\n        return this._protocol.sendMessageToRoom(roomId, chatMessage, function(error, response) {\n            if (error) {\n                that._logger.error('Send message to room failed with error [%s]', error);\n\n                return callback(error, null);\n            }\n\n            var result = {status: response.status};\n\n            if (response.status !== 'ok') {\n                that._logger.warn('Send message to room failed with status [%s]', response.status);\n            }\n\n            callback(null, result);\n        });\n    }\n\n    function assertEnabled() {\n        if (!this._enabled.getValue()) {\n            throw new Error('ChatService not Enabled. Please start before performing actions.');\n        }\n    }\n\n    function convertTimeFromLongInChatMessages(chatMessages) {\n        _.forEach(chatMessages, function(chatMessage) {\n            convertTimeFromLongInChatMessage(chatMessage);\n        });\n    }\n\n    function convertTimeFromLongInChatMessage(chatMessage) {\n        if (chatMessage.timestamp) {\n            chatMessage.timestamp = _.utc(chatMessage.timestamp);\n        }\n\n        if (chatMessage.from) {\n            chatMessage.from.lastUpdate = _.utc(chatMessage.from.lastUpdate);\n        }\n    }\n\n    return ChatService;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    '../logging/pcastLoggerFactory',\n    '../PCastEndPoint',\n    './AudioContext',\n    './AudioVolumeMeterFactory',\n    './AudioSpeakerDetectionAlgorithm'\n], function(_, assert, pcastLoggerFactory, PCastEndPoint, AudioContext, AudioVolumeMeterFactory, AudioSpeakerDetectionAlgorithm) {\n    'use strict';\n\n    function AudioSpeakerDetector(userMediaStreams, options) {\n        assert.isArray(userMediaStreams, 'userMediaStreams');\n\n        options = options || {};\n\n        this._baseUri = options.uri || PCastEndPoint.DefaultPCastUri;\n        this._logger = options.logger || pcastLoggerFactory.createPCastLogger(this._baseUri);\n        this._audioContext = options.audioContext || new AudioContext();\n        this._nativeAudioContext = this._audioContext.getNativeAudioContext();\n        this._onSpeakingChanged = null;\n        this._userMediaStreams = userMediaStreams;\n        this._disposeOfAudioContext = !_.isObject(options.audioContext);\n        this._audioVolumeMeterFactory = new AudioVolumeMeterFactory(this._logger);\n\n        _.forEach(this._userMediaStreams, _.bind(setupAudioVolumeMeter, this, options));\n    }\n\n    AudioSpeakerDetector.prototype.start = function start(options, callback) {\n        assert.isFunction(callback, 'callback');\n\n        this._onSpeakingChanged = callback;\n\n        options = options || {};\n\n        _.forEach(this._userMediaStreams, _.bind(setupSpeakingDetection, this, options));\n    };\n\n    AudioSpeakerDetector.prototype.stop = function stop() {\n        _.forEach(this.getAudioVolumeMeters(), function(meter) {\n            meter.onValue(function() {});\n        });\n\n        this._onSpeakingChanged = null;\n    };\n\n    AudioSpeakerDetector.prototype.getAudioVolumeMeter = function getAudioVolumeMeter(stream) {\n        assert.isObject(stream, 'stream');\n\n        return this._audioVolumeMeterFactory.getAudioVolumeMeter(stream);\n    };\n\n    AudioSpeakerDetector.prototype.getAudioVolumeMeters = function getAudioVolumeMeters() {\n        return this._audioVolumeMeterFactory.getAudioVolumeMeters();\n    };\n\n    AudioSpeakerDetector.prototype.dispose = function dispose() {\n        if (this._disposeOfAudioContext) {\n            this._nativeAudioContext.close();\n        }\n\n        this._audioVolumeMeterFactory.stopAllMeters();\n\n        this._userMediaStreams = null;\n    };\n\n    AudioSpeakerDetector.prototype.toString = function toString() {\n        return 'AudioSpeakerDetector';\n    };\n\n    function setupAudioVolumeMeter(options, stream) {\n        assert.isObject(stream, 'stream');\n        assert.isObject(options, 'options');\n\n        var audioVolumeMeter = this._audioVolumeMeterFactory.getAudioVolumeMeter(stream);\n\n        audioVolumeMeter.init(this._nativeAudioContext, options.alpha);\n        audioVolumeMeter.connect(stream);\n    }\n\n    function setupSpeakingDetection(options, stream) {\n        assert.isObject(stream, 'stream');\n        assert.isObject(options, 'options');\n\n        var audioVolumeMeter = this._audioVolumeMeterFactory.getAudioVolumeMeter(stream);\n        var audioSpeakerDetectionAlgorithm = new AudioSpeakerDetectionAlgorithm(this._logger);\n\n        if (options.alpha) {\n            audioVolumeMeter.setAlpha(options.alpha);\n        }\n\n        audioSpeakerDetectionAlgorithm.onValue(this._onSpeakingChanged);\n        audioSpeakerDetectionAlgorithm.startDetection(audioVolumeMeter, options);\n    }\n\n    return AudioSpeakerDetector;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    './AudioVolumeMeter'\n], function(_, assert, AudioVolumeMeter) {\n    'use strict';\n\n    function AudioVolumeMeterFactory(logger) {\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n        this._audioVolumeMeters = {};\n    }\n\n    AudioVolumeMeterFactory.prototype.stopAllMeters = function stopAllMeters() {\n        _.forOwn(this._audioVolumeMeters, function stopAudioVolumeMeters(meter) {\n            meter.stop();\n        });\n    };\n\n    AudioVolumeMeterFactory.prototype.getAudioVolumeMeter = function getAudioVolumeMeter(stream) {\n        assert.isObject(stream, 'stream');\n        assert.isStringNotEmpty(stream.id, 'streamId');\n\n        if (!this._audioVolumeMeters[stream.id]) {\n            this._audioVolumeMeters[stream.id] = new AudioVolumeMeter(this._logger);\n        }\n\n        return this._audioVolumeMeters[stream.id];\n    };\n\n    AudioVolumeMeterFactory.prototype.getAudioVolumeMeters = function getAudioVolumeMeters() {\n        return _.values(this._audioVolumeMeters);\n    };\n\n    AudioVolumeMeterFactory.prototype.toString = function toString() {\n        return 'AudioVolumeMeterFactory';\n    };\n\n    return AudioVolumeMeterFactory;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var defaultAlpha = 1 / 16;\n\n    function AudioVolumeMeter(logger) {\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n    }\n\n    AudioVolumeMeter.prototype.init = function init(context, alpha) {\n        assert.isObject(context, 'context');\n        assert.isFunction(context.createScriptProcessor, 'context.createScriptProcessor');\n\n        alpha = parseFloat(alpha || defaultAlpha);\n        assert.isNumber(alpha, 'alpha');\n\n        this._context = context;\n        this._alpha = alpha;\n        this._value = 0.;\n        this._smoothedValue = 0.;\n        this._smoothedPeakValue = 0.;\n        this._clipped = 0.;\n        this._scriptProcessor = context.createScriptProcessor(4096, 1, 1);\n\n        _.addEventListener(this._scriptProcessor, 'audioprocess', _.bind(onAudioProcess, this));\n    };\n\n    AudioVolumeMeter.prototype.onValue = function onValue(callback) {\n        this._callback = callback;\n    };\n\n    AudioVolumeMeter.prototype.getValue = function getValue() {\n        return this._value;\n    };\n\n    AudioVolumeMeter.prototype.getSmoothedValue = function getSmoothedValue() {\n        return this._smoothedValue;\n    };\n\n    AudioVolumeMeter.prototype.getSmoothedPeakValue = function getSmoothedPeakValue() {\n        return this._smoothedPeakValue;\n    };\n\n    AudioVolumeMeter.prototype.setAlpha = function setAlpha(alpha) {\n        assert.isNumber(alpha, 'alpha');\n\n        this._alpha = parseFloat(alpha);\n    };\n\n    AudioVolumeMeter.prototype.connect = function connect(stream) {\n        var that = this;\n\n        return connectToStream.call(that, stream);\n    };\n\n    AudioVolumeMeter.prototype.stop = function stop() {\n        return stopConnections.call(this);\n    };\n\n    AudioVolumeMeter.prototype.toString = function toString() {\n        return 'AudioVolumeMeter';\n    };\n\n    function onAudioProcess(event) {\n        var input = event.inputBuffer.getChannelData(0);\n        var sum = 0.;\n        var clipped = 0;\n\n        for (var i = 0; i < input.length; i++) {\n            sum += input[i] * input[i];\n\n            if (Math.abs(input[i]) > 0.99) {\n                clipped++;\n            }\n        }\n\n        this._value = Math.sqrt(sum / input.length);\n        this._smoothedValue = this._alpha * this._value + (1. - this._alpha) * this._smoothedValue;\n        this._smoothedPeakValue = Math.max(this._value, this._alpha * this._value + (1. - this._alpha) * this._smoothedPeakValue);\n        this._clipped = clipped;\n\n        if (this._callback) {\n            this._callback.call(this, {\n                date: _.now(),\n                value: this._value,\n                smoothedValue: this._smoothedValue,\n                smoothedPeakValue: this._smoothedPeakValue,\n                clipped: this._clipped\n            });\n        }\n    }\n\n    function connectToStream(stream) {\n        assert.isObject(stream, 'stream');\n\n        var that = this;\n\n        if (stream.getAudioTracks().length > 0) {\n            that._mediaStreamSource = that._context.createMediaStreamSource(stream);\n            that._mediaStreamSource.connect(that._scriptProcessor);\n            that._scriptProcessor.connect(that._context.destination);\n        } else {\n            that._logger.info('Stream has no audio tracks');\n        }\n    }\n\n    function stopConnections() {\n        if (this._mediaStreamSource) {\n            this._mediaStreamSource.disconnect();\n        }\n\n        this._scriptProcessor.disconnect();\n    }\n\n    return AudioVolumeMeter;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var defaultSpeakingHysteresisInterval = 50;\n    var defaultSilenceHysteresisInterval = 1500;\n\n    function AudioSpeakerDetectionAlgorithm(logger) {\n        assert.isObject(logger, 'logger');\n\n        this._logger = logger;\n\n        this.init();\n    }\n\n    AudioSpeakerDetectionAlgorithm.prototype.init = function init() {\n\n    };\n\n    AudioSpeakerDetectionAlgorithm.prototype.onValue = function onValue(callback) {\n        this._callback = callback;\n    };\n\n    AudioSpeakerDetectionAlgorithm.prototype.startDetection = function startDetection(audioVolumeMeter, options) {\n        var that = this;\n\n        return startAudioDetection.call(that, audioVolumeMeter, options);\n    };\n\n    AudioSpeakerDetectionAlgorithm.prototype.toString = function toString() {\n        return 'AudioSpeakerDetection';\n    };\n\n    function startAudioDetection(audioVolumeMeter, options) {\n        assert.isObject(audioVolumeMeter, 'audioVolumeMeter');\n\n        options = options || {};\n\n        var that = this;\n        var stopped = false;\n        var speakingHysteresisInterval = options.speakingHysteresisInterval || defaultSpeakingHysteresisInterval;\n        var silenceHysteresisInterval = options.silenceHysteresisInterval || defaultSilenceHysteresisInterval;\n\n        assert.isNumber(speakingHysteresisInterval, 'options.speakingHysteresisInterval');\n        assert.isNumber(silenceHysteresisInterval, 'options.silenceHysteresisInterval');\n\n        var speaking = false;\n        var nextSpeakingDeadline = _.now() + speakingHysteresisInterval;\n        var nextSilenceDeadline = _.now() + silenceHysteresisInterval;\n\n        audioVolumeMeter.onValue(function(value) {\n            if (stopped) {\n                return;\n            }\n\n            assert.isObject(audioVolumeMeter, 'audioVolumeMeter');\n            assert.isNumber(value.date, 'value.date');\n            assert.isNumber(value.value, 'value.value');\n            assert.isNumber(value.smoothedValue, 'value.smoothedValue');\n            assert.isNumber(value.smoothedPeakValue, 'value.smoothedPeakValue');\n            assert.isNumber(value.clipped, 'value.clipped');\n\n            var speakingThreshold = value.value > 0.01 && value.value > 2 * value.smoothedValue && value.value > 0.25 * value.smoothedPeakValue;\n            var speakingContinuationThreshold = value.value > 0.8 * value.smoothedValue;\n            var notSpeakingThreshold = value.value < 0.5 * value.smoothedValue;\n            var notSpeakingContinuationThreshold = !speakingThreshold;\n\n            if ((speakingThreshold || (speaking && speakingContinuationThreshold)) && nextSpeakingDeadline < value.date) {\n                nextSilenceDeadline = _.utc(value.date) + silenceHysteresisInterval;\n\n                if (!speaking) {\n                    speaking = true;\n\n                    that._logger.info('Speaking detected');\n\n                    if (that._callback) {\n                        that._callback('speaking');\n                    }\n                }\n            } else if ((notSpeakingThreshold || (!speaking && notSpeakingContinuationThreshold)) && nextSilenceDeadline < value.date) {\n                nextSpeakingDeadline = _.utc(value.date) + speakingHysteresisInterval;\n\n                if (speaking) {\n                    speaking = false;\n\n                    that._logger.info('Silence detected');\n\n                    if (that._callback) {\n                        that._callback('silence');\n                    }\n                }\n            }\n        });\n    }\n\n    return AudioSpeakerDetectionAlgorithm;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    '../logging/pcastLoggerFactory',\n    '../PCastEndPoint',\n    './PublisherBandwidthAdjuster'\n], function(_, assert, pcastLoggerFactory, PCastEndPoint, PublisherBandwidthAdjuster) {\n    'use strict';\n\n    function BandwidthMonitor(publishers, options) {\n        assert.isArray(publishers, 'userMediaStreams');\n\n        options = options || {};\n\n        this._baseUri = options.uri || PCastEndPoint.DefaultPCastUri;\n        this._logger = options.logger || pcastLoggerFactory.createPCastLogger(this._baseUri);\n        this._publisherAdjusters = [];\n        this._publishers = publishers;\n    }\n\n    BandwidthMonitor.prototype.start = function start(roomService, options) {\n        options = options || {};\n\n        _.forEach(this._publishers, _.bind(setupPublisherAdjusters, this, roomService, options));\n    };\n\n    BandwidthMonitor.prototype.stop = function stop() {\n        _.forEach(this._publisherAdjusters, function closePublisherAdjusters(adjuster) {\n            adjuster.close();\n        });\n\n        this._publisherAdjusters = [];\n    };\n\n    BandwidthMonitor.prototype.toString = function toString() {\n        return 'BandwidthMonitor';\n    };\n\n    function setupPublisherAdjusters(roomService, options, publisher) {\n        var publisherAdjuster = new PublisherBandwidthAdjuster(publisher);\n\n        publisherAdjuster.connect(roomService, options);\n\n        this._publisherAdjusters.push(publisherAdjuster);\n    }\n\n    return BandwidthMonitor;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var defaultRoomBandwidthLimit = 5000000;\n\n    function PublisherBandwidthAdjuster(publisher) {\n        this.init(publisher);\n    }\n\n    PublisherBandwidthAdjuster.prototype.init = function init(publisher) {\n        assert.isObject(publisher, 'publisher');\n\n        this._publisher = publisher;\n        this._roomMemberCount = 0;\n        this._roomSubscription = null;\n        this._membersSubscription = null;\n    };\n\n    PublisherBandwidthAdjuster.prototype.connect = function connect(roomService, options) {\n        assert.isObject(roomService, 'roomService');\n\n        options = options || {};\n\n        var roomObservable = roomService.getObservableActiveRoom();\n        var roomBandwidthLimit = options.roomBandwidthLimit || defaultRoomBandwidthLimit;\n\n        this._roomSubscription = roomObservable.subscribe(_.bind(onRoomChange, this, roomBandwidthLimit), {initial: 'notify'});\n    };\n\n    PublisherBandwidthAdjuster.prototype.close = function close() {\n        if (this._roomSubscription) {\n            this._roomSubscription.dispose();\n        }\n\n        if (this._membersSubscription) {\n            this._membersSubscription.dispose();\n        }\n\n        this._roomSubscription = null;\n        this._membersSubscription = null;\n    };\n\n    PublisherBandwidthAdjuster.prototype.toString = function toString() {\n        return 'PublisherBandwidthAdjuster';\n    };\n\n    function onRoomChange(roomBandwidthLimit, room) {\n        if (this._membersSubscription) {\n            this._membersSubscription.dispose();\n        }\n\n        if (!room) {\n            return this._publisher.limitBandwidth(roomBandwidthLimit);\n        }\n\n        var membersObservable = room.getObservableMembers();\n\n        this._membersSubscription = membersObservable.subscribe(_.bind(onRoomMembersChanged, this, roomBandwidthLimit), {initial: 'notify'});\n    }\n\n    function onRoomMembersChanged(roomBandwidthLimit, members) {\n        if (members.length === this._roomMemberCount) {\n            return;\n        }\n\n        this._roomMemberCount = members.length;\n\n        var targetBitRate = roomBandwidthLimit / Math.max(1, this._roomMemberCount - 1);\n\n        this._publisher.limitBandwidth(targetBitRate);\n    }\n\n    return PublisherBandwidthAdjuster;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert'\n], function(_, assert) {\n    'use strict';\n\n    var aspectRatios = [\n        {\n            '9x16': [\n                {3840: 2160}, // 4k (UHD)\n                {1920: 1080}, // 1080p (FHD)\n                {1366: 768}, //\n                {1280: 720}, // 720p(HD)\n                {1024: 576},\n                {854: 480}, // 480p\n                {640: 360}, // 360p (nHD)\n                {320: 180}\n            ]\n        },\n        {\n            '3x4': [\n                {1600: 1200}, // UXGA\n                {1440: 1080},\n                {960: 720},\n                {800: 600}, // SVGA\n                {768: 576},\n                {640: 480}, // VGA\n                {480: 360},\n                {352: 288}, // CIF\n                {320: 240}, // QVGA\n                {176: 144}, // QCIF\n                {160: 120} // QQVGA\n            ]\n        },\n        {\n            '16x9': [\n                {2160: 3840}, // 4k (UHD)\n                {1080: 1920}, // 1080p (FHD)\n                {768: 1366}, //\n                {720: 1280}, // 720p(HD)\n                {576: 1024},\n                {480: 854}, // 480p\n                {360: 640}, // 360p (nHD)\n                {180: 320}\n            ]\n        },\n        {\n            '4x3': [\n                {1200: 1600}, // UXGA\n                {1080: 1440},\n                {720: 960},\n                {600: 800}, // SVGA\n                {576: 768},\n                {480: 640}, // VGA\n                {360: 480},\n                {288: 352}, // CIF\n                {240: 320}, // QVGA\n                {144: 176}, // QCIF\n                {120: 160} // QQVGA\n            ]\n        }\n    ];\n    var resolutionSelectionStrategies = {\n        fallbackToLower: {\n            id: 0,\n            name: 'fallbackToLower'\n        },\n        fallbackToHigher: {\n            id: 1,\n            name: 'fallbackToHigher'\n        },\n        fallbackToLowerThenHigher: {\n            id: 2,\n            name: 'fallbackToLowerThenHigher'\n        },\n        exact: {\n            id: 3,\n            name: 'exact'\n        }\n    };\n\n    function ResolutionProvider(options) {\n        assert.isObject(options, 'options');\n\n        if (options.resolutionSelectionStrategy) {\n            assert.isValidType(options.resolutionSelectionStrategy, resolutionSelectionStrategies, 'options.resolutionSelectionStrategy');\n        }\n\n        if (options.aspectRatio) {\n            assert.isStringNotEmpty(options.aspectRatio, 'options.aspectRatio');\n        }\n\n        if (options.resolution) {\n            assert.isNumber(options.resolution, 'options.resolution');\n        }\n\n        if (options.frameRate) {\n            assert.isNumber(options.frameRate, 'options.frameRate');\n        }\n\n        this._resolutionSelectionStrategy = options.resolutionSelectionStrategy || resolutionSelectionStrategies.fallbackToLowerThenHigher.name;\n        this._defaultAspectRatio = options.aspectRatio || '16x9';\n        this._defaultResolution = parseInt(options.resolution, 10) || 720;\n        this._defaultResolutionHeight = calculateHeight.call(this, this._defaultAspectRatio, this._defaultResolution);\n        this._defaultFrameRate = options.frameRate || 15;\n    }\n\n    ResolutionProvider.prototype.getDefaultResolution = function getDefaultResolution() {\n        var longerDimension = this.calculateLongerDimensionByAspectRatio(this._defaultResolution, this._defaultAspectRatio);\n\n        switch (this._defaultAspectRatio) {\n        // Portrait\n        case '9x16':\n        case '3x4':\n            return {\n                resolution: this._defaultResolution,\n                aspectRatio: this._defaultAspectRatio,\n                height: longerDimension,\n                width: this._defaultResolution\n            };\n        // Landscape\n        case '16x9':\n        case '4x3':\n        default:\n            return {\n                resolution: this._defaultResolution,\n                aspectRatio: this._defaultAspectRatio,\n                height: this._defaultResolution,\n                width: longerDimension\n            };\n        }\n    };\n\n    ResolutionProvider.prototype.getDefaultFrameRate = function getDefaultFrameRate() {\n        return this._defaultFrameRate;\n    };\n\n    ResolutionProvider.prototype.getNextResolution = function getNextResolution(height, aspectRatio) {\n        assert.isNumber(height, 'height');\n        assert.isStringNotEmpty(aspectRatio, 'aspectRatio');\n\n        switch (this._resolutionSelectionStrategy) {\n        case resolutionSelectionStrategies.fallbackToLower.name:\n            return getNextLowestResolution.call(this, height, aspectRatio);\n        case resolutionSelectionStrategies.fallbackToHigher.name:\n            return getNextHighestResolution.call(this, height, aspectRatio);\n        case resolutionSelectionStrategies.fallbackToLowerThenHigher.name:\n            var nextResolution = null;\n\n            if (height > this._defaultResolutionHeight) {\n                nextResolution = getNextHighestResolution.call(this, height, aspectRatio);\n            } else {\n                nextResolution = getNextLowestResolution.call(this, height, aspectRatio);\n\n                if (!nextResolution || !nextResolution.height) {\n                    nextResolution = getNextHighestResolution.call(this, this._defaultResolution, this._defaultAspectRatio);\n                }\n            }\n\n            return nextResolution;\n        case resolutionSelectionStrategies.exact.name:\n        default:\n            return;\n        }\n    };\n\n    ResolutionProvider.prototype.canResolveNextResolution = function() {\n        return this._resolutionSelectionStrategy !== resolutionSelectionStrategies.exact.name;\n    };\n\n    ResolutionProvider.prototype.calculateLongerDimensionByAspectRatio = function calculateLongerDimensionByAspectRatio(shorterDimension, aspectRatio) {\n        switch (aspectRatio) {\n        case '16x9':\n        case '9x16':\n            return roundUpToNearestEvenNumber((16 / 9) * shorterDimension);\n        case '4x3':\n        case '3x4':\n            return roundUpToNearestEvenNumber((4 / 3) * shorterDimension);\n        default:\n            throw new Error('Aspect Ratio not supported');\n        }\n    };\n\n    function roundUpToNearestEvenNumber(value) {\n        assert.isNumber(value, 'value');\n\n        return 2 * Math.floor((value + 1) / 2);\n    }\n\n    function calculateHeight(aspectRatio, resolution) {\n        assert.isStringNotEmpty(aspectRatio, 'aspectRatio');\n        assert.isNumber(resolution, 'resolution');\n\n        switch (aspectRatio) {\n        case '16x9':\n        case '4x3':\n            return resolution;\n        case '9x16':\n            return roundUpToNearestEvenNumber((16 / 9) * resolution);\n        case '3x4':\n            return roundUpToNearestEvenNumber((4 / 3) * resolution);\n        default:\n            throw new Error('Aspect Ratio not supported');\n        }\n    }\n\n    function getNextHighestResolution(height, aspectRatio) {\n        var aspectRatioHeights = getObjectValueInArray(aspectRatio, aspectRatios);\n        var aspectRatioIndex = getIndexInArray(aspectRatio, aspectRatios);\n        var heightIndex = getIndexInArray(height.toString(), aspectRatioHeights);\n        var isLargestHeight = heightIndex === 0;\n        var isSmallestAspectRatio = aspectRatios.length - 1 === aspectRatioIndex;\n\n        var newAspectRatio;\n        var newAspectRatioHeights;\n        var newHeight;\n        var newWidth;\n\n        if (heightIndex < 0) {\n            heightIndex = getNextHighestKeyIndex(height, aspectRatioHeights);\n\n            if (heightIndex < 0) {\n                return null;\n            }\n        } else {\n            if (isLargestHeight) {\n                if (isSmallestAspectRatio) {\n                    return null;\n                }\n\n                aspectRatioIndex++;\n\n                newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);\n                newAspectRatioHeights = getObjectValueInArray(newAspectRatio, aspectRatios);\n                heightIndex = getNextHighestKeyIndex(this._defaultResolutionHeight, newAspectRatioHeights);\n\n                if (heightIndex < 0) {\n                    return null;\n                }\n\n                newHeight = getIndexKey(heightIndex, aspectRatioHeights);\n                newWidth = this.calculateLongerDimensionByAspectRatio(newHeight, newAspectRatio);\n\n                return {\n                    resolution: Math.min(newHeight, newWidth),\n                    aspectRatio: newAspectRatio,\n                    height: parseInt(newHeight, 10),\n                    width: parseInt(newWidth, 10)\n                };\n            }\n\n            heightIndex--;\n        }\n\n        newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);\n        newAspectRatioHeights = getIndexValue(aspectRatioIndex, aspectRatios);\n        newHeight = getIndexKey(heightIndex, newAspectRatioHeights);\n        newWidth = newAspectRatioHeights[heightIndex][newHeight];\n\n        return {\n            resolution: Math.min(newHeight, newWidth),\n            aspectRatio: newAspectRatio,\n            height: parseInt(newHeight, 10),\n            width: newWidth\n        };\n    }\n\n    function getNextLowestResolution(height, aspectRatio) {\n        var aspectRatioHeights = getObjectValueInArray(aspectRatio, aspectRatios);\n        var aspectRatioIndex = getIndexInArray(aspectRatio, aspectRatios);\n        var heightIndex = getIndexInArray(height.toString(), aspectRatioHeights);\n        var isSmallestHeight = heightIndex === aspectRatioHeights.length - 1;\n        var isSmallestAspectRatio = aspectRatios.length - 1 === aspectRatioIndex;\n\n        var newAspectRatio;\n        var newAspectRatioHeights;\n        var newHeight;\n        var newWidth;\n\n        if (!_.isNumber(heightIndex)) {\n            heightIndex = getNextLowestKeyIndex(height, aspectRatioHeights);\n\n            if (!heightIndex) {\n                return;\n            }\n        } else {\n            if (isSmallestHeight) {\n                if (isSmallestAspectRatio) {\n                    return null;\n                }\n\n                aspectRatioIndex++;\n\n                newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);\n                newHeight = this._defaultResolutionHeight;\n                newWidth = this.calculateLongerDimensionByAspectRatio(newHeight, newAspectRatio);\n\n                return {\n                    resolution: Math.min(newHeight, newWidth),\n                    aspectRatio: newAspectRatio,\n                    height: parseInt(newHeight, 10),\n                    width: parseInt(newWidth, 10)\n                };\n            }\n\n            heightIndex++;\n        }\n\n        newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);\n        newAspectRatioHeights = getIndexValue(aspectRatioIndex, aspectRatios);\n        newHeight = getIndexKey(heightIndex, newAspectRatioHeights);\n        newWidth = newAspectRatioHeights[heightIndex][newHeight];\n\n        return {\n            resolution: Math.min(newHeight, newWidth),\n            aspectRatio: newAspectRatio,\n            height: parseInt(newHeight, 10),\n            width: parseInt(newWidth, 10)\n        };\n    }\n\n    function getObjectValueInArray(value, collection) {\n        var valueObject = _.find(collection, function(item) {\n            return Object.prototype.hasOwnProperty.call(item, value);\n        });\n\n        return valueObject ? valueObject[value] : null;\n    }\n\n    function getIndexInArray(value, collection) {\n        return _.findIndex(collection, function(item) {\n            return Object.prototype.hasOwnProperty.call(item, value);\n        });\n    }\n\n    function getIndexKey(index, collection) {\n        var keys = _.keys(collection[index]);\n\n        return keys[0];\n    }\n\n    function getIndexValue(index, collection) {\n        var keys = _.keys(collection[index]);\n\n        return collection[index][keys[0]];\n    }\n\n    function getNextHighestKeyIndex(value, collection) {\n        if ( _.keys(collection[0])[0] < value) {\n            return -1;\n        }\n\n        return _.reduce(collection, function(closestIndex, nextItem, index) {\n            if (!closestIndex) {\n                return index;\n            }\n\n            var currentClosestKey = _.keys(collection[closestIndex])[0];\n            var nextKey = _.keys(nextItem)[0];\n\n            if (nextKey < value) {\n                return closestIndex;\n            }\n\n            return Math.abs(value - nextKey) < Math.abs(value - currentClosestKey) ? index : closestIndex;\n        });\n    }\n\n    function getNextLowestKeyIndex(value, collection) {\n        if ( _.keys(collection[collection.length - 1])[0] > value) {\n            return null;\n        }\n\n        return _.reduce(collection, function(closestIndex, nextItem, index) {\n            if (!closestIndex) {\n                return index;\n            }\n\n            var currentClosestKey = _.keys(collection[closestIndex])[0];\n            var nextKey = _.keys(nextItem)[0];\n\n            if (nextKey > value) {\n                return closestIndex;\n            }\n\n            return Math.abs(value - nextKey) < Math.abs(value - currentClosestKey) ? index : closestIndex;\n        });\n    }\n\n    return ResolutionProvider;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n], function() {\n    'use strict';\n\n    var shakaEnums = {\n        errorSeverity: {\n            recoverable: {\n                id: 1,\n                name: 'RECOVERABLE'\n            },\n            critical: {\n                id: 2,\n                name: 'CRITICAL'\n            }\n        }\n    };\n\n    return shakaEnums;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    'phenix-web-observable',\n    'phenix-web-disposable',\n    './RoomExpress',\n    '../room/ChannelService',\n    '../room/Channel',\n    './MemberSelector',\n    '../room/Stream',\n    '../room/room.json',\n    '../room/member.json',\n    '../room/stream.json'\n], function(_, assert, observable, disposable, RoomExpress, ChannelService, Channel, MemberSelector, Stream, roomEnums, memberEnums, streamEnums) {\n    'use strict';\n\n    var defaultOptions = {\n        reconnectOptions: {\n            maxOfflineTime: 24 * 60 * 60 * 1000, // 1 day\n            maxReconnectFrequency: 60 * 1000 // 60 seconds\n        }\n    };\n    var backoffIntervalOnCapacity = 5000;\n    var backoffIntervalOnRetry = 100;\n\n    function ChannelExpress(options) {\n        assert.isObject(options, 'options');\n\n        if (options.roomExpress) {\n            assert.isObject(options.roomExpress, 'options.roomExpress');\n        }\n\n        this._channelExpressOptions = _.assign(_.clone(defaultOptions), options);\n\n        this._roomExpress = options.roomExpress || new RoomExpress(this._channelExpressOptions);\n        this._shouldDisposeOfRoomExpress = !options.roomExpress;\n        this._logger = this._roomExpress.getPCastExpress().getPCast().getLogger();\n    }\n\n    ChannelExpress.prototype.dispose = function dispose() {\n        if (this._pcastStatusSubscription) {\n            this._pcastStatusSubscription.dispose();\n            this._pcastStatusSubscription = null;\n        }\n\n        if (this._shouldDisposeOfRoomExpress) {\n            this._roomExpress.dispose();\n        }\n\n        this._logger.info('Disposed channel express instance');\n    };\n\n    ChannelExpress.prototype.getRoomExpress = function getRoomExpress() {\n        return this._roomExpress;\n    };\n\n    ChannelExpress.prototype.getPCastExpress = function getPCastExpress() {\n        return this._roomExpress.getPCastExpress();\n    };\n\n    ChannelExpress.prototype.createChannel = function createChannel(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isObject(options.channel, 'options.channel');\n\n        var createRoomOptions = _.assign({room: options.channel}, options);\n\n        createRoomOptions.room.type = roomEnums.types.channel.name;\n\n        delete createRoomOptions.channel;\n\n        this._roomExpress.createRoom(createRoomOptions, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    ChannelExpress.prototype.joinChannel = function joinChannel(options, joinChannelCallback, subscriberCallback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(joinChannelCallback, 'joinChannelCallback');\n        assert.isFunction(subscriberCallback, 'subscriberCallback');\n\n        if (options.videoElement) {\n            assert.isObject(options.videoElement, 'options.videoElement');\n        }\n\n        if (options.streamSelectionStrategy) {\n            assert.isStringNotEmpty(options.streamSelectionStrategy, 'options.streamSelectionStrategy');\n        }\n\n        var channelOptions = _.assign({\n            type: roomEnums.types.channel.name,\n            role: memberEnums.roles.audience.name\n        }, options);\n        var failureCountForBanningAMember = _.get(options, ['failureCountForBanningAMember']);\n        var banMemberOnCapacityFailureCount = _.get(options, ['banMemberOnCapacityFailureCount']);\n        var memberSelector = new MemberSelector(options.streamSelectionStrategy, this._logger, {\n            failureCountForBanningAMember: failureCountForBanningAMember,\n            banMemberOnCapacityFailureCount: banMemberOnCapacityFailureCount\n        });\n        var lastMediaStream;\n        var lastStreamId;\n        var memberSubscriptions = [];\n        var channelRoomService;\n        var channelId = '';\n        var that = this;\n        var memberSelectionBackoffTimeoutId = null;\n\n        if (channelOptions.channelId) {\n            channelOptions.roomId = channelOptions.channelId;\n        }\n\n        delete channelOptions.channelId;\n\n        var resetListeners = function() {\n            if (memberSelectionBackoffTimeoutId !== null) {\n                that._logger.info('[%s] Clearing member selection backoff interval', channelId);\n\n                clearTimeout(memberSelectionBackoffTimeoutId);\n                memberSelectionBackoffTimeoutId = null;\n            }\n\n            for (var i = 0; i < memberSubscriptions.length; i++) {\n                memberSubscriptions[i].dispose();\n            }\n\n            memberSubscriptions = [];\n        };\n\n        var joinRoomCallback = function(error, response) {\n            var channelResponse = !response || _.assign({}, response);\n\n            if (that._pcastStatusSubscription) {\n                that._pcastStatusSubscription.dispose();\n                that._pcastStatusSubscription = null;\n            }\n\n            if (response && response.roomService) {\n                var leaveRoom = response.roomService.leaveRoom;\n                var room = response.roomService.getObservableActiveRoom().getValue();\n\n                channelRoomService = response.roomService;\n                channelId = room ? room.getRoomId() : '';\n\n                that._logger.info('Joined channel [%s] with [%s] selection strategy', channelId, memberSelector.getStrategy());\n\n                channelResponse.roomService.leaveRoom = function(callback) {\n                    if (lastMediaStream) {\n                        lastMediaStream.stop('leave-channel');\n                    }\n\n                    resetListeners();\n\n                    leaveRoom(callback);\n                };\n            }\n\n            wrapResponseWithChannelPrefixesAndContinue(joinChannelCallback, error, channelResponse);\n        };\n\n        that._roomExpress.joinRoom(channelOptions, joinRoomCallback, function membersChangedCallback(members, streamErrorStatus) {\n            resetListeners();\n\n            that._logger.info('[%s] Members changed with status [%s]. Channel has [%s] active members.', channelId, streamErrorStatus, members.length);\n\n            var evaluateMembers = function() {\n                var presenters = _.filter(members, function(member) {\n                    return member.getObservableRole().getValue() === memberEnums.roles.presenter.name && member.getObservableStreams().getValue().length > 0;\n                });\n                var selectedPresenter = memberSelector.getNext(presenters);\n                var presenterStream = selectedPresenter ? selectedPresenter.getObservableStreams().getValue()[0] : null;\n                var streamId = presenterStream ? presenterStream.getPCastStreamId() : '';\n\n                if (!presenterStream) {\n                    if (presenters.length === 0) {\n                        memberSelector.reset();\n                        lastMediaStream = null;\n                        lastStreamId = null;\n\n                        return subscriberCallback(null, {status: 'no-stream-playing'});\n                    }\n\n                    if (streamErrorStatus) {\n                        that._logger.info('Unable to find a new presenter to replace stream [%s] that ended in channel [%s] with status [%s] and [%s] black-listed members',\n                            lastStreamId, channelId, streamErrorStatus, memberSelector.getNumberOfMembersWithFailures());\n\n                        if (lastStreamId && lastMediaStream && lastMediaStream.isActive()) {\n                            lastMediaStream.stop('presenter-failure');\n                        }\n\n                        return subscriberCallback(null, {status: streamErrorStatus || 'unable-to-recover'});\n                    }\n\n                    return subscriberCallback(null, {status: 'no-stream-playing'});\n                }\n\n                if (!streamId) {\n                    that._logger.info('Channel [%s] presenter has no stream', channelId);\n\n                    return subscriberCallback(null, {status: 'no-stream-playing'});\n                }\n\n                if (lastStreamId && lastMediaStream) {\n                    if (streamId === lastStreamId) {\n                        if (!streamErrorStatus) {\n                            // New member detected but staying on previous stream\n                            return;\n                        }\n\n                        that._logger.info('[%s] Stream [%s] ended with status [%s], retrying',\n                            channelId, lastStreamId, streamErrorStatus);\n                        lastMediaStream.stop('same-presenter-failure');\n                    } else {\n                        that._logger.info('[%s] Stream [%s] ended with status [%s], failing over to stream [%s]',\n                            channelId, lastStreamId, streamErrorStatus, streamId);\n                        lastMediaStream.stop('change-presenter');\n                    }\n                }\n\n                var tryNextMember = function(streamStatus) {\n                    if (memberSelectionBackoffTimeoutId !== null) {\n                        that._logger.warn('[%s] Clearing backoff interval after triggering of another unexpected failure [%s]', channelId, streamStatus);\n\n                        clearTimeout(memberSelectionBackoffTimeoutId);\n                        memberSelectionBackoffTimeoutId = null;\n                    }\n\n                    return memberSelectionBackoffTimeoutId = setTimeout(function() {\n                        memberSelectionBackoffTimeoutId = null;\n\n                        var room = channelRoomService ? channelRoomService.getObservableActiveRoom().getValue() : null;\n\n                        if (!room) {\n                            return; // No longer in room.\n                        }\n\n                        var members = room.getObservableMembers().getValue();\n\n                        return membersChangedCallback(members, streamStatus);\n                    }, streamStatus === 'capacity' ? backoffIntervalOnCapacity : backoffIntervalOnRetry);\n                };\n\n                function monitorChannelSubscriber(mediaStreamId, error, response) {\n                    if (lastStreamId !== mediaStreamId) {\n                        that._logger.info('[%s] Ignore old channel subscriber monitor stream [%s]. Active stream is [%s]', channelId, mediaStreamId, lastStreamId);\n\n                        return;\n                    }\n\n                    if (error) {\n                        return tryNextMember('unable-to-subscribe');\n                    }\n\n                    // Don't continue - Tell client\n                    if (response.reason === 'app-background') {\n                        return subscriberCallback(error, response);\n                    }\n\n                    if (response.retry && memberSelector.getStrategy() !== 'high-availability') {\n                        that._logger.info('Retrying to subscribe to channel [%s] after stream [%s] failed with reason [%s]',\n                            channelId, mediaStreamId, response.status);\n\n                        return response.retry();\n                    }\n\n                    var responseStatus = _.get(response, ['status'], '');\n\n                    if (responseStatus !== 'ok') {\n                        if (response.reason === 'custom' && response.description !== 'client-side-failure') {\n                            return subscriberCallback(error, response);\n                        }\n\n                        switch (responseStatus) {\n                        case 'ended':\n                        case 'origin-ended':\n                        case 'origin-stream-ended':\n                            memberSelector.markDead();\n\n                            break;\n                        default:\n                            memberSelector.markFailed({failedDueToCapacity: responseStatus === 'capacity'});\n\n                            break;\n                        }\n\n                        that._logger.info('[%s] Monitor subscriber reported status [%s]. Trying next member', mediaStreamId, responseStatus);\n\n                        return tryNextMember(responseStatus);\n                    }\n                }\n\n                var subscribeOptions = _.assign({}, {\n                    monitor: {\n                        callback: _.bind(monitorChannelSubscriber, this, streamId),\n                        options: {conditionCountForNotificationThreshold: 8}\n                    }\n                }, options);\n                var hadPreviousStreamReason = streamErrorStatus ? 'recovered-from-failure' : 'stream-override';\n                var successReason = lastStreamId ? hadPreviousStreamReason : 'stream-started';\n\n                lastStreamId = streamId;\n\n                var mediaStreamCallback = function mediaStreamCallback(mediaStreamId, error, response) {\n                    if (lastStreamId !== mediaStreamId) {\n                        that._logger.info('[%s] Ignore old media stream callback for stream [%s]. Active stream is [%s]', channelId, mediaStreamId, lastStreamId);\n\n                        return;\n                    }\n\n                    var responseStatus = _.get(response, ['status'], '');\n\n                    if (responseStatus === 'ok') {\n                        response.reason = successReason;\n                    }\n\n                    if (error || (responseStatus !== 'ok')) {\n                        that._logger.info('[%s] Issue with stream [%s]. Trying next member', mediaStreamId, responseStatus, error);\n\n                        switch (responseStatus) {\n                        case 'unauthorized':\n                        case 'not-found':\n                        case 'ended':\n                        case 'origin-not-found':\n                        case 'origin-ended':\n                        case 'origin-stream-ended':\n                        case 'unsupported-features':\n                            memberSelector.markDead();\n\n                            break;\n                        default:\n                            memberSelector.markFailed({failedDueToCapacity: responseStatus === 'capacity'});\n\n                            break;\n                        }\n\n                        return tryNextMember(responseStatus);\n                    }\n\n                    if (response && response.mediaStream) {\n                        lastMediaStream = response.mediaStream;\n                    } else {\n                        lastStreamId = null;\n                        lastMediaStream = null;\n                    }\n\n                    subscriberCallback(error, response);\n                };\n\n                that._roomExpress.subscribeToMemberStream(presenterStream, subscribeOptions, _.bind(mediaStreamCallback, this, streamId));\n            };\n\n            for (var i = 0; i < members.length; i++) {\n                memberSubscriptions.push(members[i].getObservableScreenName().subscribe(evaluateMembers));\n                memberSubscriptions.push(members[i].getObservableRole().subscribe(evaluateMembers));\n                memberSubscriptions.push(members[i].getObservableStreams().subscribe(evaluateMembers));\n            }\n\n            evaluateMembers();\n        });\n    };\n\n    ChannelExpress.prototype.publishToChannel = function publishToChannel(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        if (options.publishToken && options.capabilities) {\n            this._logger.warn('[%s] Trying to publish with both `publishToken` and `capabilities` set. Only use one of the two options');\n\n            callback(new Error('Publishing with both `publishToken` and `capabilities` defined'), {status: 'conflicting-options'});\n\n            return;\n        }\n\n        if (options.streamToken && options.capabilities) {\n            this._logger.warn('[%s] Trying to publish with both `streamToken` and `capabilities` set. Only use one of the two options');\n\n            callback(new Error('Publishing with both `streamToken` and `capabilities` defined'), {status: 'conflicting-options'});\n\n            return;\n        }\n\n        var channelOptions = _.assign({\n            memberRole: memberEnums.roles.presenter.name,\n            streamType: streamEnums.types.presentation.name,\n            room: options.channel\n        }, options);\n\n        channelOptions.room.type = roomEnums.types.channel.name;\n\n        delete channelOptions.channel;\n\n        this._roomExpress.publishToRoom(channelOptions, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    ChannelExpress.prototype.publishScreenToChannel = function publishScreenToChannel(options, callback) {\n        assert.isObject(options, 'options');\n        assert.isFunction(callback, 'callback');\n\n        var channelOptions = _.assign({\n            memberRole: memberEnums.roles.presenter.name,\n            streamType: streamEnums.types.presentation.name,\n            room: options.channel\n        }, options);\n\n        channelOptions.room.type = roomEnums.types.channel.name;\n\n        delete channelOptions.channel;\n\n        this._roomExpress.publishScreenToRoom(channelOptions, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    function wrapResponseWithChannelPrefixesAndContinue(callback, error, response) {\n        if (response && _.hasIndexOrKey(response, 'roomService')) {\n            response.channelService = response.roomService ? new ChannelService(response.roomService) : null;\n\n            delete response.roomService;\n        }\n\n        if (response && _.hasIndexOrKey(response, 'room')) {\n            response.channel = response.room ? new Channel(response.room) : null;\n\n            delete response.room;\n        }\n\n        callback(error, response);\n    }\n\n    return ChannelExpress;\n});","/**\n * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndefine([\n    'phenix-web-lodash-light',\n    'phenix-web-assert',\n    './Channel'\n], function(_, assert, Channel) {\n    'use strict';\n\n    function ChannelService(roomService) {\n        assert.isObject(roomService, 'roomService');\n\n        this._roomService = roomService;\n    }\n\n    ChannelService.prototype.start = function start() {\n        return this._roomService.start.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.getChannelInfo = function getChannelInfo(channelId, alias, callback) {\n        if (channelId) {\n            assert.isStringNotEmpty(channelId, 'channelId');\n        } else {\n            assert.isStringNotEmpty(alias, 'alias');\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        return this._roomService.getRoomInfo(channelId, alias, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    ChannelService.prototype.createChannel = function createChannel(channel, callback) {\n        assert.isObject(channel, 'channel');\n        assert.isStringNotEmpty(channel.name, 'channel.name');\n        assert.isStringNotEmpty(channel.type, 'channel.type');\n        assert.isString(channel.description, 'channel.description');\n        assert.isFunction(callback, 'callback');\n\n        return this._roomService.createRoom(channel, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    ChannelService.prototype.enterChannel = function enterChannel(channelId, alias, callback) {\n        if (channelId) {\n            assert.isStringNotEmpty(channelId, 'roomId');\n        } else {\n            assert.isStringNotEmpty(alias, 'alias');\n        }\n\n        assert.isFunction(callback, 'callback');\n\n        return this._roomService.enterRoom(channelId, alias, _.bind(wrapResponseWithChannelPrefixesAndContinue, null, callback));\n    };\n\n    ChannelService.prototype.leaveChannel = function leaveChannel() {\n        return this._roomService.leaveRoom.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.getChatService = function getChatService() {\n        return this._roomService.getChatService.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.getSelf = function getSelf() {\n        return this._roomService.getSelf.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.getObservableActiveChannel = function getObservableActiveChannel() {\n        return this._roomService.getObservableActiveRoom.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.updateSelf = function updateSelf() {\n        return this._roomService.updateSelf.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.updateMember = function updateMember() {\n        return this._roomService.updateMember.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.updateChannel = function updateChannel() {\n        return this._roomService.updateRoom.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.revertChannelChanges = function revertChannelChanges() {\n        return this._roomService.revertRoomChanges.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.revertMemberChanges = function revertMemberChanges() {\n        return this._roomService.revertMemberChanges.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.isInChannel = function isInChannel() {\n        return this._roomService.isInRoom.apply(this._roomService, arguments);\n    };\n\n    ChannelService.prototype.toString = function toString() {\n        return 'ChannelService';\n    };\n\n    ChannelService.prototype.stop = function stop() {\n        return this._roomService.stop.apply(this._roomService, arguments);\n    };\n\n    function wrapResponseWithChannelPrefixesAndContinue(callback, error, response) {\n        if (response && response.room) {\n            response.channel = new Channel(response.room);\n\n            delete response.room;\n        }\n\n        return callback(error, response);\n    }\n\n    return ChannelService;\n});"],"sourceRoot":""}